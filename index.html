<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coachex-Pro – Gestión para Profesores</title>
  
<script src="https://cdn.tailwindcss.com"></script>

<script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>



  <style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    
  }
</style>
<link rel="icon" type="image/png" href="./img/logo_favicon.png">
<link rel="apple-touch-icon" href="./img/logo_favicon.png">
<meta name="theme-color" content="#34745B">

<style id="dual-pulse-loader">
    :root{
      --loader-brand-dark:#34745B;   /* verde del logo */
      --loader-brand-light:#89C5B2;  /* verde claro de la app */
      --loader-inner:#3f3f41;        /* gris interno */
      --loader-size:56px;            /* tamaño */
    }
    .loader{
      width:var(--loader-size);
      height:var(--loader-size);
      border-radius:50%;
      position:relative;
      background: radial-gradient(circle at 30% 30%, var(--loader-brand-light), var(--loader-brand-dark));
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      animation: loader-pulse-out 1.5s ease-in-out infinite;
      transform-origin:center center;
    }
    .loader::after{
      content:"";
      position:absolute; inset:0; margin:auto;
      width:58%; height:58%;
      border-radius:50%;
      background: var(--loader-inner);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.85);
      animation: loader-pulse-in 1.5s ease-in-out infinite;
      transform-origin:center center;
    }
    @keyframes loader-pulse-out{
      0%,100%{ transform:scale(1); opacity:1; }
      50%    { transform:scale(1.18); opacity:.85; }
    }
    @keyframes loader-pulse-in{
      0%,100%{ transform:scale(1); opacity:.9; }
      50%    { transform:scale(0.82); opacity:.75; }
    }
    @media (prefers-reduced-motion: reduce){
      .loader, .loader::after{ animation:none; }
    }
  </style>


<style id="a4-clean-export-styles">
/* A4 CLEAN EXPORT v2 */
#a4-sheet{width:1123px;min-height:794px;background:#fff;color:#0f172a;padding:40px 48px;box-sizing:border-box;border-radius:12px;box-shadow:0 0 0 1px rgba(0,0,0,.04)}
#a4-header{display:flex;flex-direction:column;align-items:center;gap:8px;margin-bottom:12px}
#a4-brand{display:flex;align-items:center;justify-content:center;gap:10px;font-weight:800;font-size:22px;margin:0 auto}
#a4-brand img{width:28px;height:28px;border-radius:9999px;object-fit:cover}
#a4-title{font-size:26px;line-height:1.2;font-weight:800;text-align:center;margin-top:4px}
#a4-sub{font-size:12px;line-height:1.5;color:#64748b;text-align:center}
#a4-section{margin-top:16px;display:flex;flex-direction:column;gap:8px}
.a4-card{border:1px solid #e2e8f0;border-radius:10px;padding:10px}
.a4-grid{display:grid;grid-template-columns:1fr;gap:10px}
.a4-row{display:flex;justify-content:space-between;gap:10px;font-size:12px;line-height:1.4}
.a4-muted{color:#64748b}
.a4-item{
  border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px;line-height:1.4;white-space:normal;word-break:break-word
}
#a4-sheet a{color:#0ea5e9;text-decoration:none}
</style>

</head>
<body>
  
  <div id="root"></div>

  <script type="text/babel">


    // --- INICIO DEL CÓDIGO DE LA APLICACIÓN ---

    const { useEffect, useMemo, useState, createContext, useContext } = React;

    /**
     * Gestión de Pádel – MVP en React (Canvas) - v25 con Perfil Extendido
     *
     * Cambios aplicados:
     * - (PERFIL) Se añaden secciones para Datos Bancarios, Horario Laboral y Políticas de Cancelación.
     * - (PERFIL) Se añade funcionalidad para copiar datos bancarios al portapapeles.
     * - (CALENDARIO) El calendario ahora lee el Horario Laboral y sombrea las horas no disponibles.
     */

    // ------------------------------ Configuración de Firebase ------------------------------
    const firebaseConfig = {
      apiKey: "AIzaSyDU33ryp3wkbx0oJdhjC6pG3VkfNiqGk0Q",
      authDomain: "coachex-b1d9b.firebaseapp.com",
      projectId: "coachex-b1d9b",
      storageBucket: "coachex-b1d9b.appspot.com",
      messagingSenderId: "894665560100",
      appId: "1:894665560100:web:e8a61e0849f7675e1f88b1"
    };

    // Inicializar Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const _db = db;

function pagosRef(user, clubId){
  return db.collection("users").doc(user.uid).collection("clubs").doc(clubId).collection("pagos");
}
function clasesRef(user, clubId){
  return db.collection("users").doc(user.uid).collection("clubs").doc(clubId).collection("clases");
}
function mensualidadesRef(user, clubId){
  return db.collection("users").doc(user.uid).collection("clubs").doc(clubId).collection("mensualidades");
}

// === Sumar puntos a un ranking concreto: rankings/{rankingId}/items/{jugadorId} ===
async function updateRankingPuntosEn(clubId, rankingId, jugadorId, delta, extraStats = {}) {
  try {
    const uid = firebase.auth().currentUser?.uid;
    if (!uid) { console.warn("updateRankingPuntosEn: no hay usuario"); return; }
    if (!clubId || !rankingId || !jugadorId) { console.warn("updateRankingPuntosEn args inválidos", {clubId, rankingId, jugadorId}); return; }

    const ref = db.collection('users').doc(String(uid))
      .collection('clubs').doc(String(clubId))
      .collection('rankings').doc(String(rankingId))
      .collection('items').doc(String(jugadorId));

    await ref.set({
      puntos: firebase.firestore.FieldValue.increment(Number(delta || 0)),
      pj:     firebase.firestore.FieldValue.increment(Number(extraStats.pj || 0)),
      pg:     firebase.firestore.FieldValue.increment(Number(extraStats.pg || 0)),
      pe:     firebase.firestore.FieldValue.increment(Number(extraStats.pe || 0)),
      pp:     firebase.firestore.FieldValue.increment(Number(extraStats.pp || 0)),
      wo:     firebase.firestore.FieldValue.increment(Number(extraStats.wo || 0)),
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  } catch (e) {
    console.error('updateRankingPuntosEn error', e);
  }
}

// (Opcional) Mantener el nombre viejo para no romper llamadas antiguas
async function updateRankingPuntos(clubId, jugadorId, puntos) {
  const rankingId = window.__rankingDefaultId || null; // si querés un default global
  if (!rankingId) { console.warn('No hay ranking destino por defecto.'); return; }
  return updateRankingPuntosEn(clubId, rankingId, jugadorId, puntos, { pj: 1 });
}

function Page({ children }) {
  return (
    <div className="py-6 md:py-8 px-6 sm:px-8 lg:px-12 xl:px-16">
      <div className="max-w-[1200px] mx-auto">
        {children}
      </div>
    </div>
  );
}
    
  
    // ------------------------------ Constantes y Utilidades ------------------------------
    const initialState = { 
      alumnos: [], 
      clases: [], 
      pagos: [], 
      gastos: [],
      perfil: {
        nombre: "Profe",
        apellido: "Pádel",
        telefono: "",
        precios: {},
        preciosMensuales: {},
        metodoCobro: "porClase",
        modoTrabajo: "Club",
        canchas: "Club A - Cancha 1\nClub B - Cancha 2",
        // --- NUEVOS CAMPOS AÑADIDOS ---
        datosBancarios: {
          alias: "",
          cbu: "",
          banco: "",
          titular: ""
        },
        politicasCancelacion: "Las clases deben cancelarse con 24hs de antelación para no ser cobradas.",
        horarioLaboral: [
          { dia: "Lunes", activo: true, desde: "09:00", hasta: "20:00" },
          { dia: "Martes", activo: true, desde: "09:00", hasta: "20:00" },
          { dia: "Miércoles", activo: true, desde: "09:00", hasta: "20:00" },
          { dia: "Jueves", activo: true, desde: "09:00", hasta: "20:00" },
          { dia: "Viernes", activo: true, desde: "09:00", hasta: "20:00" },
          { dia: "Sábado", activo: false, desde: "10:00", hasta: "14:00" },
          { dia: "Domingo", activo: false, desde: "10:00", hasta: "14:00" },
        ]
        // --- FIN DE NUEVOS CAMPOS ---
      }
    };
    
    const DIAS_SEMANA_NOMBRES = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"];
    const MESES_NOMBRES = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
    const DEPORTES = ["Pádel", "Tenis"];
    const ESTADOS_ALUMNO = [{value: "activo", label: "Activo"}, {value: "espera", label: "Lista de espera"}];
    const ESTADOS_CLASE = ["Programada", "Realizada", "Cancelada", "Ausente"];
const TIPOS_CLASE_MAP = { "Clase 1 persona": 1, "Clase 2 personas": 2, "Clase 3 personas": 3, "Clase 4 personas": 4, Escuelita: 1 };
const TIPOS_CLASE = Object.keys(TIPOS_CLASE_MAP);

const PRECIO_KEY_POR_TIPO = {
  "Clase 1 persona": "individual",
  "Clase 2 personas": "dupla",
  "Clase 3 personas": "trio",
  "Clase 4 personas": "cuarteto",
  "Escuelita": "escuelita"
};

// Mapeo consistente de 'tipo' -> clave de precios del perfil
function normalizarTipoClase(t) {
  // [ ... TU FUNCIÓN normalizarTipoClase COMPLETA ... ]
  if (!t) return "Clase 1 persona";
  // Convertimos el argumento a una cadena de texto de forma segura
  const s = String(t)
    .trim().toLowerCase()
    .replace(/clase\s+para\s+/, '')
    .replace(/^clase\s+/, '')
    .replace(/\s+de\s+/, ' ')
    .replace(/\s+/g, ' ');

  const alias = {
    'individual': 'Clase 1 persona',
    '1': 'Clase 1 persona',
    '1 persona': 'Clase 1 persona',

    'dupla': 'Clase 2 personas',
    '2': 'Clase 2 personas',
    '2 personas': 'Clase 2 personas',

    'trio': 'Clase 3 personas',
    '3': 'Clase 3 personas',
    '3 personas': 'Clase 3 personas',

    'cuarteto': 'Clase 4 personas',
    '4': 'Clase 4 personas',
    '4 personas': 'Clase 4 personas',

    'escuelita': 'Escuelita'
  };
  if (alias[s]) return alias[s];

  const m = s.match(/^(\d)\s*personas?$/);
  if (m) {
    const n = Number(m[1]);
    return n === 1 ? 'Clase 1 persona' : `Clase ${n} personas`;
  }
  return TIPOS_CLASE.includes(s) ? s : 'Clase 1 persona';
}
const getPrecioSugerido = (tipo, perfil) => {
  const key = PRECIO_KEY_POR_TIPO[tipo] || "individual";

  // CORRECCIÓN: Busca en preciosClase (nuevo) o precios (antiguo)
  const tabla = (perfil && perfil.preciosClase) 
    ? perfil.preciosClase 
    : ((perfil && perfil.precios) ? perfil.precios : {});

  function resolveTipoEfectivo(tipoOriginal, alumnoIds) {
  const n = (alumnoIds || []).filter(Boolean).length;

  // Si ya es Escuelita, respetamos
  if (String(tipoOriginal).trim().toLowerCase() === 'escuelita') return 'Escuelita';

  // Si hay 4 o más, usamos Escuelita
  if (n >= 4) return 'Escuelita';

  // Caso contrario, mantenemos el tipo declarado
  return tipoOriginal;
}


const computePrecioClase = (tipo, alumnoIds, perfil, alumnoMap) => {
  // 👇 ajustar tipo según cantidad (4+ => Escuelita)
  const tipoEfectivo = resolveTipoEfectivo(tipo, alumnoIds);

  // precio por alumno según el tipo efectivo
  const perAlumno = parseFloat(getPrecioSugerido(tipoEfectivo, perfil) || 0);

  const ids = (alumnoIds || []).filter(Boolean);

  // Si aún no hay IDs, usamos el fallback del tipo *original*
  const fallbackCount = TIPOS_CLASE_MAP[tipo] || 1;

  // Contar cuántos NO son mensuales (para cobrarles por clase)
  const noMensuales = ids.filter(id => {
    const a = alumnoMap.get(id);
    return a ? (a.plan !== 'mensual') : true;
  }).length;

  const count = ids.length > 0 ? (noMensuales || ids.length) : fallbackCount;

  return (perAlumno * count).toString();
};

  return tabla[key] ?? "";
};

    const TIPOS_CLASE_NOMBRES = { "Clase 1 persona": "Clase 1 persona", "Clase 2 personas": "Clase 2 personas", "Clase 3 personas": "Clase 3 personas", "Clase 4 personas": "Clase 4 personas", Escuelita: "Escuelita" };
    const METODOS_PAGO = ["Efectivo", "Transferencia", "Mixto", "Mensual","Pendiente"];
    const CATEGORIAS_GASTO = ["Alquiler", "Equipamiento", "Servicios", "Varios"];
    // Alias para compatibilidad con componentes que usan CATEGORIAS_GASTOS
    const CATEGORIAS_GASTOS = CATEGORIAS_GASTO;

    const PLANES_PAGO = [{value: "porClase", label: "Por Clase"}, {value: "mensual", label: "Mensual"}];
    const FRECUENCIAS_MENSUALES = [{value: "1xSemana", label: "1 vez por semana"}, {value: "2xSemana", label: "2 veces por semana"}, {value: "3xSemana", label: "3 veces por semana"}, {value: "libre", label: "Libre"}];
    const MESES_RECURRENCIA = [1, 2, 3, 4, 5, 6, 9, 12];
    const HORAS = Array.from({ length: 16 }, (_, i) => `${String(i + 7).padStart(2, '0')}:00`); // De 07:00 a 22:00
    
    // --- Utilidades ---
// Quita "Clase" o "Clase para" del nombre canónico para evitar "clase de Clase ..."
function labelSinClase(tipo) {
  const base = (TIPOS_CLASE_NOMBRES?.[tipo] ?? tipo ?? '').trim();
  return base.replace(/^Clase\s+(?:para\s+)?/i, '').trim();
}
    const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
    const toDigits = (s = "") => String(s).replace(/[^0-9]/g, "");
    const waLink = (telefono = "", nombre = "") => {
      const digits = toDigits(telefono);
      if (!digits) return null;
      const msg = encodeURIComponent(`Hola ${nombre || ""}!`);
      return `https://wa.me/${digits}?text=${msg}`;
    };
    const getWeekStartDate = (date) => {
      const d = new Date(date);
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      d.setHours(0, 0, 0, 0);
      return new Date(d.setDate(diff));
    };
    const parseYMDLocal = (ymd) => {
  if (!ymd || typeof ymd !== 'string') return null;
  const [y, m, d] = ymd.split('-').map(Number);
  return new Date(y, (m || 1) - 1, d || 1, 0, 0, 0, 0);
};
    const addDays = (date, days) => {
  const base = (date instanceof Date) ? date : parseYMDLocal(String(date)) || new Date(date);
  const y = base.getFullYear(), m = base.getMonth(), d = base.getDate();
  return new Date(y, m, d + Number(days || 0), 0, 0, 0, 0);
};
    const formatDate = (date, format = 'yyyy-mm-dd') => {
  if (!date) return '';
  const d = (typeof date === 'string') ? parseYMDLocal(date) : new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  if (format === 'dd/mm') return `${day}/${month}`;
  if (format === 'dd/mm/yyyy') return `${day}/${month}/${year}`;
  return `${year}-${month}-${day}`;
};
// Devuelve "Lunes 08/09/2025"
function labelDiaConFecha(yyyy_mm_dd) {
  const d = new Date(`${yyyy_mm_dd}T00:00:00`);
  const dayIdx = (d.getDay() === 0 ? 6 : d.getDay() - 1); // 0..6 (Lun..Dom)
  const nombre = DIAS_SEMANA_NOMBRES[dayIdx] || "";
  return `${nombre} ${formatDate(yyyy_mm_dd, 'dd/mm/yyyy')}`;
}
// Frecuencias incluidas por plan
const FRECUENCIAS_MENSUALES_INCLUIDAS = {
  "1xSemana": 4, "2xSemana": 8, "3xSemana": 12, "libre": 9999
};

const esClaseQueGeneraCobro = (c) =>
  ['realizada', 'ausente'].includes(String(c?.estado || '').toLowerCase());

const mesClave = (date) => {
  const d = (typeof date === 'string') ? parseYMDLocal(date) : (date instanceof Date ? date : new Date(date));
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  return `${y}-${m}`;
};

// Lee precios mensuales desde Perfil
function calcularMensualidadDesdePerfil(perfil, alumno) {
  const freq = alumno?.frecuencia || "1xSemana";

  // Cantidades incluidas (esto NO es precio)
  const mapIncl = { "1xSemana": 4, "2xSemana": 8, "3xSemana": 12, "4xSemana": 16, "libre": 9999 };
  const incluidas = mapIncl[freq] ?? 4;

  // ✅ SOLO Perfil -> preciosMensuales
  const raw = perfil?.preciosMensuales?.[freq];

  // Devolvé el monto crudo convertido a número (si no está, queda NaN/0 y lo validamos en el flujo)
  const monto = Number(raw);

  return { incluidas, monto };
}

// Crea/asegura doc de mensualidad del mes
async function ensureMensualidadParaAlumno({ user, clubId, alumno, fechaRef, perfil }) {
  if (!user || !clubId || !alumno) return null;
  const mes = mesClave(fechaRef || new Date());
  const id = `${alumno.id}_${mes}`;
  const ref = mensualidadesRef(user, clubId).doc(id);
  const snap = await ref.get();
  if (snap.exists) return { id, ...snap.data() };

  const freq = alumno.frecuencia || '1xSemana';
  const incl = FRECUENCIAS_MENSUALES_INCLUIDAS[freq] ?? 4;
  const monto = String(perfil?.preciosMensuales?.[freq] ?? "");

  const nueva = {
  alumnoId: alumno.id, mes, frecuencia: freq,
  incluidas: incl, consumidas: 0,
  monto,                            // ← queda "" si el profe no cargó nada
  deudaExtra: "0", pagado: false, estado: "pendiente",
  creadoEn: firebase.firestore.FieldValue.serverTimestamp()
};
  await ref.set(nueva, { merge: true });
  return { id, ...nueva };
}

// Registrar pago de cuota
async function acreditarCuotaMensual({ user, clubId, alumno, mensualidad }) {
  const monto = Number(mensualidad?.monto || 0);
  const mes   = mensualidad?.mes;
  const concepto = `Cuota Mensual - ${mes}`;
  await pagosRef(user, clubId).add({
    alumnoId: alumno.id,
    fecha: new Date().toISOString().slice(0,10), // YYYY-MM-DD
    concepto, monto, metodo: "Mensual", mes
  });
  await mensualidadesRef(user, clubId).doc(mensualidad.id).set({
    pagado: true, pagadoEn: new Date().toISOString()
  }, { merge: true });
}

// Consumir 1 clase del abono (suma deuda extra si se excede)
async function consumirClaseMensual({ user, clubId, alumno, fechaClase, perfil, excedentePorClase = "0" }) {
  const m = await ensureMensualidadParaAlumno({ user, clubId, alumno, fechaRef: fechaClase, perfil });
  if (!m) return;
  const ref = mensualidadesRef(user, clubId).doc(m.id);
  const consumidas = Number(m.consumidas || 0) + 1;
  let deudaExtra = Number(m.deudaExtra || 0);
  const incl = Number(m.incluidas || 0);
  const updates = { consumidas };
  if (consumidas > incl) {
    deudaExtra += Number(excedentePorClase || 0);
    updates.deudaExtra = String(deudaExtra);
  }
  await ref.set(updates, { merge: true });
}

// Cubrir clase con abono si tiene cupo; si no, suma excedente
async function cubrirClaseConMensualidadSiCorresponde({ user, clubId, alumno, claseId, fecha, precioPorAlumno, perfil }) {
  const fechaNorm = typeof fecha === "string" ? new Date(`${fecha}T00:00:00`) : fecha;
  const m = await ensureMensualidadParaAlumno({ user, clubId, alumno, perfil, fechaRef: fechaNorm });
  if (!m) return;

  const incl = Number(m.incluidas || 0);
  const cons = Number(m.consumidas || 0);
  const tieneCupo = cons < incl;

  if (tieneCupo) {
    const q = await pagosRef(user, clubId).where("claseId", "==", claseId).get();
    const yaExiste = q.docs.some(d => {
      const p = d.data();
      return p.alumnoId === alumno.id && p.metodo === "Mensual";
    });
    if (!yaExiste) {
      await pagosRef(user, clubId).add({
        claseId, alumnoId: alumno.id, fecha,
        concepto: `Cubre por abono - ${m.mes || ""}`,
        monto: "0", metodo: "Mensual"
      });
    }
  }
  const excedente = tieneCupo ? "0" : String(precioPorAlumno || 0);
  await consumirClaseMensual({ user, clubId, alumno, fechaClase: fecha, perfil, excedentePorClase: excedente });
}

// --- Exigir abono del mes (abre el modal) y, si confirma, acredita la cuota ---
async function exigirAbonoDelMesOAvisar({ user, clubId, alumno, perfil, fechaClase, abrirModalPago }) {
  const mensualidad = await ensureMensualidadParaAlumno({ user, clubId, alumno, perfil, fechaRef: fechaClase });
  if (!mensualidad) return;
  if (mensualidad.pagado) return;

  // 🚧 Si NO hay precio configurado en Perfil → Precios Mensuales, avisá y salí
  const montoNum = Number(mensualidad.monto);
  if (!montoNum || isNaN(montoNum) || montoNum <= 0) {
    alert(`Falta configurar el precio mensual para la frecuencia "${alumno.frecuencia || '1xSemana'}" en Perfil → Precios Mensuales.`);
    return;
  }

  const confirmado = await abrirModalPago(alumno, mensualidad.mes, montoNum);
  if (confirmado) {
    await acreditarCuotaMensual({ user, clubId, alumno, mensualidad });
  }
}

// ---------- Helpers de meses ----------
function mesSiguiente(m) { // "YYYY-MM" -> siguiente
  const [y, mm] = m.split('-').map(Number);
  const d = new Date(y, mm - 1, 1);
  d.setMonth(d.getMonth() + 1);
  const y2 = d.getFullYear();
  const m2 = String(d.getMonth() + 1).padStart(2, '0');
  return `${y2}-${m2}`;
}
function rangoMeses(desdeMes, hastaMes) { // inclusive
  const res = [];
  let cur = desdeMes;
  while (cur <= hastaMes) {
    res.push(cur);
    cur = mesSiguiente(cur);
  }
  return res;
}

// ---------- Pagar excedente manual (NO toca pago por clase) ----------
async function acreditarExcedenteMensual({ user, clubId, alumno, mes, monto, metodo = "Efectivo" }) {
  if (!user || !clubId || !alumno || !mes) return;
  await pagosRef(user, clubId).add({
    alumnoId: alumno.id,
    fecha: new Date().toISOString().slice(0,10), // YYYY-MM-DD
    concepto: `Excedente Mensual - ${mes}`,
    monto: Number(monto || 0),
    metodo,
    mes
  });
}

// ---------- Construye la cuenta corriente por meses ----------
async function buildCuentaCorrienteMensual({ user, clubId, alumno, perfil, desdeMes, hastaMes }) {
  if (!user || !clubId || !alumno) return { lineas: [], saldoAcumulado: 0 };

  // Traigo mensualidades en rango
  const mensSnap = await mensualidadesRef(user, clubId)
    .where('alumnoId', '==', alumno.id)
    .where('mes', '>=', desdeMes)
    .where('mes', '<=', hastaMes)
    .get();

  const mensualidades = {};
  mensSnap.docs.forEach(d => {
    const m = d.data();
    mensualidades[m.mes] = { id: d.id, ...m };
  });

  // Traigo pagos etiquetados con "mes" (cuotas, excedentes, etc.)
  const pagosSnap = await pagosRef(user, clubId)
    .where('alumnoId', '==', alumno.id)
    .where('mes', '>=', desdeMes)
    .where('mes', '<=', hastaMes)
    .get();

  const pagos = pagosSnap.docs.map(d => d.data());

  // Indexo pagos por mes
  const pagosPorMes = {};
  pagos.forEach(p => {
    const k = p.mes || '—';
    if (!pagosPorMes[k]) pagosPorMes[k] = [];
    pagosPorMes[k].push(p);
  });

  const meses = rangoMeses(desdeMes, hastaMes);
  let saldoAcumulado = 0;
  const lineas = meses.map(mes => {
    // Aseguro tener mensualidad (pero SIN crear nada en DB)
    const men = mensualidades[mes] || {
      alumnoId: alumno.id,
      mes,
      frecuencia: alumno.frecuencia || '1xSemana',
      incluidas: ({"1xSemana":4,"2xSemana":8,"3xSemana":12,"4xSemana":16,"libre":9999}[alumno.frecuencia || '1xSemana']) ?? 4,
      consumidas: 0,
      monto: String(perfil?.preciosMensuales?.[alumno.frecuencia || '1xSemana'] ?? ""),
      deudaExtra: "0",
      pagado: false
    };

    const cuota = Number(men.monto || 0);
    const excedente = Number(men.deudaExtra || 0);

    const lst = pagosPorMes[mes] || [];
    const pagCuota = lst
      .filter(p => p.concepto?.startsWith('Cuota Mensual'))
      .reduce((acc, p) => acc + Number(p.monto || 0), 0);
    const pagExced = lst
      .filter(p => p.concepto?.startsWith('Excedente Mensual'))
      .reduce((acc, p) => acc + Number(p.monto || 0), 0);

    const totalAPagar = cuota + excedente;
    const pagosMes = pagCuota + pagExced;
    const saldoMes = totalAPagar - pagosMes;
    saldoAcumulado += saldoMes;

    return {
      mes,
      incluidas: Number(men.incluidas || 0),
      consumidas: Number(men.consumidas || 0),
      cuota,
      excedente,
      pagCuota,
      pagExced,
      pagosMes,
      totalAPagar,
      saldoMes,
      saldoAcumulado,
      pagado: men.pagado === true
    };
  });

  return { lineas, saldoAcumulado };
}


    const getNombreCompleto = (a) => a ? `${a.apellido || ''} ${a.nombre || ''}`.trim() : 'Alumno eliminado';
// --- Searchable alumno picker (reusable) ---
function AlumnoSearchSelect({ value, onChange, alumnos, excludeIds = [], placeholder = "Buscar alumno...", autoFocus = false }) {
  const [open, setOpen] = React.useState(false);
  const [q, setQ] = React.useState("");
  const inputRef = React.useRef(null);
  const boxRef = React.useRef(null);

  React.useEffect(() => {
    if (autoFocus && inputRef.current) inputRef.current.focus();
  }, [autoFocus]);

  React.useEffect(() => {
    function handleClickOutside(e) {
      if (boxRef.current && !boxRef.current.contains(e.target)) setOpen(false);
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const norm = (s) => (s || "").normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
  const selected = React.useMemo(() => (alumnos || []).find(a => a.id === value) || null, [alumnos, value]);
  const filtered = React.useMemo(() => {
    const needle = norm(q);
    return (alumnos || []).filter(a => !excludeIds.includes(a.id) && (!needle || norm(getNombreCompleto(a)).includes(needle)));
  }, [alumnos, excludeIds, q]);

  const showList = open && (!selected || q.length > 0);

  return (
    <div className="relative" ref={boxRef}>
      <div className="flex gap-2">
        <input
          ref={inputRef}
          type="text"
          className="w-full border rounded-lg px-3 py-2"
          placeholder={placeholder}
          value={selected && q.length === 0 ? getNombreCompleto(selected) : q}
          onFocus={() => setOpen(true)}
          onChange={(e) => { setQ(e.target.value); onChange(""); }}
        />
        {value && (
          <button
            type="button"
            className="px-2 text-slate-500 hover:text-slate-700"
            onClick={() => { onChange(""); setQ(""); setOpen(true); }}
            title="Limpiar selección"
          >
            ×
          </button>
        )}
      </div>
      {showList && (
        <div className="absolute z-30 mt-1 w-full bg-white border rounded-lg shadow max-h-64 overflow-auto">
          {filtered.length ? filtered.map(a => (
            <button
              type="button"
              key={a.id}
              className="w-full text-left px-3 py-2 hover:bg-slate-50"
              onClick={() => { onChange(a.id); setQ(""); setOpen(false); }}
            >
              {getNombreCompleto(a)}
            </button>
          )) : (
            <div className="px-3 py-2 text-slate-500">Sin resultados</div>
          )}
        </div>
      )}
    </div>
  );
}
    const formatCurrency = (value, { withSymbol = true } = {}) => {
  const n = Number(
    typeof value === "number"
      ? value
      : String(value ?? "")
          .replace(/\./g, "")   // quita puntos miles si vinieran
          .replace(",", ".")    // coma -> punto
          .replace(/[^0-9.-]/g, "")
  );
  const opts = { minimumFractionDigits: 0, maximumFractionDigits: 0 };
  if (withSymbol) { opts.style = "currency"; opts.currency = "ARS"; }
  return new Intl.NumberFormat("es-AR", opts).format(isFinite(n) ? n : 0);
};

// --- Normalizador robusto de horarioLaboral ---
function toArrayHorarioLaboral(hl) {
  if (!hl) return [];
  if (Array.isArray(hl)) return hl;
  if (typeof hl === 'string') {
    try { const parsed = JSON.parse(hl); return Array.isArray(parsed) ? parsed : []; } catch (e) { return []; }
  }
  if (typeof hl === 'object') {
    // Convierte objetos estilo mapa a un array de valores confiable
    try { return Object.values(hl); } catch (e) { return []; }
  }
  return [];
}


    // ------------------------------ UI Básicos ------------------------------
    function Card({ title, right, children }) {
  const bodyRef = React.useRef(null);

  React.useEffect(() => {
    const el = bodyRef.current;
    if (!el) return;

    // ¿Hay una o más tablas dentro del Card?
    const tables = el.querySelectorAll('table');
    const hasTable = tables.length > 0;

    // Aplico clases sólo si hay tablas (scroll horizontal + padding negativo en mobile)
    el.classList.toggle('overflow-x-auto', hasTable);
    el.classList.toggle('-mx-2', hasTable);   // ensancha en mobile
    el.classList.toggle('sm:mx-0', hasTable); // normal en >= sm
    if (hasTable) {
      // Suaviza scroll en iOS
      el.style.webkitOverflowScrolling = 'touch';
      tables.forEach(t => {
        // Fuerza ancho mínimo para que aparezca el scroll horizontal en pantallas chicas
        if (!t.classList.contains('min-w-[720px]')) {
          t.classList.add('min-w-[720px]');
        }
        // Asegura tipografía consistente
        if (!t.classList.contains('text-sm')) {
          t.classList.add('text-sm');
        }
      });
    }
  }, [children]);

  return (
    <section className="bg-white rounded-2xl shadow-sm border border-slate-200 p-3 sm:p-4">
      <div className="flex items-center justify-between mb-2 sm:mb-3">
        <h3 className="text-sm sm:text-base font-semibold text-slate-800">{title}</h3>
        {right}
      </div>

      {/* Contenedor del contenido del Card (se autoajusta si detecta tablas) */}
      <div ref={bodyRef} className="text-[13px] sm:text-sm">
        {children}
      </div>
    </section>
  );
}

    function Toast({ msg, onClose }) {
  useEffect(() => {
    if (!msg) return;
    const t = setTimeout(onClose, 2500);
    return () => clearTimeout(t);
  }, [msg, onClose]);

  if (!msg) return null;
  return (
    <div className="fixed top-4 right-4 bg-emerald-600 text-white px-4 py-2 rounded-xl shadow-xl z-50">
      {msg}
    </div>
  );
}

function Modal({
  isOpen,
  title,
  children,
  onCancel,
  onConfirm,
  confirmText = "Confirmar",
  cancelText = "Cancelar",
  size = "5xl",
}) {
  if (!isOpen) return null;

  const SIZE_CLASS =
    {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      "3xl": "max-w-3xl",
      "4xl": "max-w-4xl",
      "5xl": "max-w-5xl",
      "6xl": "max-w-6xl",
      "7xl": "max-w-7xl",
      wide: "max-w-[1100px]",   // ancho fijo cómodo
      full: "max-w-[95vw]",     // casi pantalla completa
    }[size] || "max-w-5xl";

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div className={`w-[95vw] md:w-auto ${SIZE_CLASS} bg-white rounded-2xl shadow-xl overflow-hidden`}>
        <div className="px-6 py-4 border-b">
          <h2 className="text-lg font-semibold text-[#34745B]">{title}</h2>
        </div>

        {/* Contenido: alto controlado, sin scroll horizontal */}
        <div className="px-6 py-4 max-h-[75vh] overflow-y-auto overflow-x-hidden">
          {children}
        </div>

        <div className="px-6 py-4 border-t flex justify-end gap-2">
          <button type="button" onClick={onCancel} className="px-4 py-2 rounded-lg border">
            {cancelText}
          </button>
          <button type="button" onClick={onConfirm} className="px-4 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white">
            {confirmText}
          </button>
        </div>
      </div>
    </div>
  );
}


function ModalPagoAbono({ open, onClose, alumno, mes, monto, onConfirm }) {
  if (!open) return null;
  return (
    <div
      className="fixed inset-0 flex items-center justify-center bg-black/50 z-50"
      role="dialog"
      aria-modal="true"
      aria-labelledby="pago-abono-title"
    >
      <div className="bg-white rounded-lg shadow-lg max-w-sm w-full p-6">
        <h2 id="pago-abono-title" className="text-lg font-semibold mb-4 text-[#34745B]">
          Pago de Abono
        </h2>
        <p className="mb-2">
          Alumno: <strong>{alumno?.apellido} {alumno?.nombre}</strong>
        </p>
        <p className="mb-2">Mes: <strong>{mes}</strong></p>
        <p className="mb-4">Monto: <strong>${monto}</strong></p>

        <div className="flex justify-end gap-3">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300 text-slate-800"
          >
            Cancelar
          </button>
          <button
            type="button"
            onClick={onConfirm}
            className="px-4 py-2 rounded-md bg-emerald-600 hover:bg-emerald-700 text-white"
          >
            Confirmar
          </button>
        </div>
      </div>
    </div>
  );
}


// Hook para abrir/cerrar el modal de abono
function useModalPagoAbono() {
  const [state, setState] = React.useState({
    open: false,
    alumno: null,
    mes: "",
    monto: 0,
    resolver: null,
  });

  const abrirModalPago = React.useCallback((alumno, mes, monto) => {
    return new Promise((resolve) => {
      setState({ open: true, alumno, mes, monto, resolver: resolve });
    });
  }, []);

  const handleClose = React.useCallback(() => {
    setState((s) => {
      s.resolver && s.resolver(false);
      return { ...s, open: false, resolver: null };
    });
  }, []);

  const handleConfirm = React.useCallback(() => {
    setState((s) => {
      s.resolver && s.resolver(true);
      return { ...s, open: false, resolver: null };
    });
  }, []);

  // Componente para montar una sola vez
  const Modal = React.useCallback(() => (
    <ModalPagoAbono
      open={state.open}
      onClose={handleClose}
      alumno={state.alumno}
      mes={state.mes}
      monto={state.monto}
      onConfirm={handleConfirm}
    />
  ), [state.open, state.alumno, state.mes, state.monto, handleClose, handleConfirm]);

  return { abrirModalPago, Modal };
}

// === Iconos Nav (namespaced para evitar "Identifier 'X' has already been declared") ===
window.NavIcons = window.NavIcons || {};

// Cada asignación solo ocurre si no existía antes
window.NavIcons.Home = window.NavIcons.Home || function NavIconHome(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <path strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round" d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-6H9v6H4a1 1 0 0 1-1-1v-10.5z"/>
    </svg>
  );
};

window.NavIcons.Users = window.NavIcons.Users || function NavIconUsers(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <path strokeWidth="1.8" strokeLinecap="round" d="M16 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
      <circle cx="9" cy="7" r="3" strokeWidth="1.8"/>
      <path strokeWidth="1.8" strokeLinecap="round" d="M22 21v-2a4 4 0 0 0-3-3.87"/>
      <path strokeWidth="1.8" d="M16 3.13a4 4 0 0 1 0 7.75"/>
    </svg>
  );
};

window.NavIcons.Calendar = window.NavIcons.Calendar || function NavIconCalendar(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <rect x="3" y="4" width="18" height="18" rx="2" ry="2" strokeWidth="1.8"/>
      <line x1="16" y1="2" x2="16" y2="6" strokeWidth="1.8"/>
      <line x1="8" y1="2" x2="8" y2="6" strokeWidth="1.8"/>
      <line x1="3" y1="10" x2="21" y2="10" strokeWidth="1.8"/>
    </svg>
  );
};

window.NavIcons.Layers = window.NavIcons.Layers || function NavIconLayers(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <polygon points="12 2 22 8 12 14 2 8 12 2" strokeWidth="1.8"/>
      <polyline points="2 12 12 18 22 12" strokeWidth="1.8"/>
    </svg>
  );
};

window.NavIcons.Cash = window.NavIcons.Cash || function NavIconCash(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <rect x="2" y="6" width="20" height="12" rx="2" strokeWidth="1.8"/>
      <circle cx="12" cy="12" r="3" strokeWidth="1.8"/>
      <path d="M6 10h0 M18 14h0" strokeWidth="2" strokeLinecap="round"/>
    </svg>
  );
};

window.NavIcons.Receipt = window.NavIcons.Receipt || function NavIconReceipt(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <path d="M7 21l5-2 5 2V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2z" strokeWidth="1.8"/>
      <path d="M9 7h6M9 11h6M9 15h6" strokeWidth="1.8" strokeLinecap="round"/>
    </svg>
  );
};

window.NavIcons.Chart = window.NavIcons.Chart || function NavIconChart(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <path d="M3 3v18h18" strokeWidth="1.8"/>
      <rect x="7" y="12" width="3" height="6" strokeWidth="1.8"/>
      <rect x="12" y="9" width="3" height="9" strokeWidth="1.8"/>
      <rect x="17" y="6" width="3" height="12" strokeWidth="1.8"/>
    </svg>
  );
};

window.NavIcons.User = window.NavIcons.User || function NavIconUser(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <circle cx="12" cy="7" r="4" strokeWidth="1.8"/>
      <path d="M4 21a8 8 0 0 1 16 0" strokeWidth="1.8"/>
    </svg>
  );
};

window.NavIcons.Logout = window.NavIcons.Logout || function NavIconLogout(p){
  return (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className={p.className}>
      <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" strokeWidth="1.8"/>
      <path d="M16 17l5-5-5-5" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round"/>
      <path d="M21 12H9" strokeWidth="1.8" strokeLinecap="round"/>
    </svg>
  );
};

    
function SideNav({
  current,
  setCurrent,
  onLogout,
  clubes = [],
  clubActivoId,
  onClubChange,
  expanded = false,
  onExpandChange,
}) {
  // ===== Fallback icons (monocromo, stroke=currentColor) =====
  const ic = {
    Home: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M3 10.5 12 3l9 7.5" />
        <path d="M5 10v10h14V10" />
        <path d="M9 20v-6h6v6" />
      </svg>
    ),
    Users: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M16 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" />
        <circle cx="9" cy="7" r="4" />
        <path d="M22 21v-2a4 4 0 0 0-3-3.87" />
        <path d="M16 3.13a4 4 0 0 1 0 7.75" />
      </svg>
    ),
    Calendar: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <rect x="3" y="4" width="18" height="18" rx="2" />
        <line x1="16" y1="2" x2="16" y2="6" />
        <line x1="8" y1="2" x2="8" y2="6" />
        <line x1="3" y1="10" x2="21" y2="10" />
      </svg>
    ),
    Layers: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <polygon points="12 2 2 7 12 12 22 7 12 2" />
        <polyline points="2 12 12 17 22 12" />
        <polyline points="2 17 12 22 22 17" />
      </svg>
    ),
    Cash: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <rect x="2" y="6" width="20" height="12" rx="2" />
        <circle cx="12" cy="12" r="3" />
        <path d="M18 8h.01M6 16h.01" />
      </svg>
    ),
    Receipt: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M4 2v20l3-2 3 2 3-2 3 2 3-2V2z" />
        <path d="M8 7h8M8 11h8M8 15h5" />
      </svg>
    ),
    Chart: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M3 3v18h18" />
        <rect x="7" y="8" width="3" height="8" />
        <rect x="12" y="5" width="3" height="11" />
        <rect x="17" y="11" width="3" height="5" />
      </svg>
    ),
    User: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M20 21a8 8 0 0 0-16 0" />
        <circle cx="12" cy="7" r="4" />
      </svg>
    ),
    Trophy: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M8 21h8" />
        <path d="M12 17v4" />
        <path d="M7 4h10v3a5 5 0 0 1-5 5 5 5 0 0 1-5-5V4z" />
        <path d="M5 7a3 3 0 0 1-3-3V3h5v4" />
        <path d="M19 7a3 3 0 0 0 3-3V3h-5v4" />
      </svg>
    ),
    Brackets: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M6 4H4v6h2c2 0 4 2 4 4v6H8v-6c0-1.1-.9-2-2-2H4" />
        <path d="M18 4h2v6h-2c-2 0-4 2-4 4v6h2v-6c0-1.1.9-2 2-2h2" />
      </svg>
    ),
    Logout: ({ className = "" }) => (
      <svg viewBox="0 0 24 24" className={className} fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden="true">
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
        <polyline points="16 17 21 12 16 7" />
        <line x1="21" y1="12" x2="9" y2="12" />
      </svg>
    ),
  };

  // Usa set de íconos si existe; sino, fallback
  const I = (name, fallback) => (window.NavIcons && window.NavIcons[name]) || fallback;

  const tabs = [
    { id: "dashboard", label: "Dashboard", icon: I("Home", ic.Home) },
    { id: "alumnos",  label: "Alumnos",   icon: I("Users", ic.Users) },
    { id: "clases",   label: "Clases",    icon: I("Calendar", ic.Calendar) },
    { id: "grupos",   label: "Grupos",    icon: I("Layers", ic.Layers) },
    { id: "torneos",  label: "Torneos",   icon: (window.NavIcons && (window.NavIcons.Tournament || window.NavIcons.Brackets)) || ic.Brackets },
    { id: "rankings", label: "Ranking",   icon: I("Trophy", ic.Trophy) },
    { id: "pagos",    label: "Pagos",     icon: I("Cash", ic.Cash) },
    { id: "gastos",   label: "Gastos",    icon: I("Receipt", ic.Receipt) },
    { id: "reportes", label: "Reportes",  icon: I("Chart", ic.Chart) },
    { id: "perfil",   label: "Perfil",    icon: I("User", ic.User) },
  ];

  const onTab = (id) => setCurrent && setCurrent(id);

  return (
    <>
      {/* Sidebar izquierda (Desktop/Tablet) */}
      <aside
        className={
          // 👇 aquí estaba el typo antes: "bg[#303030]"; debe ser "bg-[#303030]"
          "hidden md:flex fixed inset-y-0 left-0 z-40 bg-[#303030] text-white " +
          (expanded ? "w-56" : "w-16") +
          " transition-[width] duration-300 pt-5"
        }
        onMouseEnter={() => onExpandChange && onExpandChange(true)}
        onMouseLeave={() => onExpandChange && onExpandChange(false)}
      >
        <div className="flex flex-col w-full">
          {/* Header / logo */}
          <div className="h-14 flex items-center px-3 border-b border-white/10">
            <img src="logo_favicon.png" alt="Coachex-Pro" className="h-10 w-auto" />
            <span
              className={
                "ml-3 text-sm font-semibold transition-opacity whitespace-nowrap " +
                (expanded ? "opacity-100" : "opacity-0")
              }
            >
              Coachex-Pro
            </span>
          </div>

          {/* Selector de club: solo visible expandido */}
          <div className={"px-2 py-2 " + (expanded ? "block" : "hidden")}>
            {Array.isArray(clubes) && clubes.length > 1 ? (
              <select
                value={clubActivoId || ""}
                onChange={(e) => onClubChange && onClubChange(e.target.value)}
                className="w-full bg-[#3b3b3b] text-white/90 text-sm rounded-lg px-2 py-1 border border-white/10 focus:ring-2 focus:ring-white/30"
                title="Seleccionar club"
              >
                {clubes.map((c) => (
                  <option key={c.id} value={c.id}>{c.nombre}</option>
                ))}
              </select>
            ) : (
              <div className="text-xs text-white/70 px-2 py-1 rounded bg-white/5 border border-white/10">
                {clubActivoId ? (clubes.find(c=>c.id===clubActivoId)?.nombre || "—") : (clubes?.[0]?.nombre || "—")}
              </div>
            )}
          </div>

          {/* Navegación */}
          <nav className="flex-1 mt-2">
            {tabs.map((t) => {
              const active = current === t.id;
              const Icon = t.icon;
              return (
                <button
                  key={t.id}
                  onClick={() => {
          setCurrent && setCurrent(t.id);
          onExpandChange && onExpandChange(false);
        }}
        title={t.label}
        className={
          "relative w-full mx-2 my-1 flex items-center gap-3 px-3 py-2 rounded-xl transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-white/30 " +
          (active ? "bg-white/15" : "hover:bg-white/10")
        }
      >
                  {/* Indicador activo */}
                  <span
                    aria-hidden
                    className={
                      "absolute left-0 top-1/2 -translate-y-1/2 h-6 w-1 rounded-r transition-all " +
                      (active ? "bg-white" : "bg-transparent")
                    }
                  />
                  <Icon className="h-5 w-5 shrink-0" />
                  <span
                    className={
                      "text-sm transition-opacity whitespace-nowrap " +
                      (expanded ? "opacity-100" : "opacity-0")
                    }
                  >
                    {t.label}
                  </span>
                </button>
              );
            })}
          </nav>

          {/* Logout */}
          <div className="p-2 border-t border-white/10">
            <button
              onClick={onLogout}
              className="w-full flex items-center gap-3 px-3 py-2 rounded-xl hover:bg-white/10 focus-visible:ring-2 focus-visible:ring-white/30"
              title="Cerrar sesión"
            >
              {React.createElement((window.NavIcons && window.NavIcons.Logout) || ic.Logout, {
                className: "h-5 w-5",
              })}
              <span
                className={
                  "text-sm transition-opacity " +
                  (expanded ? "opacity-100" : "opacity-0")
                }
              >
                Cerrar Sesión
              </span>
            </button>
          </div>
        </div>
      </aside>

      {/* Barra inferior (Mobile) */}
      <nav
        className="md:hidden fixed bottom-0 inset-x-0 z-40 bg-[#303030] text-white flex items-stretch justify-around border-t border-white/10"
        style={{
          height: "calc(56px + env(safe-area-inset-bottom))",
          paddingBottom: "env(safe-area-inset-bottom)",
        }}
      >
        {tabs.map((t) => {
          const Icon = t.icon;
          return (
            <button
              key={t.id}
              onClick={() => onTab(t.id)}
              className={
                "flex-1 flex flex-col items-center justify-center text-[11px] transition-colors " +
                (current === t.id ? "bg-white/10" : "active:bg-white/5")
              }
            >
              <Icon className="h-5 w-5 mb-0.5" />
              <span className="leading-none">{t.label}</span>
            </button>
          );
        })}
      </nav>
    </>
  );
}




    
    function ClasesPorTamanoMes({ clases }) {
  const resumen = useMemo(() => {
    const ahora = new Date();
    const mesActual = ahora.getMonth();
    const anioActual = ahora.getFullYear();

    const clasesDelMes = clases.filter(c => {
  const fechaClase = new Date(c.fecha);
  const esRealizada = String(c.estado || '').toLowerCase() === 'realizada';
  return (
    fechaClase.getMonth() === mesActual &&
    fechaClase.getFullYear() === anioActual &&
    esRealizada
  );
});

    return TIPOS_CLASE.reduce((acc, tipo) => {
      acc[tipo] = clasesDelMes.filter(
        c => normalizarTipoClase(c.tipo) === tipo
      ).length;
      return acc;
    }, {});
  }, [clases]);

  return (
    <Card title="Clases por cantidad de alumnos">
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-2 text-center">
        {TIPOS_CLASE.map(tipo => (
          <div key={tipo} className="bg-slate-50 p-2 rounded-lg flex flex-col justify-between h-full">
            <p className="text-xs text-slate-600 h-8 flex items-center justify-center">{labelSinClase(tipo)}</p>
            <p className="text-xl font-bold">{resumen[tipo] || 0}</p>
          </div>
        ))}
      </div>
    </Card>
  );
}

function fechaDDMMYYYY(iso) {
  if (!iso) return "-";
  const [y, m, d] = String(iso).split("-");
  return `${d}/${m}/${y}`;
}

// ===== Numeración de comprobantes =====
// ===== Numeración de comprobantes (por SERIE y por AÑO) =====
const COMPROB_SERIE_DEFAULT = "CP"; // fallback

function _yearFromISO(iso) {
  if (iso && /^\d{4}-\d{2}-\d{2}$/.test(iso)) return iso.slice(0,4);
  return String(new Date().getFullYear());
}

function nextComprobanteNumber(pago, serie = COMPROB_SERIE_DEFAULT) {
  try {
    // Mantenemos un mapa por SERIE para que no se mezclen
    const mapKey     = `coachex_comprob_map_${serie}`;     // pago.id -> nro
    const seqPrefix  = `coachex_comprob_seq_${serie}_`;     // por serie & año

    const map = JSON.parse(localStorage.getItem(mapKey) || "{}");

    if (pago?.id && map[pago.id]) return map[pago.id]; // estable por pago

    const year  = _yearFromISO(pago?.fecha);
    const seqKey = seqPrefix + year;

    let seq = parseInt(localStorage.getItem(seqKey) || "0", 10);
    seq += 1;
    localStorage.setItem(seqKey, String(seq));

    const numStr = String(seq).padStart(6, "0");
    const nro = `${serie}-${year}-${numStr}`;

    if (pago?.id) {
      map[pago.id] = nro;
      localStorage.setItem(mapKey, JSON.stringify(map));
    }
    return nro;
  } catch (e) {
    const year = _yearFromISO(pago?.fecha);
    return `${serie}-${year}-${String(Date.now()).slice(-6)}`;
  }
}

// (opcional) reset manual
function resetComprobanteCounter(year = String(new Date().getFullYear()), serie = COMPROB_SERIE_DEFAULT) {
  localStorage.removeItem(`coachex_comprob_seq_${serie}_` + year);
}

// ====== PDF: Comprobante de Pago por Clase (GLOBAL, robusto) ======
// ====== PDF: Comprobante de Pago por Clase (GLOBAL, con soporte WhatsApp) ======
window.generarComprobanteClase = async function generarComprobanteClase(opts) {
  try {
    const { pago, clase, alumno, perfil, lugar, returnBlob } = opts || {};
    if (!pago || !clase || !alumno) {
      alert("Faltan datos: pago, clase o alumno.");
      console.warn("Payload comprobante:", opts);
      return;
    }

    if (!window.jspdf || !window.jspdf.jsPDF) {
      alert("jsPDF no está cargado");
      return;
    }
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    const fmtMoney = (n) =>
      Number(n || 0).toLocaleString("es-AR", { minimumFractionDigits: 0 });
    const toDDMMYYYY = (iso) => {
      if (!iso) return "-";
      const [y, m, d] = String(iso).split("-");
      return `${d}/${m}/${y}`;
    };

    // Logo (si está en la misma carpeta que index.html)
    let logoDataUrl = null;
    try {
      const resp = await fetch("./logo_favicon.png");
      if (resp.ok) {
        const blob = await resp.blob();
        logoDataUrl = await new Promise((res) => {
          const r = new FileReader();
          r.onload = () => res(r.result);
          r.readAsDataURL(blob);
        });
      }
    } catch (_) {}

    // Encabezado
    try { if (logoDataUrl) doc.addImage(logoDataUrl, "PNG", 12, 10, 22, 22); } catch (_) {}
    doc.setFontSize(16);
    doc.text("Comprobante de Pago", 40, 18);
    doc.setFontSize(10);

    const profe =
      `${perfil?.nombre || ""} ${perfil?.apellido || ""}`.trim() ||
      perfil?.nombreCompleto ||
      "-";
    const serie = (perfil?.serieComprobantes || "CP");
    const compNum = nextComprobanteNumber(pago, serie);

    doc.text(`Nº: ${compNum}`, 40, 25);
    doc.text(`Fecha emisión: ${toDDMMYYYY(pago?.fecha || clase?.fecha)}`, 40, 31);

    // Separador
    doc.setDrawColor(150);
    doc.setLineWidth(0.2);
    doc.line(12, 36, 198, 36);

    // Datos
    const alumnoNombre = `${alumno?.apellidos || ""} ${alumno?.nombres || ""}`.trim() || (alumno?.nombre || "-");
    const fechaClase   = toDDMMYYYY(clase?.fecha || "");
    const horaClase    = clase?.hora || "-";
    const tipoClase    = clase?.tipo || "-";
    const metodo       = pago?.metodo || "-";
    const monto        = fmtMoney(pago?.monto || 0);
    const concepto     = pago?.concepto || `Pago de clase (${tipoClase})`;
    const observ       = pago?.observaciones || "";
    const sede         = lugar || perfil?.lugarTrabajoNombre || perfil?.lugar || perfil?.sede || "-";

    const detalleRows = [
      ["Alumno/a",        alumnoNombre],
      ["Fecha de clase",  `${fechaClase} - ${horaClase}`],
      ["Tipo de clase",   tipoClase],
      ["Profesor/a",      profe],
      ["Sede",            sede],
      ["Método de pago",  metodo],
      ["Monto",           `$${monto}`],
      ["Concepto",        concepto],
    ];

    if (doc.autoTable) {
      doc.autoTable({
        startY: 40,
        head: [["Detalle", "Información"]],
        body: detalleRows,
        theme: "grid",
        styles: { fontSize: 10, cellPadding: 3 },
        headStyles: { fillColor: [63, 63, 65], textColor: 255, fontStyle: "bold" },
        columnStyles: { 0: { cellWidth: 55, fontStyle: "bold" }, 1: { cellWidth: 125 } },
      });
    }

    let y = doc.lastAutoTable?.finalY || 40;
    if (observ) {
      y += 8;
      doc.setFontSize(10);
      doc.text("Observaciones:", 12, y);
      const wrapped = doc.splitTextToSize(observ, 184);
      doc.text(wrapped, 12, y + 6);
      y += wrapped.length * 5 + 6;
    }

    // Firma
    y = Math.max(y + 14, 120);
    doc.setDrawColor(150);
    doc.line(140, y, 198, y);
    doc.setFontSize(9);
    doc.text("Firma / Aclaración", 146, y + 5);

    // Pie
    const pageH = doc.internal.pageSize.height;
    doc.setFontSize(8);
    doc.text("Generado por Coachex-Pro", 12, pageH - 10);

    // Nombre de archivo
    const fn = `Comprobante_${(alumnoNombre || "Alumno").replaceAll(" ", "_")}_${fechaClase.replaceAll("/", "-")}_${compNum}.pdf`;

    // ⬇️ Si me pedís blob (para WhatsApp), NO descargo. Devuelvo {blob, filename}
    if (returnBlob) {
      const blob = doc.output("blob");
      return { blob, filename: fn };
    }

    // De lo contrario, descargo normalmente
    doc.save(fn);
  } catch (e) {
    console.error("Error generando comprobante:", e);
    alert("No se pudo generar el comprobante.");
  }
};


// ====== PDF: Reportes con logo (GLOBAL) ======
window.generarReportePDF = async function generarReportePDF({
  tipo = "Diario",
  clases = [],
  pagos = [],
  gastos = [],
  perfil
}) {
  if (!window.jspdf || !window.jspdf.jsPDF) {
    alert("jsPDF no está cargado");
    return;
  }
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  const fmtMoney = (n) => Number(n || 0).toLocaleString("es-AR", { minimumFractionDigits: 0 });

  // ---------- Rango (para título) ----------
  let rangoTexto = "";
  if (clases?.length) {
    const ord = [...clases].sort((a,b) => (a.fecha||"").localeCompare(b.fecha||""));
    const desde = fechaDDMMYYYY(ord[0].fecha);
    const hasta = fechaDDMMYYYY(ord[ord.length - 1].fecha);
    if (desde && hasta) rangoTexto = `${desde}–${hasta}`;
  }

  // ---------- Logo (mismo folder que index.html) ----------
  let logoDataUrl = null;
  try {
    const resp = await fetch("./logo_favicon.png");
    if (resp.ok) {
      const blob = await resp.blob();
      logoDataUrl = await new Promise(res => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.readAsDataURL(blob);
      });
    }
  } catch (_) {}

  // ---------- Encabezado (ajustado) ----------
  const pageW  = doc.internal.pageSize.getWidth();
  const margin = 14;
  const rightX = pageW - margin;

  // Logo a la izquierda
  const logoX = margin - 4, logoY = 8, logoW = 25, logoH = 25;
  try { if (logoDataUrl) doc.addImage(logoDataUrl, "PNG", logoX, logoY, logoW, logoH); } catch(_) {}

  // “Coachex-Pro” centrado debajo del logo
  doc.setFont("helvetica", "normal");
  doc.setFontSize(9);
  doc.setTextColor(100); // gris
  doc.text("Coachex-Pro", logoX + logoW / 2, logoY + logoH + 6, { align: "center" });

  // Título a la derecha con la fuente de la app (helvetica bold)
  doc.setTextColor(0);
  doc.setFont("helvetica", "bold");
  doc.setFontSize(20);
  doc.text(`Reporte ${tipo}`, rightX, 18, { align: "right" });

  // Metadatos a la derecha
  doc.setFont("helvetica", "normal");
  doc.setFontSize(10);
  doc.text(`Generado: ${new Date().toLocaleDateString("es-AR")}`, rightX, 25, { align: "right" });

  if (perfil) {
    const nombreCompleto = `${perfil?.nombre || ""} ${perfil?.apellido || ""}`.trim();
    doc.text(`Profesor/a: ${nombreCompleto || "-"}`, rightX, 31, { align: "right" });
  }
  if (tipo !== "Diario" && rangoTexto) {
    doc.text(`Período: ${rangoTexto}`, rightX, 37, { align: "right" });
  }

  // Restablecer estilo por las dudas
  doc.setFont("helvetica", "normal");
  doc.setFontSize(10);
  doc.setTextColor(0);

  // ---------- Resumen ----------
  const totalIngresos = (pagos || []).reduce((a, p) => a + Number(p.monto || 0), 0);
  const totalGastos   = (gastos || []).reduce((a, g) => a + Number(g.monto || 0), 0);
  const balance       = totalIngresos - totalGastos;

  doc.setFontSize(12);
  doc.text("Resumen", 14, 48);
  doc.setFontSize(10);
  doc.text(`Clases registradas: ${clases.length}`, 14, 55);
  doc.text(`Ingresos: $${fmtMoney(totalIngresos)}`, 14, 61);
  doc.text(`Gastos: $${fmtMoney(totalGastos)}`,   14, 67);
  doc.text(`Balance: $${fmtMoney(balance)}`,      14, 73);

  // ---------- Por tipo (tabla compacta) ----------
  const totPorTipo = (clases || []).reduce((acc, c) => {
    const k = c?.tipo || "Otro";
    acc[k] = (acc[k] || 0) + 1;
    return acc;
  }, {});
  const tiposRows = Object.entries(totPorTipo).map(([k,v]) => [k, String(v)]);
  if (tiposRows.length && doc.autoTable) {
    doc.autoTable({
      startY: 79,
      head: [["Tipo", "Cantidad"]],
      body: tiposRows,
      styles: { fontSize: 9 },
      theme: "grid",
      headStyles: { fillColor: [63,63,65], textColor: 255, fontStyle: "bold" },
      alternateRowStyles: { fillColor: [245,247,248] }
    });
  }

  // ---------- Tabla de clases ----------
  const bodyClases = (clases || []).map(c => ([
    fechaDDMMYYYY(c.fecha || ""),
    c.hora || "-",
    (c.alumnoNombres && c.alumnoNombres.length
      ? c.alumnoNombres.join(", ")
      : (Array.isArray(c.alumnos)
          ? c.alumnos.map(a => `${a.apellido||""} ${a.nombre||""}`.trim()).join(", ")
          : "-"
        )
    ),
    c.tipo || "-",
    c.estado || "-"
  ]));

  const startYTabla = (doc.lastAutoTable && doc.lastAutoTable.finalY
    ? doc.lastAutoTable.finalY + 6
    : 86
  );

  if (bodyClases.length && doc.autoTable) {
    doc.autoTable({
      startY: startYTabla,
      head: [["Fecha","Hora","Alumno(s)","Tipo","Estado"]],
      body: bodyClases,
      // anti-overflow
      tableWidth: "auto",
      margin: { left: 12, right: 12 },
      styles: { fontSize: 9, cellPadding: 2, overflow: "linebreak" },
      columnStyles: {
        0: { cellWidth: 24 }, // Fecha
        1: { cellWidth: 16 }, // Hora
        2: { cellWidth: 82 }, // Alumno(s)
        3: { cellWidth: 38 }, // Tipo
        4: { cellWidth: 24 }, // Estado
      },
      theme: "grid",
      headStyles: { fillColor: [63,63,65], textColor: 255, fontStyle: "bold", halign: "left" },
      alternateRowStyles: { fillColor: [245,247,248] },
      didParseCell: (data) => {
        if (data.section === "body" && (data.column.index === 2 || data.column.index === 3)) {
          const maxW = data.column.index === 2 ? 82 : 38;
          data.cell.text = doc.splitTextToSize(String(data.cell.text || ""), maxW);
          data.cell.styles.valign = "top";
          data.cell.styles.minCellHeight = 6;
        }
      },
    });
  }

  // ---------- Página extra: Pagos / Gastos (si hay) ----------
  const hayPagos  = (pagos?.length || 0) > 0;
  const hayGastos = (gastos?.length || 0) > 0;

  if (hayPagos || hayGastos) {
    doc.addPage();

    // ===== Pagos (4 columnas, sin overflow) =====
    if (hayPagos) {
      const bodyPagos = pagos.map(p => [
        fechaDDMMYYYY(p.fecha || ""),
        p.concepto || "-",
        `$${fmtMoney(p.monto || 0)}`,
        p.metodo || "-"
      ]);

      // Cálculo de anchos con colchón
      const mlP = 16, mrP = 16;
      const availWP = pageW - mlP - mrP;
      const safeWP  = Math.floor(availWP * 0.88); // 12% libre

      const wFechaP   = 22;
      const wMontoP   = 26;
      const wMetodoP  = 24;
      const wConceptoP = Math.max(40, safeWP - wFechaP - wMontoP - wMetodoP);

      doc.setFontSize(12);
      doc.text("Pagos", 14, 16);

      doc.autoTable({
        startY: 20,
        head: [["Fecha","Concepto","Monto","Método"]],
        body: bodyPagos,

        tableWidth: safeWP,
        margin: { left: mlP, right: mrP },
        styles: {
          fontSize: 9,
          overflow: "linebreak",
          cellPadding: { top: 2, right: 2, bottom: 2, left: 2 },
        },
        columnStyles: {
          0: { cellWidth: wFechaP },
          1: { cellWidth: wConceptoP },
          2: { cellWidth: wMontoP, halign: "right" },
          3: { cellWidth: wMetodoP },
        },

        theme: "grid",
        headStyles: { fillColor: [63,63,65], textColor: 255, fontStyle: "bold" },
        alternateRowStyles: { fillColor: [245,247,248] },

        didParseCell: (data) => {
          if (data.section === "body" && data.column.index === 1) {
            data.cell.text = doc.splitTextToSize(String(data.cell.text ?? ""), wConceptoP);
            data.cell.styles.valign = "top";
          }
        },
      });
    }

    // ===== Gastos (3 columnas, sin overflow) =====
    if (hayGastos) {
      const bodyGastos = gastos.map(g => ([
        fechaDDMMYYYY(g.fecha || ""),
        g.concepto || "-",
        `$${fmtMoney(g.monto || 0)}`
      ]));

      const startYGastos = (doc.lastAutoTable?.finalY ? doc.lastAutoTable.finalY + 10 : 20);
      doc.setFontSize(12);
      doc.text("Gastos", 14, startYGastos - 4);

      const mlG = 16, mrG = 16;
      const availWG = pageW - mlG - mrG;
      const safeWG  = Math.floor(availWG * 0.88); // 12% libre

      const wFechaG   = 22;
      const wMontoG   = 26;
      const wConceptoG = Math.max(40, safeWG - wFechaG - wMontoG);

      doc.autoTable({
        startY: startYGastos,
        head: [["Fecha","Concepto","Monto"]],
        body: bodyGastos,

        tableWidth: safeWG,
        margin: { left: mlG, right: mrG },
        styles: {
          fontSize: 9,
          overflow: "linebreak",
          cellPadding: { top: 2, right: 2, bottom: 2, left: 2 }
        },
        columnStyles: {
          0: { cellWidth: wFechaG },
          1: { cellWidth: wConceptoG },
          2: { cellWidth: wMontoG, halign: "right" },
        },

        theme: "grid",
        headStyles: { fillColor: [63,63,65], textColor: 255, fontStyle: "bold" },
        alternateRowStyles: { fillColor: [245,247,248] },

        didParseCell: (data) => {
          if (data.section === "body" && data.column.index === 1) {
            data.cell.text = doc.splitTextToSize(String(data.cell.text || ""), wConceptoG);
            data.cell.styles.valign = "top";
          }
        },
      });
    }
  }

  // ---------- Pie + nombre de archivo ----------
  const pageH = doc.internal.pageSize.height;
  doc.setFontSize(8);
  doc.text("Generado por Coachex-Pro", 12, pageH - 10);

  const hoyISO = new Date().toISOString().slice(0, 10);
  const sufijo = (tipo === "Diario")
    ? (clases?.[0]?.fecha ? fechaDDMMYYYY(clases[0].fecha).replaceAll("/", "-") : hoyISO)
    : (rangoTexto ? rangoTexto.replaceAll("/", "-").replace("–", "_") : hoyISO);

  doc.save(`Reporte_${tipo}_${sufijo}.pdf`);
};


// Enviar PDF por WhatsApp (sin descargar en fallback, salvo que lo pidas)
async function sharePdfViaWhatsApp({ blob, filename, text, phone, autoDownloadInFallback = false }) {
  const file = new File([blob], filename, { type: "application/pdf" });
  const msg  = text || "Te envío tu comprobante de pago";

  if (navigator.canShare && navigator.canShare({ files: [file] })) {
    await navigator.share({ files: [file], title: filename, text: msg });
    return;
  }
  const q = encodeURIComponent(msg);
  const waUrl = phone ? `https://wa.me/${phone}?text=${q}` : `https://wa.me/?text=${q}`;
  window.open(waUrl, "_blank");

  if (autoDownloadInFallback) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename; a.click();
    setTimeout(() => URL.revokeObjectURL(url), 20000);
  }
}


// ===== TELÉFONO DEL ALUMNO (ROBUSTO) =====
const GET_TEL_DEBUG = false; // poné true para ver candidatos en consola

function _collectPhoneStrings(obj, depth = 0, acc = []) {
  if (!obj || depth > 2) return acc;
  if (Array.isArray(obj)) {
    obj.forEach(x => _collectPhoneStrings(x, depth + 1, acc));
    return acc;
  }
  if (typeof obj === "object") {
    for (const [k, v] of Object.entries(obj)) {
      // claves que "suenan" a teléfono/whatsapp
      const looksLikePhoneKey = /whats?app|wpp|celu|celular|movil|m[oó]vil|tel(efono)?|phone|contacto/i.test(k);
      if (looksLikePhoneKey) {
        if (typeof v === "string" || typeof v === "number") acc.push(String(v));
        else _collectPhoneStrings(v, depth + 1, acc);
      }
    }
  }
  return acc;
}

function getTelefonoAlumno(alumno) {
  if (!alumno) return null;

  // campos comunes + escaneo por claves “phone-like”
  const candidates = [
    alumno.whatsapp, alumno.WhatsApp, alumno.wasap, alumno.wpp, alumno.wapp,
    alumno.telefono, alumno.teléfono, alumno.tel, alumno.cel, alumno.celular,
    alumno.movil, alumno.móvil, alumno.phone, alumno.mobile,
    alumno.contactoPadre, alumno.contactoMadre,
    alumno?.contacto?.telefono, alumno?.contacto?.whatsapp,
    ..._collectPhoneStrings(alumno)
  ]
  .filter(Boolean)
  .map(s => String(s).trim());

  // limpiar y filtrar por longitud mínima
  const cleaned = candidates
    .map(raw => ({ raw, digits: raw.replace(/\D+/g, "") }))
    .filter(o => o.digits.length >= 6);

  if (GET_TEL_DEBUG) console.log("☎️ candidatos:", candidates, "→", cleaned);

  if (!cleaned.length) return null;

  // preferir alguno que venga de campos tipo "whatsapp", si existe
  const prefer = cleaned.find(o => /whats?app|wpp/i.test(o.raw)) ||
                 cleaned.sort((a, b) => b.digits.length - a.digits.length)[0];

  return prefer.digits; // devolvemos dígitos (sin símbolos)
}

// ===== NORMALIZADOR A wa.me (Argentina por defecto) =====
function normalizarTelefonoParaWhatsApp(rawDigits, defaultCountry = "54") {
  if (!rawDigits) return null;
  let num = String(rawDigits).replace(/\D+/g, "");

  // 00 + país
  if (num.startsWith("00")) num = num.slice(2);

  // Si ya es AR
  if (num.startsWith("54")) {
    if (!num.startsWith("549")) num = "549" + num.slice(2);
    // quitar '15' pos-área (líneas viejas): 54938115xxxxxx → 549381xxxxxx
    num = num.replace(/^549(11|[2368]\d{2}|9\d{3})15/, "549$1");
    return num;
  }

  // Nacional: quitar 0 y 15 inicial si corresponde
  if (num.startsWith("0")) num = num.slice(1);
  num = num.replace(/^15/, "");

  // Anteponer país por defecto (AR)
  return defaultCountry ? ("549" + num) : num;
}

    
    function Dashboard({ perfil, clases, pagos, gastos, alumnos, clubes, clubActivoId, goToNewClass, goToEditClass }) {
  useEffect(() => {
    console.log("DATOS RECIBIDOS POR EL DASHBOARD:", { clubId: clubActivoId, nombrePerfil: perfil?.nombre });
  }, [clubActivoId, perfil?.nombre]);

  const [currentDate, setCurrentDate] = useState(new Date());
  const [mostrarSoloHorarioLaboral, setMostrarSoloHorarioLaboral] = useState(false);

  const weekStartDate = getWeekStartDate(currentDate);
  const weekDates = Array.from({ length: 7 }, (_, i) => formatDate(addDays(weekStartDate, i)));

  // 🔹 club activo y datos de horario (debe ir ANTES de usarlo en useMemo)
  const clubActivo = clubActivoId ? (clubes || []).find(c => c.id === clubActivoId) : null;
  const nombreLugar = clubActivo ? clubActivo.nombre : "—";
  const nombreCompleto = `${perfil?.nombre || ''} ${perfil?.apellido || ''}`.trim();
  const horarioData = clubActivo ? clubActivo.horarioLaboral : perfil?.horarioLaboral;

  const alumnoMap = useMemo(
    () => new Map((alumnos || []).map(a => [a.id, getNombreCompleto(a)])),
    [alumnos]
  );
  const alumnoObjMap = useMemo(
    () => new Map((alumnos || []).map(a => [a.id, a])),
    [alumnos]
  );

  const [contactosExpandId, setContactosExpandId] = useState(null);
  const [contactosMsg, setContactosMsg] = useState("");

  const hoy = formatDate(new Date());
  const semanaInicio = formatDate(getWeekStartDate(new Date()));
  const manana = formatDate(addDays(new Date(), 1));

  const clasesHoy = useMemo(() => {
return (clases || [])
  .filter(c => c.fecha === hoy && String(c.estado || '').toLowerCase() === 'realizada')
  .map(c => ({
    ...c,
    nombresAlumnos: (c.alumnoIds || [])
      .map(id => alumnoMap.get(id))
      .filter(Boolean)
      .join(', ')
  }))
  .sort((a, b) => a.hora.localeCompare(b.hora));
}, [clases, hoy, alumnoMap]);

  const clasesManana = useMemo(() => {
    return (clases || [])
      .filter(c => c.fecha === manana)
      .map(c => ({
        ...c,
        nombresAlumnos: (c.alumnoIds || []).map(id => alumnoMap.get(id)).filter(Boolean).join(', ')
      }))
      .sort((a, b) => a.hora.localeCompare(b.hora));
  }, [clases, manana, alumnoMap]);

  // --- Horario disponible para mañana ---
  const getDayIndex = (d) => (d.getDay() === 0 ? 6 : d.getDay() - 1); // 0..6 (Lun..Dom)
  const getNombreDiaFromYMD = (yyyy_mm_dd) => {
    const d = new Date(`${yyyy_mm_dd}T00:00:00`);
    return DIAS_SEMANA_NOMBRES[getDayIndex(d)];
  };
  const generateSlots = (desde, hasta, stepMin = 60) => {
    const [h1, m1] = (desde || '08:00').split(':').map(Number);
    const [h2, m2] = (hasta || '20:00').split(':').map(Number);
    const start = h1 * 60 + m1;
    const end = h2 * 60 + m2;
    const res = [];
    for (let t = start; t + stepMin <= end; t += stepMin) {
      const hh = String(Math.floor(t / 60)).padStart(2, '0');
      const mm = String(t % 60).padStart(2, '0');
      res.push(`${hh}:${mm}`);
    }
    return res;
  };

  const bloquesManana = useMemo(() => {
    const nombreDia = getNombreDiaFromYMD(manana);
    const data = clubActivo ? (clubActivo.horarioLaboral || {}) : (perfil?.horarioLaboral || []);
    if (clubActivo && data && Array.isArray(data.bloques)) {
      return data.bloques
        .filter(b => b.dia === nombreDia && (b.activo ?? true))
        .map(b => ({ desde: b.desde, hasta: b.hasta }));
    }
    const arr = Array.isArray(data) ? data : [];
    return arr
      .filter(b => b.dia === nombreDia && (b.activo ?? true))
      .map(b => ({ desde: b.desde, hasta: b.hasta }));
  }, [clubActivo, perfil, manana]);

  const horarioDisponibleManana = useMemo(() => {
    const ocupadas = new Set((clasesManana || []).map(c => c.hora));
    const slots = [];
    bloquesManana.forEach(b => {
      generateSlots(b.desde, b.hasta, 60).forEach(h => {
        if (!ocupadas.has(h)) slots.push(h);
      });
    });
    return slots.sort((a, b) => a.localeCompare(b));
  }, [bloquesManana, clasesManana]);

  const resumenClasesHoy = useMemo(() => {
    if (!clasesHoy || clasesHoy.length === 0) return [];
    const counts = clasesHoy.reduce((acc, clase) => {
      const tipo = normalizarTipoClase(clase.tipo || 'Clase 1 persona');
      acc[tipo] = (acc[tipo] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(counts).map(([tipo, cantidad]) => {
      const nombreClase = labelSinClase(tipo);
      const textoClase = cantidad > 1 ? 'clases' : 'clase';
      return `${cantidad} ${textoClase} de ${nombreClase}`;
    });
  }, [clasesHoy]);

  const balanceSemana = useMemo(() => {
    const ingresos = (pagos || [])
      .filter(p => p.fecha >= semanaInicio && p.metodo !== 'Pendiente')
      .reduce((acc, p) => acc + parseFloat(p.monto || 0), 0);
    const egresos = (gastos || [])
      .filter(g => g.fecha >= semanaInicio)
      .reduce((acc, g) => acc + parseFloat(g.monto || 0), 0);
    return ingresos - egresos;
  }, [pagos, gastos, semanaInicio]);

  const pagosPendientes = useMemo(() => {
    let pendientes = 0;
    const alumnosMensuales = (alumnos || []).filter(a => a.plan === 'mensual' && a.estado === 'activo');
    const pagosMensualesMesActual = (pagos || [])
      .filter(p => p.concepto?.startsWith("Cuota Mensual") && new Date(p.fecha).getMonth() === new Date().getMonth());
    alumnosMensuales.forEach(alumno => {
      const cuota = parseFloat((perfil?.preciosMensuales || {})[alumno.frecuencia] || 0);
      const totalPagado = pagosMensualesMesActual
        .filter(p => p.alumnoId === alumno.id)
        .reduce((acc, p) => acc + parseFloat(p.monto || 0), 0);
      if (cuota > totalPagado) pendientes++;
    });
    return pendientes;
  }, [pagos, alumnos, perfil]);

  const horarioFormateado = (() => {
    const data = horarioData;
    const esClub = !!clubActivo;
    if (!data) return ["No especificado"];
    if (esClub && data.bloques) {
      if (data.bloques.length === 0) return ["No hay horarios definidos para este club."];
      return data.bloques.map(b => `${b.dia}: ${b.desde} - ${b.hasta}`);
    }
    if (!esClub && Array.isArray(data)) {
      const activos = data.filter(d => d.activo);
      if (activos.length === 0) return ["No hay días de trabajo definidos."];
      return activos.map(d => `${d.dia}: ${d.desde} - ${d.hasta}`);
    }
    return ["Horario no configurado."];
  })();

  // ====== PDF: Reportes con logo (global) ======


return (
  <div className="grid gap-6">
    {/* ===== Fila superior en 2 columnas ===== */}
    <div className="grid md:grid-cols-2 gap-6">
      {/* Columna izquierda: Lugar de Trabajo */}
      <div className="bg-white p-4 rounded-2xl flex flex-wrap justify-between items-start shadow-sm border border-slate-200">
        <div className="text-sm space-y-2">
          <h3 className="font-semibold text-[#34745B] text-base">Lugar de Trabajo</h3>
          <p className="text-slate-600">
            <strong>Modo actual:</strong>{" "}
            <span className="font-semibold text-slate-800">{nombreLugar}</span>
          </p>
          <p className="text-slate-600"><strong>Profesor/a:</strong> {nombreCompleto}</p>
        </div>
        <div className="text-sm space-y-1 text-right">
          <strong className="block text-[#34745B]">Horario Laboral:</strong>
          <div className="text-slate-600">
            {horarioFormateado.map((linea, index) => (
              <div key={index}>{linea}</div>
            ))}
          </div>
        </div>
      </div>

      {/* Columna derecha: Reportes PDF */}
      <section className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
        <div className="flex items-center justify-between mb-2">
          <h3 className="text-base font-semibold text-[#34745B]">Reportes PDF</h3>
        </div>
        <p className="text-sm text-slate-600 mb-3">
          Descargá reportes listos para enviar por WhatsApp o email.
        </p>

        <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
          {/* Diario */}
          <button
  type="button"
  className="px-3 py-2 rounded-lg text-sm bg-emerald-600 hover:bg-emerald-700 text-white"
  onClick={() => {
    const hoyStr = formatDate(new Date());
    const clasesDia = (clases || [])
      .filter(c => c.fecha === hoyStr && String(c.estado || '').toLowerCase() === 'realizada')
      .map(c => ({
        ...c,
        alumnoNombres: (c.alumnoIds || [])
          .map(id => alumnoMap.get(id))
          .filter(Boolean)
      }));
    const pagosDia = (pagos || []).filter(p => p.fecha === hoyStr);
    const gastosDia = (gastos || []).filter(g => g.fecha === hoyStr);
    generarReportePDF({ tipo: "Diario", clases: clasesDia, pagos: pagosDia, gastos: gastosDia, perfil });
  }}
>
  Diario
</button>

<button
  type="button"
  className="px-3 py-2 rounded-lg text-sm bg-slate-800 hover:bg-slate-900 text-white"
  onClick={() => {
    const semanaInicio = formatDate(getWeekStartDate(new Date()));
    const enRango = (f) => (f >= semanaInicio && f <= formatDate(addDays(new Date(semanaInicio), 6)));
    const clasesSem = (clases || [])
      .filter(c => enRango(c.fecha) && String(c.estado || '').toLowerCase() === 'realizada')
      .map(c => ({
        ...c,
        alumnoNombres: (c.alumnoIds || [])
          .map(id => alumnoMap.get(id))
          .filter(Boolean)
      }));
    const pagosSem = (pagos || []).filter(p => enRango(p.fecha));
    const gastosSem = (gastos || []).filter(g => enRango(g.fecha));
    generarReportePDF({ tipo: "Semanal", clases: clasesSem, pagos: pagosSem, gastos: gastosSem, perfil });
  }}
>
  Semanal
</button>

<button
  type="button"
  className="px-3 py-2 rounded-lg text-sm bg-slate-600 hover:bg-slate-700 text-white"
  onClick={() => {
    const hoy = new Date();
    const y = hoy.getFullYear();
    const m = hoy.getMonth();
    const desde = formatDate(new Date(y, m, 1));
    const hasta = formatDate(new Date(y, m + 1, 0));
    const enRango = (f) => (f >= desde && f <= hasta);
    const clasesMes = (clases || [])
      .filter(c => enRango(c.fecha) && String(c.estado || '').toLowerCase() === 'realizada')
      .map(c => ({
        ...c,
        alumnoNombres: (c.alumnoIds || [])
          .map(id => alumnoMap.get(id))
          .filter(Boolean)
      }));
    const pagosMes = (pagos || []).filter(p => enRango(p.fecha));
    const gastosMes = (gastos || []).filter(g => enRango(g.fecha));
    generarReportePDF({ tipo: "Mensual", clases: clasesMes, pagos: pagosMes, gastos: gastosMes, perfil });
  }}
>
  Mensual
</button>
        </div>

        <p className="mt-3 text-xs text-slate-500">
          El reporte incluye resumen (clases, ingresos, gastos, balance) y una tabla de clases realizadas.
        </p>
      </section>
    </div>

    {/* ===== Fila siguiente: 3 tarjetas (como ya tenías) ===== */}
    <div className="grid md:grid-cols-3 gap-4">
      <div className="bg-green-50 border border-green-200 p-4 rounded-xl">
        <p className="text-sm text-green-800">Clases de Hoy</p>
        <p className="text-2xl font-bold text-[#34745B]">{clasesHoy.length}</p>
        {resumenClasesHoy.length > 0 && (
          <div className="text-xs text-green-700 mt-2 border-t border-green-200 pt-2">
            {resumenClasesHoy.map((linea, index) => (<p key={index}>{linea}</p>))}
          </div>
        )}
      </div>

      <div className="bg-slate-50 border border-slate-200 p-4 rounded-xl">
        <p className="text-sm text-slate-600">Horario disponible para mañana</p>
        <div className="mt-1 text-xs text-slate-500">{horarioDisponibleManana.length} libres</div>

        {horarioDisponibleManana.length === 0 ? (
          <p className="text-sm text-slate-500 mt-2">
            No hay horas libres dentro del horario laboral.
          </p>
        ) : (
          <div className="mt-3">
            <div className="flex flex-wrap gap-2">
              {horarioDisponibleManana.map((h) => (
                <div
                  key={h}
                  className="inline-flex items-center gap-2 px-2 py-1 rounded-full border bg-white text-slate-700 text-sm"
                  title={`Agendar ${h}`}
                >
                  <span className="px-1">{h}</span>
                  <button
                    type="button"
                    onClick={() => goToNewClass && goToNewClass({ fecha: manana, hora: h })}
                    className="text-xs px-2 py-0.5 rounded-md bg-emerald-600 hover:bg-emerald-700 text-white"
                  >
                    Agendar
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      <div className="bg-green-50 border border-green-200 p-4 rounded-xl">
        <p className="text-sm text-green-800">Balance de la Semana</p>
        <p className={`text-2xl font-bold ${balanceSemana >= 0 ? 'text-[#34745B]' : 'text-red-900'}`}>
          {formatCurrency(balanceSemana)}
        </p>
      </div>
    </div>

      <div className="grid md:grid-cols-2 gap-4">
        <Card title={<span className="text-[#34745B]">Agenda del Día</span>}>
          {clasesHoy.length === 0 ? (
            <p className="text-sm text-slate-500">No hay clases programadas para hoy.</p>
          ) : (
            <ul className="space-y-2">
  {clasesHoy.map(c => {
    const nombres = (c.alumnoIds || [])
      .map(id => alumnoMap.get(id))
      .filter(Boolean)
      .join(', ') || 'Sin alumno';

    return (
      <li key={c.id} className="p-2 border-b flex justify-between items-center">
        <div>
          <p className="font-semibold text-slate-700 break-words">{c.hora} - {nombres}</p>
          <p className="text-xs text-slate-500">
            {c.tipo}{c.cancha ? ` en ${c.cancha}` : ''}
          </p>
        </div>
        {c.estado !== 'Programada' && (
          <span
            className={`px-2 py-0.5 rounded-full text-xs font-semibold ${
              c.estado === 'Realizada' ? 'bg-green-100 text-green-800' :
              c.estado === 'Ausente'    ? 'bg-orange-100 text-orange-800' :
              c.estado === 'Cancelada'  ? 'bg-red-100 text-red-800' : ''
            }`}
          >
            {c.estado}
          </span>
        )}
      </li>
    );
  })}
</ul>

          )}
        </Card>

<Card title={<span className="text-[#34745B]">Agenda de Mañana · Contactos</span>}>
  {clasesManana.length === 0 ? (
    <p className="text-sm text-slate-500">No hay clases programadas para mañana.</p>
  ) : (
    <ul className="space-y-2">
      {clasesManana.map(c => {
        const nombres = (c.alumnoIds || [])
          .map(id => alumnoMap.get(id))
          .filter(Boolean)
          .join(', ') || 'Sin alumno';

        return (
          <li key={c.id} className="p-2 border rounded-lg">
            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center">
              <div>
                <p className="font-semibold text-slate-700 break-words">{c.hora} - {nombres}</p>
                <p className="text-xs text-slate-500">
                  {c.tipo}{c.cancha ? ` en ${c.cancha}` : ''}
                </p>
              </div>

              <div className="flex items-center gap-2 mt-2 sm:mt-0">
                <span className="px-2 py-0.5 rounded-full text-xs bg-slate-100 text-slate-800">
                  {c.estado}
                </span>
                <button
                  type="button"
                  onClick={() => {
                    const canchaTxt = c.cancha ? ` en ${c.cancha}` : "";
                    const def = `Hola! Te recuerdo tu clase ${c.tipo}${canchaTxt} el ${c.fecha} a las ${c.hora}.`;
                    setContactosMsg(def);
                    setContactosExpandId(contactosExpandId === c.id ? null : c.id);
                  }}
                  className="text-xs px-3 py-1.5 rounded-lg border border-slate-300 hover:bg-slate-50"
                >
                  Contactos
                </button>
              </div>
            </div>

            {contactosExpandId === c.id && (
              <div className="mt-3 p-3 bg-slate-50 rounded-lg border">
                <div className="mb-3">
                  <label className="text-xs text-slate-500 block mb-1">Mensaje (editable)</label>
                  <textarea
                    value={contactosMsg}
                    onChange={(e)=>setContactosMsg(e.target.value)}
                    className="w-full border rounded-lg px-2 py-1 text-sm"
                    rows="2"
                  />
                </div>

                      <table className="w-full text-sm">
                        <thead>
                          <tr className="text-slate-500">
                            <th className="text-left px-2 py-1">Alumno</th>
                            <th className="text-left px-2 py-1">Teléfono</th>
                            <th className="text-left px-2 py-1">Acción</th>
                          </tr>
                        </thead>
                        <tbody>
                          {(c.alumnoIds || []).filter(Boolean).map(id => {
                            const a = alumnoObjMap.get(id);
                            if (!a) return null;
                            const nombre = getNombreCompleto(a);
                            const telRaw = (a.telefono || a.contactoPadre || "").toString();
                            const digits = telRaw.replace(/\D/g, "");
                            const canchaTxt = c.cancha ? ` en ${c.cancha}` : "";
                            const base = `Hola! Te recuerdo tu clase ${c.tipo}${canchaTxt} el ${c.fecha} a las ${c.hora}.`;
                            const msg = contactosExpandId === c.id && contactosMsg ? contactosMsg : base;
                            const wa = `https://api.whatsapp.com/send?phone=${digits}&text=${encodeURIComponent(msg)}`;
                            return (
                              <tr key={id} className="border-t">
                                <td className="px-2 py-1">{nombre}</td>
                                <td className="px-2 py-1">{telRaw || '-'}</td>
                                <td className="px-2 py-1">
                                  <a className="text-emerald-700 underline" href={wa} target="_blank" rel="noopener">WhatsApp</a>
                                </td>
                              </tr>
                            );
                          })}
                        </tbody>
                      </table>
                    </div>
                  )}
                </li>
        );
      })}
    </ul>
  )}
</Card>
      </div>

      <Card
        title={<span className="text-[#34745B]">Calendario Semanal</span>}
        right={
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-2 text-sm">
              <input
                type="checkbox"
                id="vista-compacta"
                checked={mostrarSoloHorarioLaboral}
                onChange={(e) => setMostrarSoloHorarioLaboral(e.target.checked)}
              />
              <label htmlFor="vista-compacta" className="text-slate-600">Mostrar solo horario laboral</label>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => setCurrentDate(prev => addDays(prev, -7))} className="px-3 py-1.5 text-sm rounded-lg border bg-white hover:bg-slate-50">‹ Ant</button>
              <button onClick={() => setCurrentDate(new Date())} className="px-3 py-1.5 text-sm rounded-lg border bg-white hover:bg-slate-50">Hoy</button>
              <button onClick={() => setCurrentDate(prev => addDays(prev, 7))} className="px-3 py-1.5 text-sm rounded-lg border bg-white hover:bg-slate-50">Sig ›</button>
            </div>
          </div>
        }
      >
        <CalendarioSemanal
          week={weekDates}
          clases={(clases || []).filter(c => weekDates.includes(c.fecha))}
          alumnos={alumnos || []}                  
          onEdit={goToEditClass}
          horarioLaboral={horarioData}
          mostrarSoloHorarioLaboral={mostrarSoloHorarioLaboral}
        />
      </Card>
    </div>
  );
}


    function AlumnoForm({ initialData, onSubmit, onCancel, onRegisterMonthlyPayment, studentBeingEdited }) {
      const [form, setForm] = useState(initialData)

      const isMensual = form.plan === 'mensual';
      const canRegisterAbono = isMensual && Boolean(studentBeingEdited?.id);
      
      useEffect(() => {
        const t = form.tipo || "";
        let size = 1;
        if (/^\d+x$/.test(t)) size = parseInt(t);
        if (/^Indiv/.test(t)) size = 1;
        if (/^Dupla|2x/.test(t)) size = 2;
        if (/^Trio|3x/.test(t)) size = 3;
        if (/^Cuart|4x/.test(t)) size = 4;
        if (/Escuelita/i.test(t)) size = 4;
        const base = (form.alumnoIds && form.alumnoIds[0]) || "";
        const ids = Array.from({length: size}, (_, i) => (i===0 ? base : (form.alumnoIds && form.alumnoIds[i]) || ""));
        if (!form.alumnoIds || form.alumnoIds.length !== size) {
          setForm(prev => ({ ...prev, alumnoIds: ids }));
        }
      }, [form.tipo]);
    const handleChange = (e) => { const { name, value } = e.target; setForm(prev => ({ ...prev, [name]: value })); };
      const addHorario = () => setForm(f => ({ ...f, horarios: [...(f.horarios || []), { dia: "Lunes", hora: "18:00" }] }));
      const delHorario = (idx) => setForm(f => ({ ...f, horarios: f.horarios.filter((_, i) => i !== idx) }));
      const setHorario = (idx, key, val) => setForm(f => ({ ...f, horarios: f.horarios.map((h, i) => i === idx ? { ...h, [key]: val } : h) }));
      function handleSubmit(e) { e.preventDefault(); if (!form.nombre.trim()) return alert("Ingresá un nombre"); onSubmit(form); }
      return (
        <form onSubmit={handleSubmit} className="grid md:grid-cols-6 gap-3">
          <div className="md:col-span-3"><label className="text-sm text-slate-600">Nombre</label><input name="nombre" value={form.nombre} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" placeholder="Ej: Sofía" required /></div>
          <div className="md:col-span-3"><label className="text-sm text-slate-600">Apellido</label><input name="apellido" value={form.apellido} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" placeholder="Ej: Pérez" /></div>
          <div className="md:col-span-3"><label className="text-sm text-slate-600">Teléfono</label><input name="telefono" value={form.telefono} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" placeholder="Ej: 549381..." /></div>
          <div className="md:col-span-3"><label className="text-sm text-slate-600">Contacto Padre/Madre (Escuelita)</label><input name="contactoPadre" value={form.contactoPadre} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" placeholder="Nombre y teléfono" /></div>
          <div><label className="text-sm text-slate-600">Deporte</label><select name="deporte" value={form.deporte} onChange={handleChange} className="w-full border rounded-lg px-3 py-2">{DEPORTES.map(d => <option key={d}>{d}</option>)}</select></div>
          <div><label className="text-sm text-slate-600">Estado</label><select name="estado" value={form.estado} onChange={handleChange} className="w-full border rounded-lg px-3 py-2">{ESTADOS_ALUMNO.map(e => <option key={e.value} value={e.value}>{e.label}</option>)}</select></div>
          {/* Plan de Pago + Frecuencia (si mensual) + Botón Registrar */}
<div className="md:col-span-6 grid grid-cols-1 md:grid-cols-[1fr_auto] items-end gap-3">
  {/* Columna izquierda: selects */}
  <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
    <div className="md:col-span-1">
      <label className="text-sm text-slate-600">Plan de Pago</label>
      <select
        name="plan"
        value={form.plan}
        onChange={handleChange}
        className="w-full border rounded-lg px-3 py-2"
      >
        {PLANES_PAGO.map(p => (
          <option key={p.value} value={p.value}>{p.label}</option>
        ))}
      </select>
    </div>

    {isMensual && (
      <div className="md:col-span-2">
        <label className="text-sm text-slate-600">Frecuencia</label>
        <select
          name="frecuencia"
          value={form.frecuencia}
          onChange={handleChange}
          className="w-full border rounded-lg px-3 py-2"
        >
          {FRECUENCIAS_MENSUALES.map(f => (
            <option key={f.value} value={f.value}>{f.label}</option>
          ))}
        </select>
      </div>
    )}
  </div>

  {/* Columna derecha: botón */}
  {isMensual && (
    <button
      type="button"
      disabled={!canRegisterAbono}
      onClick={() => onRegisterMonthlyPayment?.(studentBeingEdited)}
      title={
        canRegisterAbono
          ? 'Registrar pago de abono'
          : 'Guardá el alumno para registrar su primer pago'
      }
      className={
        "inline-flex items-center justify-center gap-2 h-10 px-4 rounded-lg text-sm font-medium transition " +
        (canRegisterAbono
          ? "bg-emerald-600 text-white hover:bg-emerald-700 shadow-sm"
          : "bg-white border border-slate-200 text-slate-400 cursor-not-allowed")
      }
    >
      💳 <span>Registrar pago</span>
    </button>
  )}
</div>

{/* Leyenda cuando el botón está deshabilitado */}
{isMensual && !canRegisterAbono && (
  <p className="md:col-span-6 text-xs text-slate-500 -mt-2">
    Guardá el alumno para registrar su primer pago.
  </p>
)}

          <div className="md:col-span-6"><label className="text-sm text-slate-600">Horarios fijos</label><div className="grid gap-2">{(form.horarios || []).map((h, idx) => (<div key={idx} className="flex gap-2 items-center flex-wrap"><select value={h.dia} onChange={(e) => setHorario(idx, 'dia', e.target.value)} className="border rounded-lg px-3 py-2">{DIAS_SEMANA_NOMBRES.map(d => <option key={d}>{d}</option>)}</select><input type="time" value={h.hora} onChange={(e) => setHorario(idx, 'hora', e.target.value)} className="border rounded-lg px-3 py-2" /><button type="button" onClick={() => delHorario(idx)} className="px-2 py-2 rounded-lg border text-red-600 hover:bg-red-50">−</button></div>))}<button type="button" onClick={addHorario} className="self-start px-3 py-1.5 rounded-lg border w-auto">+ Agregar horario</button></div></div>
          <div className="md:col-span-6"><label className="text-sm text-slate-600">Notas / Descripción</label><textarea name="notas" value={form.notas} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" rows={3} placeholder="Detalle particular del alumno" /></div>
          <div className="md:col-span-6 flex gap-2 justify-end"><button type="button" onClick={onCancel} className="px-3 py-2 rounded-lg border">Cancelar</button><button type="submit" className="px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white">Guardar</button></div>
        </form>
      );
    }
function CuentaCorrienteAlumno({ user, clubId, alumno, perfil, desdeMes, hastaMes }) {
  const { abrirModalPago, Modal: ModalAbono } = useModalPagoAbono();
  const [lineas, setLineas] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState(null);

  const refetch = React.useCallback(async () => {
    try {
      setLoading(true);
      const { lineas } = await buildCuentaCorrienteMensual({
        user, clubId, alumno, perfil, desdeMes, hastaMes
      });
      setLineas(lineas);
      setError(null);
    } catch (e) {
      console.error(e);
      setError('No se pudo cargar la cuenta corriente.');
    } finally {
      setLoading(false);
    }
  }, [user, clubId, alumno, perfil, desdeMes, hastaMes]);

  React.useEffect(() => { refetch(); }, [refetch]);

  const pagarCuota = async (mes, monto) => {
    const ok = await abrirModalPago(alumno, mes, Number(monto || 0));
    if (ok) {
      // aseguro doc y acredito cuota
      const m = await ensureMensualidadParaAlumno({
        user, clubId, alumno, perfil, fechaRef: `${mes}-01`
      });
      await acreditarCuotaMensual({ user, clubId, alumno, mensualidad: m });
      await refetch();
    }
  };

  const pagarExcedente = async (mes) => {
    const monto = prompt(`Importe a registrar como pago de Excedente del mes ${mes}:`, "0");
    const val = Number(monto || 0);
    if (!isFinite(val) || val <= 0) return;
    await acreditarExcedenteMensual({ user, clubId, alumno, mes, monto: val, metodo: "Efectivo" });
    await refetch();
  };

  if (loading) return <div className="p-3 text-sm text-slate-500">Cargando cuenta corriente…</div>;
  if (error)   return <div className="p-3 text-sm text-red-600">{error}</div>;

  const saldoFinal = lineas.length ? lineas[lineas.length - 1].saldoAcumulado : 0;

  return (
    <div className="bg-white border border-slate-200 rounded-2xl p-4">
      <div className="flex items-center justify-between mb-3">
        <h3 className="font-semibold text-[#34745B]">
          Cuenta Corriente — {getNombreCompleto(alumno)}
        </h3>
        <div className={`text-sm font-semibold ${saldoFinal >= 0 ? 'text-slate-700' : 'text-red-700'}`}>
          Saldo acumulado: {formatCurrency(saldoFinal)}
        </div>
      </div>

      <div className="overflow-x-auto">
        <table className="min-w-full text-sm">
          <thead className="text-left text-slate-600">
            <tr>
              <th className="py-2 pr-3">Mes</th>
              <th className="py-2 pr-3">Incl./Cons.</th>
              <th className="py-2 pr-3">Cuota</th>
              <th className="py-2 pr-3">Excedente</th>
              <th className="py-2 pr-3">Pagos cuota</th>
              <th className="py-2 pr-3">Pagos exced.</th>
              <th className="py-2 pr-3">Saldo Mes</th>
              <th className="py-2 pr-3">Saldo Acum.</th>
              <th className="py-2 pr-3">Acciones</th>
            </tr>
          </thead>
          <tbody className="align-top">
            {lineas.map(l => (
              <tr key={l.mes} className="border-t">
                <td className="py-2 pr-3 whitespace-nowrap">{l.mes}</td>
                <td className="py-2 pr-3">{l.incluidas}/{l.consumidas}</td>
                <td className="py-2 pr-3">{formatCurrency(l.cuota)}</td>
                <td className="py-2 pr-3">{formatCurrency(l.excedente)}</td>
                <td className="py-2 pr-3">{formatCurrency(l.pagCuota)}</td>
                <td className="py-2 pr-3">{formatCurrency(l.pagExced)}</td>
                <td className="py-2 pr-3">{formatCurrency(l.saldoMes)}</td>
                <td className="py-2 pr-3">{formatCurrency(l.saldoAcumulado)}</td>
                <td className="py-2 pr-3">
                  <div className="flex gap-2">
                    <button
                      type="button"
                      onClick={() => pagarCuota(l.mes, l.cuota)}
                      className="px-2 py-1 rounded border text-xs bg-emerald-600 text-white hover:bg-emerald-700"
                    >
                      Pagar cuota
                    </button>
                    <button
                      type="button"
                      onClick={() => pagarExcedente(l.mes)}
                      className="px-2 py-1 rounded border text-xs bg-sky-600 text-white hover:bg-sky-700"
                    >
                      Pagar exced.
                    </button>
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* Montá el modal UNA sola vez */}
      <ModalAbono
    open={true}
    alumno={registrandoAbono.alumno}
    onClose={cerrarAbono}
  />
    </div>
  );
}

    
function Alumnos({
  alumnos,
  onCreate, onUpdate, onDelete,
  onRegisterMonthlyPayment,
  clases, pagos,
  onRegistrarClase, onPagarPendiente, onEditarPago, onDeletePago,
  user,
  clubActivoId,
  perfil,
  openRegistrarClaseForAlumno = () => {}
}) {
  const [q, setQ] = useState("");
  const [showForm, setShowForm] = useState(false);
  const [editing, setEditing] = useState(null);
  const [alumnoFicha, setAlumnoFicha] = useState(null);
  const emptyForm = {
    nombre: "", apellido: "", telefono: "", contactoPadre: "",
    deporte: "Pádel", estado: "activo", plan: "porClase",
    frecuencia: "1xSemana", notas: "", horarios: []
  };

  const [currentPage, setCurrentPage] = useState(1);
  const ITEMS_PER_PAGE = 10;

  // 👉 rango meses para la cuenta corriente (últimos 6 meses)
  const hastaMesCC = mesClave(new Date());
  const desdeMesCC = (() => {
    const d = new Date();
    d.setMonth(d.getMonth() - 5); // últimos 6 meses incl. el actual
    d.setDate(1);
    return mesClave(d);
  })();

  const sortedAlumnos = useMemo(() => {
    const qLower = q.trim().toLowerCase();
    const fil = (alumnos || []).filter(a => !qLower || getNombreCompleto(a).toLowerCase().includes(qLower));
    return fil.sort((a,b)=> getNombreCompleto(a).localeCompare(getNombreCompleto(b), "es", {sensitivity:"base"}));
  }, [alumnos, q]);

  const totalPages = Math.ceil(sortedAlumnos.length / ITEMS_PER_PAGE);

  const paginatedAlumnos = useMemo(() => {
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    return sortedAlumnos.slice(startIndex, startIndex + ITEMS_PER_PAGE);
  }, [sortedAlumnos, currentPage]);

  useEffect(() => { setCurrentPage(1); }, [q]);

  function openNew() {
    setEditing(null);
    setShowForm(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }
  function openEdit(a) {
    setEditing(a);
    setShowForm(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }
  function cancel() {
    setShowForm(false);
    setEditing(null);
  }

  async function submit(formData) {
    if (editing) {
      onUpdate({ ...formData, id: editing.id });
      cancel();
    } else {
      if (formData.plan === 'mensual') {
        try {
          const nuevoAlumno = await onCreate(formData);
          cancel();
          onRegisterMonthlyPayment(nuevoAlumno);
        } catch (error) {
          console.error("Error al guardar el alumno:", error);
          alert("Hubo un error al guardar el alumno.");
        }
      } else {
        onCreate(formData);
        cancel();
      }
    }
  }

  return (
    <>
      <div className="grid gap-4">
        <Card
          title={<span className="text-[#34745B]">{editing ? "Editar alumno" : "Nuevo alumno"}</span>}
          right={!showForm && (
            <button onClick={openNew} className="bg-[#34745B] hover:bg-green-800 text-white text-sm px-3 py-1.5 rounded-xl">
              + Nuevo
            </button>
          )}
        >
          {showForm ? (
            <AlumnoForm
              initialData={editing ? { ...emptyForm, ...editing } : emptyForm}
              onSubmit={submit}
              onCancel={cancel}
              onRegisterMonthlyPayment={onRegisterMonthlyPayment}
              studentBeingEdited={editing}
            />
          ) : (
            <p className="text-sm text-slate-500">
              Hacé clic en <b>+ Nuevo</b> para crear un alumno, o en el lápiz para editar.
            </p>
          )}
        </Card>

        <Card
          title={<span className="text-[#34745B]">Listado de alumnos</span>}
          right={
            <input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              placeholder="Buscar por nombre..."
              className="border rounded-xl px-3 py-1.5 text-sm"
            />
          }
        >
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="text-left text-slate-600">
                  <th className="p-2">Nombre Completo</th>
                  <th className="p-2">Teléfono</th>
                  <th className="p-2">Plan de Pago</th>
                  <th className="p-2">Estado</th>
                  <th className="p-2 text-right">Acciones</th>
                </tr>
              </thead>
              <tbody>
                {paginatedAlumnos.length === 0 && (
                  <tr>
                    <td colSpan={5} className="text-center py-6 text-slate-400">
                      No se encontraron alumnos.
                    </td>
                  </tr>
                )}

                {paginatedAlumnos.map((a) => (
                  <tr key={a.id} className="border-t">
                    <td className="p-2 font-semibold">{getNombreCompleto(a)}</td>
                    <td className="p-2">
                      <div className="flex items-center gap-2">
                        <span>{a.telefono || "-"}</span>
                        {a.telefono && (
                          <a
                            href={waLink(a.telefono, a.nombre)}
                            target="_blank"
                            rel="noreferrer"
                            className="inline-flex items-center px-2 py-0.5 text-xs rounded-full border text-green-700 bg-green-50 hover:bg-green-100"
                          >
                            WhatsApp
                          </a>
                        )}
                      </div>
                    </td>
                    <td className="p-2">{a.plan === 'mensual' ? 'Mensual' : 'Por Clase'}</td>
                    <td className="p-2">
                      <span
                        className={`px-2 py-0.5 rounded-full text-xs ${
                          a.estado === 'espera'
                            ? 'bg-amber-100 text-amber-800'
                            : 'bg-emerald-100 text-emerald-800'
                        }`}
                      >
                        {a.estado === 'espera' ? 'Espera' : 'Activo'}
                      </span>
                    </td>
                    <td className="p-2 text-right">
                      <div className="inline-flex gap-2">
                        <button
                          type="button"
                          onClick={() => setAlumnoFicha(a)}
                          className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50"
                        >
                          👁️ Ver ficha
                        </button>
         <button
  type="button"
  onClick={() => openRegistrarClaseForAlumno(a.id)}
  className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50"
>
  🟢 Registrar clase
</button>

<button
  onClick={() => openEdit(a)}
  className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50"
>
                          ✏️ Editar
                        </button>
                        <button
                          type="button"
                          onClick={() => onDelete(a.id)}
                          className="px-2 py-1 text-xs rounded-lg border text-red-600 hover:bg-red-50"
                        >
                          🗑️ Eliminar
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {totalPages > 1 && (
            <div className="mt-4 flex justify-center items-center gap-2">
              <button
                onClick={() => setCurrentPage(p => Math.max(p - 1, 1))}
                disabled={currentPage === 1}
                className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
              >
                Anterior
              </button>
              <span className="text-sm text-slate-600">
                Página {currentPage} de {totalPages}
              </span>
              <button
                onClick={() => setCurrentPage(p => Math.min(p + 1, totalPages))}
                disabled={currentPage === totalPages}
                className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
              >
                Siguiente
              </button>
            </div>
          )}
        </Card>

        {/* 👉 CUENTA CORRIENTE visible cuando abrís la ficha de un alumno mensual */}
        {alumnoFicha && alumnoFicha.plan === 'mensual' && (
          <Card title={<span className="text-[#34745B]">Cuenta Corriente (Plan Mensual)</span>}>
            <CuentaCorrienteAlumno
              user={user}
              clubId={clubActivoId}
              alumno={alumnoFicha}
              perfil={perfil}
              desdeMes={desdeMesCC}
              hastaMes={hastaMesCC}
            />
          </Card>
        )}
      </div>

      {/* tu modal de ficha existente */}
      <AlumnoFichaModal
        alumno={alumnoFicha}
        clases={clases}
        pagos={pagos}
        alumnos={alumnos}
        onPagarPendiente={onPagarPendiente}
        onClose={() => setAlumnoFicha(null)}
        onRegistrarPago={onRegisterMonthlyPayment}
        onEditarPago={onEditarPago}
        onDeletePago={onDeletePago}
      />
    </>
  );
}
    
// ========= NUEVO PANEL RESUMEN (uso interno del modal) =========
function CuentaCorrientePanel({ alumno, clases = [], pagos = [], onRegistrarPago }) {
  // Frecuencias incluidas (solo para el resumen visual)
  const INCL = { "1xSemana": 4, "2xSemana": 8, "3xSemana": 12, "4xSemana": 16, "libre": 9999 };

  const hoy = new Date();
  const y = hoy.getFullYear();
  const m = String(hoy.getMonth() + 1).padStart(2, '0'); // 01..12
  const mesClave = `${y}-${m}`; // "YYYY-MM"

  // Clases realizadas este mes por el alumno
  const clasesMes = (clases || []).filter(c =>
    (c.fecha || '').startsWith(mesClave) &&
    (c.estado === 'Realizada') &&
    Array.isArray(c.alumnoIds) &&
    c.alumnoIds.includes(alumno.id)
  );
  const consumidas = clasesMes.length;

  // Incluidas según frecuencia
  const incluidas = INCL[alumno.frecuencia] ?? 4;
  const restantes = Math.max(0, incluidas - consumidas);

  // Pagos mensuales del mes (detecta "Cuota", "Abono" o método "Mensual")
  const pagosMes = (pagos || []).filter(p =>
    p.alumnoId === alumno.id &&
    (p.fecha || '').startsWith(mesClave) &&
    (p.metodo === 'Mensual' || /cuota|abono/i.test(p.concepto || ''))
  );
  const montoPagadoMes = pagosMes.reduce((acc, p) => acc + Number(p.monto || 0), 0);
  const cuotaPagada = montoPagadoMes > 0;

  return (
    <div className="grid gap-4">
      <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
        <div className="p-3 rounded-xl border bg-white">
          <p className="text-xs text-slate-500">Frecuencia</p>
          <p className="font-semibold">{alumno.frecuencia || '—'}</p>
        </div>
        <div className="p-3 rounded-xl border bg-white">
          <p className="text-xs text-slate-500">Incluidas este mes</p>
          <p className="font-semibold">{incluidas}</p>
        </div>
        <div className="p-3 rounded-xl border bg-white">
          <p className="text-xs text-slate-500">Consumidas</p>
          <p className="font-semibold">{consumidas}</p>
        </div>
        <div className="p-3 rounded-xl border bg-white">
          <p className="text-xs text-slate-500">Restantes</p>
          <p className="font-semibold">{restantes}</p>
        </div>
      </div>

      <div className="flex items-center justify-between p-3 rounded-xl border bg-slate-50">
        <div>
          <p className="text-sm text-slate-600">Cuota del mes ({mesClave})</p>
          <p className={`text-sm font-semibold ${cuotaPagada ? 'text-emerald-700' : 'text-red-700'}`}>
            {cuotaPagada ? `Pagada · $${montoPagadoMes}` : 'Pendiente'}
          </p>
        </div>
        <button
          type="button"
          onClick={() => onRegistrarPago && onRegistrarPago(alumno)}
          className="px-3 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white text-sm"
        >
          Registrar cuota
        </button>
      </div>

      <div>
        <p className="text-sm font-semibold text-slate-700 mb-2">Clases realizadas este mes</p>
        {clasesMes.length === 0 ? (
          <p className="text-sm text-slate-500">Sin clases realizadas aún en {mesClave}.</p>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm">
              <thead>
                <tr className="text-left text-slate-500">
                  <th className="p-2">Fecha</th>
                  <th className="p-2">Hora</th>
                  <th className="p-2">Tipo</th>
                  <th className="p-2">Estado</th>
                </tr>
              </thead>
              <tbody>
                {clasesMes.sort((a,b)=>a.hora.localeCompare(b.hora)).map(c => (
                  <tr key={c.id} className="border-t">
                    <td className="p-2">{c.fecha}</td>
                    <td className="p-2">{c.hora}</td>
                    <td className="p-2">{c.tipo}</td>
                    <td className="p-2">
                      <span className="px-2 py-0.5 rounded-full text-xs bg-emerald-100 text-emerald-800">
                        {c.estado}
                      </span>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

// ========= REEMPLAZÁ TU AlumnoFichaModal POR ESTE =========
function AlumnoFichaModal({
  alumno,
  alumnos = [],
  clases = [],
  pagos = [],
  onClose,
  onPagarPendiente,
  onRegistrarPago,   // <- para registrar cuota mensual
  onEditarPago,
  onDeletePago
}) {
  const a = alumno;
  const [tab, setTab] = React.useState('clases');
  if (!a) return null;

  const nombreCompleto = `${a.apellido || ''} ${a.nombre || ''}`.trim() || 'Alumno';

  // Utilidades de listas existentes (no tocamos flujo por clase)
  const clasesDelAlumno = (clases || []).filter(c => Array.isArray(c.alumnoIds) && c.alumnoIds.includes(a.id));
  const pagosDelAlumno  = (pagos || []).filter(p => p.alumnoId === a.id);

  return (
    <Modal
      isOpen={!!alumno}
  title={`Ficha de ${getNombreCompleto(alumno)}`}
  size="7xl"        // o "wide" si preferís el ancho fijo de 1100px
  confirmText="Cerrar"
  onConfirm={onClose}
  onCancel={onClose}
    >
      <div className="grid md:grid-cols-[280px_1fr] gap-6">
        {/* Lado izquierdo: resumen */}
        <div className="p-4 rounded-2xl bg-slate-50 border">
          <h3 className="text-lg font-bold text-slate-800 mb-3">{nombreCompleto}</h3>
          <ul className="space-y-2 text-sm">
            <li>🏸 Deporte: <strong>{a.deporte || '—'}</strong></li>
            <li>✅ Estado: <strong>{a.estado === 'activo' ? 'Activo' : 'Espera'}</strong></li>
            <li>💳 Plan de Pago: <strong>{a.plan === 'mensual' ? 'Mensual' : 'Por clase'}</strong></li>
            {a.plan === 'mensual' && <li>📆 Frecuencia: <strong>{a.frecuencia || '—'}</strong></li>}
          </ul>
        </div>

        {/* Lado derecho: pestañas */}
        <div className="min-w-0">
          <div className="flex gap-6 border-b mb-4">
            <button
              className={`pb-2 -mb-px border-b-2 ${tab === 'clases' ? 'border-emerald-600 text-emerald-700' : 'border-transparent text-slate-500'}`}
              onClick={() => setTab('clases')}
            >
              Clases ({clasesDelAlumno.length})
            </button>
            <button
              className={`pb-2 -mb-px border-b-2 ${tab === 'pagos' ? 'border-emerald-600 text-emerald-700' : 'border-transparent text-slate-500'}`}
              onClick={() => setTab('pagos')}
            >
              Pagos ({pagosDelAlumno.length})
            </button>
            {a.plan === 'mensual' && (
              <button
                className={`pb-2 -mb-px border-b-2 ${tab === 'cuenta' ? 'border-emerald-600 text-emerald-700' : 'border-transparent text-slate-500'}`}
                onClick={() => setTab('cuenta')}
              >
                Cuenta Corriente
              </button>
            )}
          </div>

          {/* CONTENIDOS */}
          {tab === 'clases' && (
            <div>
              <h4 className="text-base font-semibold text-slate-700 mb-2">Historial de Clases</h4>
              {clasesDelAlumno.length === 0 ? (
                <p className="text-sm text-slate-500">Sin clases aún.</p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="text-left text-slate-500">
                        <th className="p-2">Fecha</th>
                        <th className="p-2">Tipo</th>
                        <th className="p-2">Precio</th>
                        <th className="p-2">Estado</th>
                        <th className="p-2 text-right">Acciones</th>
                      </tr>
                    </thead>
                    <tbody>
                      {clasesDelAlumno
  .sort((a,b)=> (a.fecha+b.hora).localeCompare(b.fecha+a.hora))
  .map(c => {
    // ✔ Solo estas generan cobro en plan por-clase
    const estadoLower = String(c.estado || '').toLowerCase();
    const generaCobro = (estadoLower === 'realizada' || estadoLower === 'ausente');

    // Pagos del alumno para esta clase
    const totalPagado = (pagos || [])
      .filter(p => p.claseId === c.id && p.alumnoId === a.id)
      .reduce((acc,p)=> acc + Number(p.monto || 0), 0);

    // Precio por alumno
    const precio = Number(c.precio || 0) / Math.max(1, (c.alumnoIds || []).length);

    // Pendiente SOLO si la clase genera cobro
    const pendiente = generaCobro && (totalPagado < precio);

    // Etiqueta y estilo del chip de estado de pago
    const pagoLabel = generaCobro ? (pendiente ? 'Pendiente' : 'Pagada') : 'No aplica';
    const pagoClass =
      !generaCobro
        ? 'bg-slate-100 text-slate-700'
        : (pendiente ? 'bg-rose-100 text-rose-800' : 'bg-emerald-100 text-emerald-800');

    return (
      <tr key={c.id} className="border-t">
        <td className="p-2">{c.fecha}</td>
        <td className="p-2">{c.tipo}</td>
        <td className="p-2">${precio}</td>
        <td className="p-2">
          <span className={`px-2 py-0.5 rounded-full text-xs ${pagoClass}`}>
            {pagoLabel}
          </span>
        </td>
        <td className="p-2 text-right">
          {/* Mostrar botón solo si corresponde cobrar */}
          {pendiente && (
            <button
              type="button"
              onClick={() => onPagarPendiente && onPagarPendiente(c, a.id)}
              className="px-2 py-1 text-xs rounded-lg border bg-green-50 text-green-800 hover:bg-green-100"
            >
              Registrar Pago
            </button>
          )}
        </td>
      </tr>
    );
  })}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          )}

          {tab === 'pagos' && (
            <div>
              <h4 className="text-base font-semibold text-slate-700 mb-2">Pagos</h4>
              {pagosDelAlumno.length === 0 ? (
                <p className="text-sm text-slate-500">Sin pagos aún.</p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full text-sm">
                    <thead>
                      <tr className="text-left text-slate-500">
                        <th className="p-2">Fecha</th>
                        <th className="p-2">Concepto</th>
                        <th className="p-2">Método</th>
                        <th className="p-2">Monto</th>
                        <th className="p-2 text-right">Acciones</th>
                      </tr>
                    </thead>
                    <tbody>
                      {pagosDelAlumno
                        .sort((a,b)=> (a.fecha || '').localeCompare(b.fecha || ''))
                        .map(p => (
                          <tr key={p.id || `${p.fecha}-${p.monto}-${Math.random()}`} className="border-t">
                            <td className="p-2">{p.fecha}</td>
                            <td className="p-2">{p.concepto}</td>
                            <td className="p-2">{p.metodo}</td>
                            <td className="p-2">${Number(p.monto || 0)}</td>
                            <td className="p-2 text-right">
                              {onEditarPago && (
                                <button
                                  type="button"
                                  onClick={() => onEditarPago(p)}
                                  className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50 mr-2"
                                >
                                  Editar
                                </button>
                              )}
                              {onDeletePago && (
                                <button
                                  type="button"
                                  onClick={() => onDeletePago(p.id)}
                                  className="px-2 py-1 text-xs rounded-lg border text-red-600 hover:bg-red-50"
                                >
                                  Eliminar
                                </button>
                              )}
                            </td>
                          </tr>
                        ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          )}

          {tab === 'cuenta' && a.plan === 'mensual' && (
  <CuentaCorrientePanel
    alumno={a}          // si en tu código usás alumno/alumnoLive, dejalo igual
    clases={clases}
    pagos={pagos}
    onRegistrarPago={onRegistrarPago}
  />
)}
</div>   {/* cierra la columna derecha md:w-2/3 */}
</div>   {/* cierra la grid principal del modal */}
</Modal>
);
}

function CalendarioSemanal({
  week,
  clases,
  alumnos = [],
  onEdit,
  horarioLaboral,
  mostrarSoloHorarioLaboral
}) {
  // Colores por estado
  const getStatusColor = (status) => {
    switch (status) {
      case "Realizada": return "bg-emerald-100 border-emerald-300 text-emerald-800";
      case "Cancelada": return "bg-red-100 border-red-300 text-red-800";
      case "Ausente":   return "bg-amber-100 border-amber-300 text-amber-800";
      default:          return "bg-green-50 border-[#89C5B2] text-[#34745B]";
    }
  };

  // Mapa id -> alumno
  const alumnoMap = React.useMemo(
    () => Object.fromEntries((alumnos || []).map(a => [a.id, a])),
    [alumnos]
  );

  // Nombre corto
  function getNombreCorto(a) {
    if (!a) return "Sin alumno";
    const base = `${a.nombre || ""} ${a.apellido || ""}`.trim();
    return (base || "Sin alumno").split(" ")[0];
  }

  // Indexar clases por día/hora
  const clasesPorDiaHora = React.useMemo(() => {
    const map = {};
    (clases || []).forEach(clase => {
      const key = `${clase.fecha}_${clase.hora}`;
      if (!map[key]) map[key] = [];
      map[key].push(clase);
    });
    return map;
  }, [clases, alumnos]);

  // --- Helpers de calendario / horario ---
  const nombreDiaFromYMD = (ymd) => {
    const d = new Date(`${ymd}T00:00:00`);
    const idx = (d.getDay() + 6) % 7; // 0..6 => Lun..Dom
    return ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"][idx];
  };

  const horaToMin = (hhmm = "00:00") => {
    const [h, m] = String(hhmm).split(":").map(Number);
    return (h * 60) + (m || 0);
  };

  const incluyeHora = (bloque, hhmm) => {
    // Consideramos el slot [hh:mm, hh:mm+60)
    const t = horaToMin(hhmm);
    const desde = horaToMin(bloque?.desde || "08:00");
    const hasta = horaToMin(bloque?.hasta || "20:00");
    return t >= desde && (t + 60) <= hasta;
  };

  // Normalizamos horarioLaboral a un Map(diaNombre -> [{desde,hasta},...])
  const bloquesPorDia = React.useMemo(() => {
    const out = new Map(
      ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"].map(d => [d, []])
    );

    const raw = horarioLaboral || [];
    const lista = Array.isArray(raw) ? raw : (raw?.bloques || []);

    (lista || [])
      .filter(b => (b?.activo ?? true))
      .forEach(b => {
        const arr = out.get(b.dia) || [];
        arr.push({ desde: b.desde || "08:00", hasta: b.hasta || "20:00" });
        out.set(b.dia, arr);
      });

    return out;
  }, [horarioLaboral]);

  const esHoraLaboral = (dayYMD, hora) => {
    if (!mostrarSoloHorarioLaboral || !horarioLaboral) return true;

    const bloques = bloquesPorDia.get(nombreDiaFromYMD(dayYMD)) || [];
    if (bloques.length) return bloques.some(b => incluyeHora(b, hora));

    // Fallback si no hay bloques: rango general (si existiera)
    const inicio = horarioLaboral?.inicio || "08:00";
    const fin    = horarioLaboral?.fin    || "22:00";
    return hora >= inicio && hora < fin;
  };

  // Horas base (preferimos horarioLaboral.horas si existe)
  const horasBase = React.useMemo(() => {
    if (Array.isArray(horarioLaboral?.horas) && horarioLaboral.horas.length) return horarioLaboral.horas;
    const hs = [];
    for (let h = 8; h <= 22; h++) hs.push(String(h).padStart(2, "0") + ":00");
    return hs;
  }, [horarioLaboral]);

  // Si el toggle está activo, filtramos filas: solo horas con al menos un día laboral
  const horasParaMostrar = React.useMemo(() => {
  if (!mostrarSoloHorarioLaboral) return horasBase;
  return horasBase.filter(hora =>
    week.some(d => esHoraLaboral(d, hora))   // ← antes usaba .some(...)
  );
}, [mostrarSoloHorarioLaboral, horasBase, week, bloquesPorDia]);

  // ---------- RENDER ----------
  return (
    <div className="grid grid-cols-[80px_repeat(7,1fr)]">
      {/* Encabezado de días */}
      <div />
      {week.map(day => {
        const d = new Date(`${day}T00:00:00`);
        const dayIdx = (d.getDay() === 0 ? 6 : d.getDay() - 1); // 0..6 (Lun..Dom)
        const nombreDia = ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"][dayIdx];
        return (
          <div key={`head-${day}`} className="text-center p-2">
            <div className="font-semibold">{nombreDia}</div>
            <div className="text-xs text-slate-500">{formatDate(day, 'dd/mm/yyyy')}</div>
          </div>
        );
      })}

      {/* Filas por hora */}
      {horasParaMostrar.map(hora => (
        <React.Fragment key={hora}>
          {/* Columna fija de horas */}
          <div className="bg-white text-center text-xs p-2 flex items-center justify-center">
            <span className="text-slate-500">{hora}</span>
          </div>

          {/* 7 columnas de días */}
          {week.map(day => {
            const laboral = esHoraLaboral(day, hora);
            const key = `${day}_${hora}`;
            const arr = clasesPorDiaHora[key] || [];

            return (
              <div
                key={`${day}-${hora}`}
                className={`${
                  laboral
                    ? "bg-white hover:bg-slate-50"
                    : (mostrarSoloHorarioLaboral
                        ? "bg-slate-100 opacity-50 pointer-events-none"
                        : "bg-slate-100")
                } min-h-[70px] p-1 border-t border-l border-slate-200`}
              >
                {arr.map(clase => (
                  <div
                    key={clase.id}
                    onClick={() => onEdit && onEdit(clase)}
                    className={`cursor-pointer border rounded-md px-2 py-1 mb-1 text-xs ${getStatusColor(clase.estado)}`}
                  >
                    <div className="font-semibold">
                      {clase.tipo || "Clase"} · {
                        (clase.alumnoIds || [])
                          .filter(Boolean)
                          .map(id => getNombreCorto(alumnoMap[id]))
                          .join(", ") || "Sin alumno"
                      }
                    </div>
                    {clase.notas ? (
                      <div className="text-[11px] opacity-80 truncate">{clase.notas}</div>
                    ) : null}
                  </div>
                ))}
              </div>
            );
          })}
        </React.Fragment>
      ))}
    </div>
  );

  return (
    <div className="grid grid-cols-[80px_repeat(7,1fr)]">
      {/* encabezado de días */}
      <div />
      {week.map(day => (
        <div key={`head-${day}`} className="text-center font-semibold p-2">
          {day}
        </div>
      ))}

      {/* grilla por horas x días */}
      {horasParaMostrar.map(hora => (
        <React.Fragment key={hora}>
          {/* columna de horas */}
          <div className="bg-white text-center text-xs p-2 flex items-center justify-center">
            <span className="text-slate-500">{hora}</span>
          </div>

          {/* celdas por día */}
          {week.map(day => {
            const laboral = esHoraLaboral(day, hora);
            const key = `${day}_${hora}`;
            const arr = clasesPorDiaHora[key] || [];

            return (
              <div
                key={`${day}-${hora}`}
                className={`${laboral ? "bg-white hover:bg-slate-50" : "bg-slate-100"} min-h-[70px] p-1 border-t border-l border-slate-200`}
              >
                {arr.map(clase => (
                  <div
                    key={clase.id}
                    onClick={() => onEdit && onEdit(clase)}
                    className={`cursor-pointer border rounded-md px-2 py-1 mb-1 text-xs ${getStatusColor(clase.estado)}`}
                  >
                    <div className="font-semibold">
                      {clase.tipo || "Clase"} · {
                        (clase.alumnoIds || [])
                          .filter(Boolean)
                          .map(id => getNombreCorto(alumnoMap[id]))
                          .join(", ") || "Sin alumno"
                      }
                    </div>
                    {clase.notas ? (
                      <div className="text-[11px] opacity-80 truncate">{clase.notas}</div>
                    ) : null}
                  </div>
                ))}
              </div>
            );
          })}
        </React.Fragment>
      ))}
    </div>
  );
}


/**
 * computePrecioClase(tipoDeclarado, alumnoIds, perfil, alumnoMap)
 * - Usa regla 4+ => Escuelita para el precio unitario
 * - Cobra solo a NO mensuales
 * - Devuelve string con total (mantengo compatibilidad donde esperabas string)
 */
function computePrecioClase(tipo, alumnoIds, perfil, alumnoMap = new Map()) {
  const tipoEfectivo = resolveTipoEfectivo(tipo, alumnoIds);
  const perAlumno = getPrecioSugerido(tipoEfectivo, perfil);

  const ids = (alumnoIds || []).filter(Boolean);
  const noMensuales = ids.filter(id => {
    const a = alumnoMap.get ? alumnoMap.get(id) : null;
    return a ? a.plan !== "mensual" : true;
  }).length;

  const total = perAlumno * (noMensuales || 0);
  return String(total);
}

if (typeof window.resolveTipoEfectivo !== "function") {
  window.resolveTipoEfectivo = function (tipoOriginal, alumnoIds) {
    const n = (alumnoIds || []).filter(Boolean).length;
    if (String(tipoOriginal || "").toLowerCase() === "escuelita") return "Escuelita";
    if (n >= 4) return "Escuelita";
    return tipoOriginal || "Individual";
  };
}

// Precio por tipo (lee primero perfil.preciosClase y luego perfil.precios)
if (typeof window.getPrecioSugerido !== "function") {
  window.getPrecioSugerido = function (tipo, perfil) {
    const KEYMAP_FALLBACK = {
      Individual: "individual",
      Dupla: "dupla",
      Trio: "trio",
      Cuarteto: "cuarteto",
      Escuelita: "escuelita",
    };
    const key =
      (typeof PRECIO_KEY_POR_TIPO !== "undefined" && PRECIO_KEY_POR_TIPO?.[tipo]) ||
      KEYMAP_FALLBACK[tipo] || "individual";
    const tabla = (perfil?.preciosClase) || (perfil?.precios) || {};
    const v = tabla[key];
    return Number.isFinite(+v) ? Number(v) : 0;
  };
}

// Total por clase/grupo (cobra solo a NO mensuales; respeta 4+ => Escuelita)
// Si ya tenés computePrecioClase, no redefinimos (evita choques)
if (typeof window.computePrecioClase !== "function") {
  window.computePrecioClase = function (tipo, alumnoIds, perfil, alumnoMap = new Map()) {
    const tipoEfectivo = window.resolveTipoEfectivo(tipo, alumnoIds);
    const perAlumno = window.getPrecioSugerido(tipoEfectivo, perfil);
    const ids = (alumnoIds || []).filter(Boolean);
    const noMensuales = ids.filter(id => {
      const a = alumnoMap.get ? alumnoMap.get(id) : null;
      return a ? a.plan !== "mensual" : true;
    }).length;
    return String(perAlumno * (noMensuales || 0));
  };
}
function nextDateForDiaSemana(diaSemana) {
  const today = new Date();
  // JS: 0=Domingo..6=Sábado  →  1=Lunes..7=Domingo
  const hoy = ((today.getDay() + 6) % 7) + 1;
  let delta = diaSemana - hoy;
  if (delta < 0) delta += 7;
  const d = new Date(today);
  d.setDate(today.getDate() + delta);
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}
    
function Clases({
  clases, alumnos, pagos, perfil,
  onCreate, onUpdate, onDelete, onPay,
  user,
  claseParaEditar, setClaseParaEditar,
  nuevoAlumnoId, setNuevoAlumnoId,
  prefillClase, onPrefillConsumed,
  grupos, clubActivoId
}) {
  const [showForm, setShowForm] = useState(false);
  const [editing, setEditing] = useState(null);

   const emptyForm = {
   alumnoIds: [""],
   fecha: formatDate(new Date()),
   hora: "18:00",
   tipo: "Clase 1 persona",
   estado: "Programada",
   precio: String(getPrecioSugerido("Clase 1 persona", perfil)),
   notas: "",
   cancha: ""
 };
  const [form, setForm] = useState(emptyForm);

  const [grupoSeleccionadoId, setGrupoSeleccionadoId] = useState("");
  const handleSelectGrupo = (e) => {
    const id = e.target.value;
    setGrupoSeleccionadoId(id);
    const grupo = grupos.find(g => g.id === id);
    if (grupo) {
      setForm(prev => {
        const nuevosAlumnos = grupo.alumnoIds || [];
        const nuevoTipoClase = normalizarTipoClase(`Clase ${nuevosAlumnos.length} personas`);
        return {
          ...prev,
          alumnoIds: nuevosAlumnos,
          tipo: nuevoTipoClase,
          precio: computePrecioClase(nuevoTipoClase, nuevosAlumnos, perfil, alumnoMap)
        };
      });
      setFormStep(3);
    } else {
      setForm(prev => ({ ...prev, alumnoIds: [""] }));
      setFormStep(1);
    }
  };


  const { abrirModalPago, Modal: ModalAbono } = useModalPagoAbono();

  useEffect(() => {
    // ... tu código existente
  }, [prefillClase]);

  useEffect(() => {
    if (prefillClase && prefillClase.fecha && prefillClase.hora) {
      setShowForm(true);
      setForm(prev => ({ ...prev, fecha: prefillClase.fecha, hora: prefillClase.hora }));
      onPrefillConsumed && onPrefillConsumed();
    }
  }, [prefillClase]);

  const [formStep, setFormStep] = useState(1);
  const [alumnoSearchQuery, setAlumnoSearchQuery] = useState("");
  const [isAlumnosListOpen, setIsAlumnosListOpen] = useState(false);
  const [filtroAlumno, setFiltroAlumno] = useState("");
  const [filtroEstado, setFiltroEstado] = useState("");
  const [filtroFechaDesde, setFiltroFechaDesde] = useState("");
  const [filtroFechaHasta, setFiltroFechaHasta] = useState("");


  useEffect(() => {
    if (claseParaEditar) {
      openEdit(claseParaEditar);
      setClaseParaEditar(null);
    }
  }, [claseParaEditar]);

  useEffect(() => {
    if (nuevoAlumnoId) {
      setShowForm(true);
      const alumnoSeleccionado = alumnoMap.get(nuevoAlumnoId);
      if (!alumnoSeleccionado) {
        setNuevoAlumnoId(null);
        return;
      }
      setForm({
        ...emptyForm,
        alumnoIds: [nuevoAlumnoId],
      });
      if (alumnoSeleccionado.horarios && alumnoSeleccionado.horarios.length > 0) {
        setFormStep(2);
      } else {
        setFormStep(3);
      }
      setNuevoAlumnoId(null);
    }
  }, [nuevoAlumnoId, alumnoMap, emptyForm, setNuevoAlumnoId]);

  const alumnosActivos = useMemo(
    () => (alumnos || []).filter(a => a.estado === 'activo'),
    [alumnos]
  );
  const alumnoMap = useMemo(
    () => new Map((alumnos || []).map(a => [a.id, a])),
    [alumnos]
  );

  const alumnosFiltrados = useMemo(() => {
    if (!alumnoSearchQuery) return alumnosActivos;
    return alumnosActivos.filter(alumno =>
      getNombreCompleto(alumno).toLowerCase().includes(alumnoSearchQuery.toLowerCase())
    );
  }, [alumnoSearchQuery, alumnosActivos]);

  const pagosPorClase = useMemo(() => {
    const map = new Map();
    (pagos || []).forEach(p => {
      if (!map.has(p.claseId)) map.set(p.claseId, []);
      map.get(p.claseId).push(p);
    });
    return map;
  }, [pagos]);

  const clasesConDatos = useMemo(() => (clases || []).map(c => ({
    ...c,
    tipo: normalizarTipoClase(c.tipo),
    nombresAlumnos: (c.alumnoIds || []).map(id => getNombreCompleto(alumnoMap.get(id))).filter(Boolean).join(', '),
    pagos: pagosPorClase.get(c.id) || []
  })), [clases, alumnoMap, pagosPorClase]);

  const clasesFiltradas = useMemo(() => {
    return (clasesConDatos || []).filter(c => {
      const pasaFiltroAlumno = !filtroAlumno || (c.alumnoIds || []).includes(filtroAlumno);
      const pasaFiltroEstado = !filtroEstado || c.estado === filtroEstado;
      const pasaFiltroFechaDesde = !filtroFechaDesde || c.fecha >= filtroFechaDesde;
      const pasaFiltroFechaHasta = !filtroFechaHasta || c.fecha <= filtroFechaHasta;
      return pasaFiltroAlumno && pasaFiltroEstado && pasaFiltroFechaDesde && pasaFiltroFechaHasta;
    });
  }, [clasesConDatos, filtroAlumno, filtroEstado, filtroFechaDesde, filtroFechaHasta]);

  const canchasDisponibles = useMemo(
    () => (perfil.canchas || '').split('\n').filter(c => c.trim() !== ''),
    [perfil.canchas]
  );

  function handleFormChange(e) {
    const { name, value, type, checked } = e.target;
    const val = type === 'checkbox' ? checked : value;
    setForm(prev => {
      const newState = { ...prev, [name]: val };
      if (name === "tipo") {
        const canon = normalizarTipoClase(val);
        newState.tipo = canon;
        newState.precio = computePrecioClase(canon, prev.alumnoIds, perfil, alumnoMap);
        const numAlumnos = TIPOS_CLASE_MAP[canon] || 1;
        newState.alumnoIds = Array.from({ length: numAlumnos }, (_, i) => prev.alumnoIds[i] || "");
      }
      return newState;
    });
  }

  function handleAlumnoChange(index, newId) {
    setForm(prev => {
      const newAlumnoIds = [...(prev.alumnoIds || [])];
      newAlumnoIds[index] = newId;
      const canon = normalizarTipoClase(prev.tipo);
      const nuevoPrecio = computePrecioClase(canon, newAlumnoIds, perfil, alumnoMap);
   return { ...prev, alumnoIds: newAlumnoIds, precio: nuevoPrecio };
    });
    if (index === 0 && newId) {
      const alumnoSeleccionado = alumnoMap.get(newId);
      if (alumnoSeleccionado && alumnoSeleccionado.horarios && alumnoSeleccionado.horarios.length > 0) {
        setFormStep(2);
      } else {
        setFormStep(3);
      }
    }
  }

  function handleSelectAlumno(alumno) {
    setAlumnoSearchQuery(getNombreCompleto(alumno));
    setIsAlumnosListOpen(false);
    handleAlumnoChange(0, alumno.id);
  }

  const getNextDateForDay = (dayName) => {
    const today = new Date();
    const todayDayIndex = today.getDay(); // 0=domingo, 1=lunes, etc.
    const targetDayIndex = DIAS_SEMANA_NOMBRES.indexOf(dayName); // 0=lunes, 1=martes, etc.
    let correctedTargetIndex = targetDayIndex + 1;
    if (correctedTargetIndex === 7) correctedTargetIndex = 0;
    let dayDifference = correctedTargetIndex - todayDayIndex;
    if (dayDifference <= 0) dayDifference += 7;
    const resultDate = new Date(today.getTime());
    resultDate.setDate(today.getDate() + dayDifference);
    return resultDate;
  };

  function handleScheduleSelect(horario) {
    const proximaFecha = getNextDateForDay(horario.dia);
    setForm(prev => ({ ...prev, fecha: formatDate(proximaFecha), hora: horario.hora }));
    setFormStep(3);
  }

  function openNew() {
    setEditing(null);
    setForm(emptyForm);
    setAlumnoSearchQuery("");
    setFormStep(1);
    setShowForm(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  function openEdit(c) {
    setEditing(c);
    setForm({ ...emptyForm, ...c, tipo: normalizarTipoClase(c.tipo) });
    setFormStep(3);
    setShowForm(true);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  function cancel() {
    setShowForm(false);
    setEditing(null);
    setForm(emptyForm);
    setFormStep(1);
  }

  // ⚙️ clubId razonable sin tocar props
  const clubId = perfil?.clubActivoId || perfil?.clubId || perfil?.clubActivo || null;

const normHour = (h) => String(h || '').slice(0, 5); // "18:00"
const existeClaseEnHorario = ({ fecha, hora, cancha, excluirId = null }) => {
  const f = String(fecha);
  const h = normHour(hora);
  return (clases || []).find(c => {
    if (c?.id === excluirId) return false;
    if ((c?.estado || '') === 'Cancelada') return false; // las canceladas no bloquean
    const mismoDiaHora = String(c?.fecha) === f && normHour(c?.hora) === h;
    if (!mismoDiaHora) return false;
    // si indicás cancha, exige misma cancha; si no, bloquea globalmente esa franja
    const mismaCancha = cancha ? String(c?.cancha || '') === String(cancha || '') : true;
    return mismaCancha;
  }) || null;
};

  // ✅ submit con integración de mensualidad (después de persistir)
async function submit(e) {
  e.preventDefault();

  // 1) Validaciones básicas
  const validAlumnos = (form.alumnoIds || []).filter(Boolean);
  if (validAlumnos.length === 0) {
    alert("Seleccioná al menos un alumno");
    return;
  }

  // 2) Tipo canónico + precio consistente
  const canon = normalizarTipoClase(form.tipo);
  const precioCanon = form.precio ?? getPrecioSugerido(canon, perfil);

  // 3) Payload final unificado (lo que irá a Firestore)
  const finalForm = {
    ...form,
    tipo: canon,                 // ← guardamos SIEMPRE el tipo canónico
    precio: precioCanon,
    alumnoIds: validAlumnos
  };

  // ✅ 3.1) Bloqueo de superposición (misma fecha + hora, y misma cancha si aplica)
  const conflicto = existeClaseEnHorario({
    fecha: finalForm.fecha,
    hora: finalForm.hora,
    cancha: finalForm.cancha,         // si no usás cancha, igual bloquea por fecha+hora
    excluirId: editing?.id || null    // al editar, ignoramos la propia
  });

  if (conflicto) {
    const nombres = (conflicto.alumnoIds || [])
      .map(id => getNombreCompleto(alumnoMap.get(id)))
      .filter(Boolean)
      .join(', ');
    const canchaTxt = finalForm.cancha ? ` en ${finalForm.cancha}` : '';
    alert(
      `Conflicto de horario:\n` +
      `Ya existe una clase el ${finalForm.fecha} a las ${normHour(finalForm.hora)}${canchaTxt}` +
      (nombres ? ` (alumnos: ${nombres}).` : '.')
    );
    return; // 🚫 no seguimos con el guardado
  }

  // 4) Flags y contexto
  const shouldOpenPayModal = ['realizada', 'ausente'].includes(String(finalForm.estado || '').toLowerCase());
  const currentClubId = clubActivoId || clubId;

  // 5) Persistencia (update o create) y referencia de la clase resultante
  let clasePersistida = null;
  try {
    if (editing) {
      const claseActualizada = { ...finalForm, id: editing.id };
      await onUpdate(claseActualizada);
      clasePersistida = claseActualizada;
    } else {
      // Si onCreate devuelve la clase creada con id, la usamos
      const creada = await onCreate(finalForm);
      clasePersistida = (creada && creada.id) ? creada : null;
    }
  } catch (err) {
    console.error("Error al guardar la clase:", err);
  }

  // 6) Flujo de mensualidades (exigir abono y cubrir clase por abono)
  try {
    if (clasePersistida) {
      for (const alumnoId of (clasePersistida.alumnoIds || [])) {
        const alumno = (alumnos || []).find(a => a.id === alumnoId);
        if (alumno?.plan === 'mensual') {
          // Si el mes no está pago, pedimos abono
          await exigirAbonoDelMesOAvisar({
            user,
            clubId: currentClubId,
            alumno,
            perfil,
            fechaClase: clasePersistida.fecha,
            abrirModalPago, // del hook useModalPagoAbono()
          });

          // Cubrimos la clase con la mensualidad (sin excedente)
          await cubrirClaseConMensualidadSiCorresponde({
            user,
            clubId: currentClubId,
            alumno,
            claseId: clasePersistida.id,
            fecha: clasePersistida.fecha,
            precioPorAlumno: 0, // si quisieras cobrar excedente, poné el precio por alumno real
            perfil
          });
        }
      }
    }
  } catch (err) {
    console.warn("Error en mensualidad:", err);
  }

  // 7) Modal de cobro por clase (solo si la clase quedó Realizada/Ausente)
  if (shouldOpenPayModal && clasePersistida?.id) {
  onPay(clasePersistida);
}

  // 8) Cerrar/limpiar UI
  setShowForm(false);
  setEditing(null);
}


  const primerAlumnoId = form.alumnoIds ? form.alumnoIds[0] : null;
  const esMensual = alumnoMap.get(primerAlumnoId)?.plan === 'mensual';

  return (
    <div className="grid gap-4">
      <div className="flex justify-between items-center flex-wrap gap-2">
        <h2 className="text-xl font-bold text-[#34745B]">Clases</h2>
      </div>

      <Card
        title={<span className="text-[#34745B]">{editing ? "Editar clase" : "Nueva clase"}</span>}
        right={!showForm && (
          <button
            id="nueva-clase-btn"
            onClick={openNew}
            className="bg-[#34745B] hover:bg-green-800 text-white text-sm px-3 py-1.5 rounded-xl"
          >
            + Nueva
          </button>
        )}
      >
        {showForm ? (
          <form onSubmit={submit} className="grid md:grid-cols-6 gap-3">
            {(formStep === 1) && (
              <div className="md:col-span-6 relative">
                <label className="text-sm text-slate-600 font-semibold">Selecciona Alumno/a</label>
                <input
                  type="text"
                  value={alumnoSearchQuery}
                  onChange={(e) => { setAlumnoSearchQuery(e.target.value); setIsAlumnosListOpen(true); }}
                  onFocus={() => setIsAlumnosListOpen(true)}
                  onBlur={() => setTimeout(() => setIsAlumnosListOpen(false), 200)}
                  placeholder="Escribe para buscar un alumno..."
                  className="w-full mt-1 border rounded-lg px-3 py-2"
                />
                {isAlumnosListOpen && (
                  <ul className="absolute z-10 w-full bg-white border rounded-lg mt-1 max-h-60 overflow-y-auto shadow-lg">
                    {alumnosFiltrados.length > 0 ? (
                      alumnosFiltrados.map(alumno => (
                        <li
                          key={alumno.id}
                          onMouseDown={() => handleSelectAlumno(alumno)}
                          className="px-3 py-2 hover:bg-slate-100 cursor-pointer"
                        >
                          {getNombreCompleto(alumno)}
                        </li>
                      ))
                    ) : (
                      <li className="px-3 py-2 text-slate-500">No se encontraron alumnos.</li>
                    )}
                  </ul>
                )}
                <div className="mt-4">
                  <label className="block text-sm text-slate-600">O selecciona un grupo:</label>
                  <select
                    value={grupoSeleccionadoId}
                    onChange={handleSelectGrupo}
                    className="w-full mt-1 border rounded-lg px-3 py-2"
                  >
                    <option value="">-- Selecciona un grupo --</option>
                    {grupos.map(g => (
                      <option key={g.id} value={g.id}>{g.nombre}</option>
                    ))}
                  </select>
                </div>
              </div>
            )}

            {(formStep === 2 && alumnoMap.get(form.alumnoIds[0])) && (
              <div className="md:col-span-6">
                <p className="text-sm text-slate-700 mb-2">
                  <span className="font-bold">{getNombreCompleto(alumnoMap.get(form.alumnoIds[0]))}</span> tiene horarios fijos guardados.
                </p>
                <p className="text-sm font-semibold text-slate-600">
                  ¿Quieres agendar una clase en uno de sus horarios habituales?
                </p>
                <div className="flex flex-wrap gap-2 my-3">
                  {(alumnoMap.get(form.alumnoIds[0]).horarios || []).map(horario => (
                    <button
                      type="button"
                      key={`${horario.dia}-${horario.hora}`}
                      onClick={() => handleScheduleSelect(horario)}
                      className="px-3 py-2 text-sm rounded-lg border bg-sky-50 text-sky-800 hover:bg-sky-100"
                    >
                      {horario.dia} {horario.hora}
                    </button>
                  ))}
                </div>
                <div className="border-t pt-3 mt-3">
                  <button
                    type="button"
                    onClick={() => setFormStep(3)}
                    className="w-full text-left px-3 py-2 text-sm rounded-lg hover:bg-slate-100"
                  >
                    O agendar una clase personalizada en otro horario
                  </button>
                </div>
              </div>
            )}

            {(formStep === 3) && (
              <>
                <div className="md:col-span-6 grid grid-cols-1 md:grid-cols-2 gap-3">
                  {(form.alumnoIds || [""]).map((alumnoId, index) => (
                    <div key={index}>
                      <label className="text-sm text-slate-600">Alumno {index + 1}</label>
                      <AlumnoSearchSelect
                        value={alumnoId}
                        onChange={(newId) => handleAlumnoChange(index, newId)}
                        alumnos={alumnosActivos}
                        excludeIds={(form.alumnoIds || []).filter((_, i) => i !== index)}
                        placeholder={`Buscar alumno ${index + 1}...`}
                        autoFocus={index === 0}
                      />
                    </div>
                  ))}
                </div>

                <div className="md:col-span-2">
                  <label className="text-sm text-slate-600">Ubicación / Cancha</label>
                  <select name="cancha" value={form.cancha} onChange={handleFormChange} className="w-full border rounded-lg px-3 py-2">
                    <option value="">Seleccionar cancha...</option>
                    {canchasDisponibles.map(c => <option key={c} value={c}>{c}</option>)}
                  </select>
                </div>

                <div>
                  <label className="text-sm text-slate-600">Fecha</label>
                  <input type="date" name="fecha" value={form.fecha} onChange={handleFormChange} className="w-full border rounded-lg px-3 py-2" required />
                </div>

                <div>
                  <label className="text-sm text-slate-600">Hora</label>
                  <input type="time" name="hora" value={form.hora} onChange={handleFormChange} className="w-full border rounded-lg px-3 py-2" required />
                </div>

                <div>
                  <label className="text-sm text-slate-600">Tipo de Clase</label>
                  <select name="tipo" value={form.tipo} onChange={handleFormChange} className="w-full border rounded-lg px-3 py-2">
                    {TIPOS_CLASE.map(t => <option key={t}>{t}</option>)}
                  </select>
                </div>

                <div>
                  <label className="text-sm text-slate-600">Precio</label>
                  <input
                    type="number"
                    name="precio"
                    value={esMensual ? "0" : form.precio}
                    onChange={handleFormChange}
                    className={`w-full border rounded-lg px-3 py-2 ${esMensual ? 'bg-slate-100' : ''}`}
                    placeholder="0"
                    disabled={esMensual}
                  />
                </div>

                <div className="md:col-span-2">
                  <label className="text-sm text-slate-600">Estado</label>
                  <select name="estado" value={form.estado} onChange={handleFormChange} className="w-full border rounded-lg px-3 py-2">
                    {ESTADOS_CLASE.map(e => <option key={e}>{e}</option>)}
                  </select>
                </div>

                <div className="md:col-span-6">
                  <label className="text-sm text-slate-600">Notas</label>
                  <textarea
                    name="notas"
                    value={form.notas}
                    onChange={handleFormChange}
                    className="w-full border rounded-lg px-3 py-2"
                    rows={2}
                    placeholder="Comentarios sobre la clase"
                  />
                </div>
              </>
            )}

            <div className="md:col-span-6 flex gap-2 justify-end">
              <button type="button" onClick={() => { cancel(); setFormStep(1); }} className="px-3 py-2 rounded-lg border">
                Cancelar
              </button>
              {editing && (
                <button type="button" onClick={() => onDelete(editing.id)} className="px-3 py-2 rounded-lg text-red-600 border border-red-300 hover:bg-red-50">
                  🗑️ Eliminar
                </button>
              )}
              {formStep === 3 && (
                <button type="submit" className="px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white">
                  Guardar
                </button>
              )}
            </div>
          </form>
        ) : (
          <p className="text-sm text-slate-500">Hacé clic en <b>+ Nueva</b> para programar una clase.</p>
        )}
      </Card>

      <div>
        {(() => {
  // === Calendario semanal como componente dedicado ===
function SemanaCalendario({ clasesFiltradas, perfil, grupos, alumnoMap, openEdit }) {
  const [semanaVisible, setSemanaVisible] = React.useState(getWeekStartDate(new Date()));
  const cambiarSemana = (dias) => setSemanaVisible(prev => addDays(prev, dias));

  const hoyString = formatDate(new Date());
  const semanaActualStrings = Array.from({ length: 7 }, (_, i) => formatDate(addDays(semanaVisible, i)));

  const clasesDeLaSemana = React.useMemo(
    () => clasesFiltradas.filter(c => semanaActualStrings.includes(c.fecha)),
    [clasesFiltradas, semanaVisible]
  );
  const clasesDeHoy = React.useMemo(
    () => clasesFiltradas.filter(c => c.fecha === hoyString),
    [clasesFiltradas, hoyString]
  );

  const grupoMap = React.useMemo(
    () => new Map((grupos || []).map(g => [g.id, g])),
    [grupos]
  );

  const clasesAgrupadas = React.useMemo(() => {
    const acc = {};
    for (const clase of clasesDeLaSemana) {
      if (clase.fecha !== hoyString) (acc[clase.fecha] ||= []).push(clase);
    }
    return acc;
  }, [clasesDeLaSemana, hoyString]);

  const diasLaborales = React.useMemo(
    () => toArrayHorarioLaboral(perfil?.horarioLaboral).filter(d => d.activo).map(d => d.dia),
    [perfil]
  );

  // Etiqueta uniforme: "Clase para N" (acepta número o grupo)
  const labelClasePara = (input) => {
    let n = 0;
    if (typeof input === 'number') {
      n = Number(input) || 0;
    } else if (input && typeof input === 'object') {
      n = Number(input?.alumnoIds?.length || input?.cupo || input?.capacidad || 0);
    }
    return n > 0 ? `Clase para ${n}` : 'Clase grupal';
  };

  // === GRUPOS con múltiples horarios ===
  // Expande un grupo en varias "instancias virtuales" por día/hora
  const expandSchedules = React.useCallback((g) => {
    if (Array.isArray(g.horarios) && g.horarios.length) {
      return g.horarios
        .filter(h => h && h.diaSemana && h.hora)
        .map(h => ({
          ...g,
          _sched: { diaSemana: Number(h.diaSemana), hora: String(h.hora).slice(0, 5) }
        }));
    }
    if (g.diaSemana && g.hora) {
      return [{
        ...g,
        _sched: { diaSemana: Number(g.diaSemana), hora: String(g.hora).slice(0, 5) }
      }];
    }
    return [];
  }, []);

  const gruposAgrupados = React.useMemo(() => {
    const acc = {};
    for (const fechaStr of semanaActualStrings) {
      const jsDay = new Date(`${fechaStr}T00:00:00`).getDay(); // 0..6 (Dom..Sab)
      const dia1a7 = jsDay === 0 ? 7 : jsDay;

      const delDia = (grupos || []).flatMap(g => expandSchedules(g))
        .filter(gx => gx._sched.diaSemana === Number(dia1a7))
        .map(gx => ({
          _isGrupoVirtual: true,
          id: `grp_${gx.id || 'x'}_${fechaStr}`,
          _grupoRealId: gx.id,
          fecha: fechaStr,
          hora: gx._sched.hora,
          tipo: labelClasePara(gx),
          nombreGrupo: gx.nombre || 'Grupo',
          alumnoIds: gx.alumnoIds || []
        }));

      if (delDia.length) acc[fechaStr] = delDia;
    }
    return acc;
  }, [grupos, semanaActualStrings, expandSchedules]);

  const ClaseItem = ({ clase }) => {
    // nombres de alumnos desde alumnoIds + alumnoMap
    const nombresAlumnos = (clase.alumnoIds || [])
      .filter(Boolean)
      .map(id => getNombreCompleto(alumnoMap.get(id)))
      .filter(Boolean)
      .join(', ');

    const nombreGrupoDeClase = clase.origenGrupoId
      ? (grupoMap.get(clase.origenGrupoId)?.nombre || 'Grupo')
      : null;

    const totalPagado = (clase.pagos || []).reduce((acc, p) => acc + parseFloat(p.monto || 0), 0);
    const precioClase = parseFloat(clase.precio || 0);
    const estadoPago = totalPagado >= precioClase ? 'Pagada' : 'Pendiente';

    const estadoClaseBg =
  clase.estado === 'Realizada' ? 'bg-green-100 text-green-800' :
  clase.estado === 'Ausente'   ? 'bg-orange-100 text-orange-800' :
  clase.estado === 'Cancelada' ? 'bg-red-100 text-red-800' :
  'bg-slate-100 text-slate-700';

    const estadoPagoBg = estadoPago === 'Pagada'
      ? 'bg-green-100 text-green-800'
      : 'bg-red-100 text-red-800';

return (
  <div
    onClick={() => openEdit(clase)}
    className="p-3 bg-white rounded-lg shadow-sm border border-slate-200 hover:border-blue-300 hover:shadow-md cursor-pointer transition-all"
  >
    <div className="flex justify-between items-center">
      <p className="font-semibold text-slate-800">
        {clase.hora} - {nombreGrupoDeClase ? <>CLASE GRUPAL — {nombreGrupoDeClase}</> : nombresAlumnos}
      </p>

      <div className="flex gap-2">
        {/* Estado de la clase: mostrar SIEMPRE (Programada, Realizada, etc.) */}
        <span className={`px-2 py-0.5 rounded-full text-xs font-semibold ${estadoClaseBg}`}>
          {clase.estado || 'Programada'}
        </span>

        {/* Pago solo si la clase fue Realizada */}
        {clase.estado === 'Realizada' && (
          <span className={`px-2 py-0.5 rounded-full text-xs font-semibold ${estadoPagoBg}`}>
            {estadoPago}
          </span>
        )}
      </div>
    </div>

    <p className="text-xs text-slate-500 mt-1">
      {(clase.origenGrupoId ? labelClasePara((clase.alumnoIds || []).length) : (clase.tipo || 'Clase'))}
      {clase.cancha ? ` en ${clase.cancha}` : ''}
    </p>
  </div>
);
  };

  const GrupoItem = ({ grupo }) => (
    <div className="p-2 rounded-md border border-violet-300 bg-violet-50">
      <div className="flex items-center justify-between">
        <span className="text-sm font-semibold text-violet-800">{grupo.nombreGrupo}</span>
        <span className="text-xs text-violet-700">{grupo.hora}</span>
      </div>
      <div className="text-xs text-violet-700 mt-0.5">
        {labelClasePara(grupo)}
        {grupo.alumnoIds?.length ? ` • ${grupo.alumnoIds.length} alumnos` : ''}
      </div>
    </div>
  );

  const DiaGroup = ({ fecha, clasesDelDia = [], gruposDelDia = [] }) => {
    const d = new Date(`${fecha}T00:00:00`);
    const diaNombre = DIAS_SEMANA_NOMBRES[d.getDay() === 0 ? 6 : d.getDay() - 1];
    const diaNumero = d.getDate();
    return (
      <div className="bg-slate-50 border border-slate-200 rounded-2xl p-4 min-h-[120px]">
        <h3 className="font-bold text-slate-700">{diaNombre}, {diaNumero}</h3>
        <div className="space-y-2 mt-2">
          {/* GRUPOS primero */}
          {gruposDelDia.length > 0 &&
            gruposDelDia.sort((a, b) => a.hora.localeCompare(b.hora))
                        .map(g => <GrupoItem key={g.id} grupo={g} />)}

          {/* CLASES */}
          {clasesDelDia.length > 0 ? (
            clasesDelDia.sort((a, b) => a.hora.localeCompare(b.hora))
                        .map(c => <ClaseItem key={c.id} clase={c} />)
          ) : (
            <p className="text-sm text-slate-400 pt-2">No hay clases.</p>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-bold text-[#34745B] mb-2">Agenda de Hoy</h2>
        <div className="bg-green-50 border border-green-200 rounded-2xl p-4">
          {clasesDeHoy.length > 0 ? (
            <div className="space-y-2">
              {clasesDeHoy.sort((a, b) => a.hora.localeCompare(b.hora)).map(c => (
                <ClaseItem key={c.id} clase={c} />
              ))}
            </div>
          ) : (
            <p className="text-sm text-slate-500">No hay clases programadas para hoy.</p>
          )}
        </div>
      </div>

      <div>
        <div className="flex justify-between items-center mb-3">
          <button onClick={() => cambiarSemana(-7)} className="px-4 py-2 text-sm rounded-lg border bg-white shadow-sm hover:bg-slate-50">‹ Sem. Anterior</button>
          <p className="font-semibold text-slate-600">
            Semana del {formatDate(semanaVisible, 'dd/mm')} al {formatDate(addDays(semanaVisible, 6), 'dd/mm')}
          </p>
          <button onClick={() => cambiarSemana(7)} className="px-4 py-2 text-sm rounded-lg border bg-white shadow-sm hover:bg-slate-50">Sem. Siguiente ›</button>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {semanaActualStrings.map((fechaString, index) => {
            const diaNombre = DIAS_SEMANA_NOMBRES[index];
            if (diasLaborales.includes(diaNombre) && fechaString !== hoyString) {
              return (
                <DiaGroup
                  key={fechaString}
                  fecha={fechaString}
                  clasesDelDia={clasesAgrupadas[fechaString] || []}
                  gruposDelDia={gruposAgrupados[fechaString] || []}
                />
              );
            }
            return null;
          })}
        </div>
      </div>
    </div>
  );
}


  // montar el componente
  return (
    <SemanaCalendario
      clasesFiltradas={clasesFiltradas}
      perfil={perfil}
      grupos={grupos}
      alumnoMap={alumnoMap}
      openEdit={openEdit}
    />
  );
})()}
      </div>
      <ModalAbono />
    </div>
  );
}

      function Grupos({ alumnos, user, perfil, clubActivoId }) {
  // --- Estados del Componente ---
  const [grupos, setGrupos] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [tab, setTab] = React.useState('crear');

  const [form, setForm] = React.useState({
    nombre: "",
    alumnosSeleccionados: [],
    horarios: [{ diaSemana: "", hora: "" }]
  });

  // === Estado para EDITAR ===
  const [editOpen, setEditOpen] = React.useState(false);
  const [editGrupoId, setEditGrupoId] = React.useState(null);
  const [editForm, setEditForm] = React.useState({});

  // ===== Helpers locales =====
  const nextDateForDiaSemana = (n) => {
    if (!n) return "";
    const today = new Date();
    const todayIdx = today.getDay();
    const targetIdx = (n === 7) ? 0 : n;
    let diff = targetIdx - todayIdx;
    if (diff <= 0) diff += 7;
    const d = new Date(today);
    d.setDate(today.getDate() + diff);
    return formatDate(d);
  };

  const resolveTipoEfectivo = (alumnoIds = []) => {
    const n = (alumnoIds || []).filter(Boolean).length;
    return n >= 4 ? "Escuelita" : "Trio";
  };
  const getPrecioSugeridoLocal = (tipo, perfilObj) => {
    const precios = perfilObj?.preciosClase || perfilObj?.precios || {};
    const key = String(tipo).toLowerCase();
    const v = precios?.[key];
    return Number.isFinite(+v) ? Number(v) : 0;
  };

  const labelClasePara = (grupo) => {
    const n = Number(grupo?.alumnoIds?.length || grupo?.cupo || grupo?.capacidad || 0);
    return n > 0 ? `Clase para ${n}` : 'Clase grupal';
  };

  const alumnosMap = React.useMemo(() => {
    const m = new Map();
    (alumnos || []).forEach(a => m.set(a.id, a));
    return m;
  }, [alumnos]);

  const computePreview = (alumnoIds = []) => {
    const tipoEfectivo = resolveTipoEfectivo(alumnoIds);
    const precioUnit = getPrecioSugeridoLocal(tipoEfectivo, perfil);
    const noMensuales = (alumnoIds || []).filter(id => {
      const a = alumnosMap.get(id);
      return a ? a.plan !== "mensual" : true;
    }).length;
    const total = precioUnit * (noMensuales || 0);
    return { tipoEfectivo, precioUnit, noMensuales, total };
  };

  const DIAS_ABBR = ["", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb", "Dom"];

  // ===== Firestore =====
  const gruposCollection = React.useMemo(() => {
    if (!user || !clubActivoId) return null;
    return db
      .collection('users').doc(user.uid)
      .collection('clubs').doc(clubActivoId)
      .collection('grupos');
  }, [user, clubActivoId]);

  React.useEffect(() => {
    if (!gruposCollection) return;
    let mounted = true;
    const unsubscribe = gruposCollection.onSnapshot(
      (snapshot) => {
        if (!mounted) return;
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setGrupos(data);
        setLoading(false);
      },
      (err) => {
        console.error("onSnapshot grupos error:", err);
        if (mounted) setLoading(false);
      }
    );
    return () => { mounted = false; unsubscribe && unsubscribe(); };
  }, [gruposCollection]);

  const cleanHorarios = (arr) =>
    (arr || [])
      .map(h => ({ diaSemana: Number(h.diaSemana) || "", hora: (h.hora || "").slice(0, 5) }))
      .filter(h => h.diaSemana && h.hora);

  const handleCrearGrupo = async () => {
    if (!form.nombre.trim() || form.alumnosSeleccionados.length === 0) {
      alert("Por favor, ingresa un nombre para el grupo y selecciona al menos un alumno.");
      return;
    }

    const preview = computePreview(form.alumnosSeleccionados);
    const horariosLimpios = cleanHorarios(form.horarios);
    const first = horariosLimpios[0] || {};

    const nuevoGrupo = {
      nombre: form.nombre,
      alumnoIds: form.alumnosSeleccionados,
      tipoEfectivo: preview.tipoEfectivo,
      precioUnit: preview.precioUnit,
      horarios: horariosLimpios,
      diaSemana: first.diaSemana ?? null,
      hora: first.hora ?? null,
      updatedAt: Date.now(),
    };

    try {
      await gruposCollection.add(nuevoGrupo);
      setForm({ nombre: "", alumnosSeleccionados: [], horarios: [{ diaSemana: "", hora: "" }] });
      alert("¡Grupo creado con éxito!");
      setTab('grupos');
    } catch (error) {
      console.error("Error al crear el grupo: ", error);
      alert("Hubo un error al crear el grupo.");
    }
  };

  const handleEliminarGrupo = (id) => {
    if (window.confirm("¿Estás seguro de que quieres eliminar este grupo?")) {
      gruposCollection.doc(id).delete().catch(error => {
        console.error("Error al eliminar el grupo: ", error);
        alert("Hubo un error al eliminar el grupo.");
      });
    }
  };

  const abrirEditar = (grupo) => {
    setEditGrupoId(grupo.id);
    const arr = Array.isArray(grupo.horarios) && grupo.horarios.length
      ? grupo.horarios.map(h => ({ diaSemana: String(h.diaSemana || ""), hora: h.hora || "" }))
      : [{ diaSemana: grupo.diaSemana ? String(grupo.diaSemana) : "", hora: grupo.hora || "" }];
    setEditForm({
      nombre: grupo.nombre || "",
      alumnosSeleccionados: grupo.alumnoIds || [],
      horarios: arr
    });
    setEditOpen(true);
  };

  const cerrarEditar = () => {
    setEditOpen(false);
    setEditGrupoId(null);
    setEditForm({});
  };

  const guardarEdicion = async () => {
    if (!editGrupoId || !editForm.nombre.trim() || editForm.alumnosSeleccionados.length === 0) {
      alert("Completá nombre y al menos un alumno.");
      return;
    }

    const preview = computePreview(editForm.alumnosSeleccionados);
    const horariosLimpios = cleanHorarios(editForm.horarios);
    const first = horariosLimpios[0] || {};

    try {
      await gruposCollection.doc(editGrupoId).update({
        nombre: editForm.nombre,
        alumnoIds: editForm.alumnosSeleccionados,
        tipoEfectivo: preview.tipoEfectivo,
        precioUnit: preview.precioUnit,
        horarios: horariosLimpios,
        diaSemana: first.diaSemana ?? null,
        hora: first.hora ?? null,
        updatedAt: Date.now(),
      });
      cerrarEditar();
    } catch (error) {
      console.error("Error al actualizar el grupo: ", error);
      alert("Hubo un error al actualizar el grupo.");
    }
  };

  const PeriodoHorarioRow = ({ value, onChange, onRemove, disableRemove }) => (
    <div className="grid md:grid-cols-12 gap-3 items-end">
      <div className="md:col-span-6">
        <label className="text-sm text-slate-600">Día</label>
        <select
          value={value.diaSemana}
          onChange={e => onChange({ ...value, diaSemana: e.target.value })}
          className="w-full mt-1 border rounded-lg px-3 py-2"
        >
          <option value="">— Seleccionar —</option>
          <option value="1">Lunes</option>
          <option value="2">Martes</option>
          <option value="3">Miércoles</option>
          <option value="4">Jueves</option>
          <option value="5">Viernes</option>
          <option value="6">Sábado</option>
          <option value="7">Domingo</option>
        </select>
      </div>
      <div className="md:col-span-4">
        <label className="text-sm text-slate-600">Hora</label>
        <input
          type="time"
          value={value.hora}
          onChange={e => onChange({ ...value, hora: e.target.value })}
          className="w-full mt-1 border rounded-lg px-3 py-2"
        />
      </div>
      <div className="md:col-span-2">
        <button
          type="button"
          onClick={onRemove}
          disabled={disableRemove}
          className={`w-full mt-6 px-3 py-2 rounded-lg border ${disableRemove ? 'opacity-40 cursor-not-allowed' : 'hover:bg-slate-50'}`}
        >
          🗑️
        </button>
      </div>
    </div>
  );

  return (
    <div className="space-y-4">
      <div className="flex gap-2 border-b-2 border-slate-200">
        <button
          onClick={() => setTab('crear')}
          className={`px-4 py-2 text-sm font-medium ${tab === 'crear' ? 'border-b-2 border-[#34745B] text-[#34745B]' : 'text-slate-500'}`}
        >
          Crear Grupo
        </button>
        <button
          onClick={() => setTab('grupos')}
          className={`px-4 py-2 text-sm font-medium ${tab === 'grupos' ? 'border-b-2 border-[#34745B] text-[#34745B]' : 'text-slate-500'}`}
        >
          Grupos Existentes
        </button>
      </div>

      {tab === 'crear' && (
        <Card title={<span className="text-[#34745B]">Nuevo Grupo</span>}>
          <div className="grid gap-4">
            <div>
              <label className="text-sm text-slate-600">Nombre del Grupo</label>
              <input
                type="text"
                value={form.nombre}
                onChange={(e) => setForm({ ...form, nombre: e.target.value })}
                placeholder="Ej: Martes/Jueves 18hs"
                className="w-full mt-1 border rounded-lg px-3 py-2"
              />
            </div>
            <div>
              <label className="text-sm text-slate-600">Selecciona los Alumnos</label>
              <p className="text-xs text-slate-500 mb-1">Ctrl/Cmd para seleccionar varios.</p>
              <select
                multiple
                value={form.alumnosSeleccionados}
                onChange={(e) => {
                  const opciones = Array.from(e.target.selectedOptions, o => o.value);
                  setForm({ ...form, alumnosSeleccionados: opciones });
                }}
                className="w-full border rounded-lg p-2 h-48"
              >
                {alumnos.map(a => (
                  <option key={a.id} value={a.id}>
                    {getNombreCompleto(a)}{a.plan === 'mensual' ? ' (mensual)' : ''}
                  </option>
                ))}
              </select>
            </div>
            <div className="grid gap-3">
              <label className="text-sm text-slate-600">Días y horarios del grupo</label>
              {form.horarios.map((h, i) => (
                <PeriodoHorarioRow
                  key={i}
                  value={h}
                  onChange={(nv) => setForm(f => ({ ...f, horarios: f.horarios.map((x, idx) => idx === i ? nv : x) }))}
                  onRemove={() => setForm(f => ({ ...f, horarios: f.horarios.filter((_, idx) => idx !== i) }))}
                  disableRemove={form.horarios.length === 1}
                />
              ))}
              <div>
                <button
                  type="button"
                  onClick={() => setForm(f => ({ ...f, horarios: [...f.horarios, { diaSemana: "", hora: "" }] }))}
                  className="px-3 py-1.5 text-sm rounded-lg border bg-white hover:bg-slate-50"
                >
                  + Añadir día/horario
                </button>
              </div>
              <div className="text-xs text-slate-500">
                {cleanHorarios(form.horarios).map((h, i) => (
                  <span key={i} className="inline-block mr-2 mb-1 px-2 py-0.5 rounded bg-slate-100 border">
                    {DIAS_ABBR[h.diaSemana]} {h.hora} • próxima: {nextDateForDiaSemana(Number(h.diaSemana))}
                  </span>
                ))}
              </div>
            </div>
            {form.alumnosSeleccionados.length > 0 && (() => {
              const p = computePreview(form.alumnosSeleccionados);
              const etiqueta = labelClasePara({ alumnoIds: form.alumnosSeleccionados });
              return (
                <div className="rounded-xl border bg-slate-50 p-3 text-sm">
                  <div>Tipo: <b>{etiqueta}</b> {p.tipoEfectivo === 'Escuelita' && form.alumnosSeleccionados.length >= 4 && (
                    <span className="ml-2 text-[11px] px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-700">Auto 4+</span>
                  )}</div>
                  <div>Precio unitario sugerido: <b>${p.precioUnit}</b> <span className="text-xs text-slate-500">(según {p.tipoEfectivo})</span></div>
                  <div>No mensuales: <b>{p.noMensuales}</b></div>
                  <div>Total (cobrar a no mensuales): <b>${p.total}</b></div>
                </div>
              );
            })()}
            <button
              onClick={handleCrearGrupo}
              className="px-4 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white font-semibold"
            >
              Guardar Grupo
            </button>
          </div>
        </Card>
      )}

      {tab === 'grupos' && (
        <Card title={<span className="text-[#34745B]">Grupos Existentes</span>}>
          {loading && <p>Cargando grupos...</p>}
          {!loading && grupos.length === 0 && <p className="text-sm text-slate-500">Aún no has creado ningún grupo.</p>}
          <ul className="space-y-3">
            {grupos.map((grupo) => {
              const nombresAlumnos = (grupo.alumnoIds || []).map(id => {
                const alumno = alumnos.find(a => a.id === id);
                return alumno ? getNombreCompleto(alumno) : 'Alumno no encontrado';
              }).join(', ');
              const { tipoEfectivo, precioUnit, noMensuales, total } = computePreview(grupo.alumnoIds || []);
              const cant = (grupo.alumnoIds || []).length;
              const horariosShow = Array.isArray(grupo.horarios) && grupo.horarios.length
                ? grupo.horarios
                : (grupo.diaSemana && grupo.hora ? [{ diaSemana: grupo.diaSemana, hora: grupo.hora }] : []);
              return (
                <li key={grupo.id} className="p-3 border rounded-lg bg-slate-50">
                  <div className="flex justify-between items-start gap-3">
                    <div>
                      <h4 className="font-bold text-slate-800 flex items-center gap-2">
                        {grupo.nombre}
                        {tipoEfectivo === "Escuelita" && cant >= 4 && (
                          <span className="text-[11px] px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-700">Auto 4+</span>
                        )}
                      </h4>
                      <p className="text-xs text-slate-600 mt-1">
                        <strong>Integrantes ({cant}):</strong> {nombresAlumnos}
                      </p>
                      {horariosShow.length > 0 && (
                        <p className="text-xs text-slate-600 mt-1">
                          <strong>Horarios:</strong>
                          {horariosShow.map((h, i) => (
                            <span key={i} className="inline-block mr-2 mb-1 px-2 py-0.5 rounded bg-slate-100 border">
                              {DIAS_ABBR[h.diaSemana]} {String(h.hora).slice(0, 5)}
                            </span>
                          ))}
                        </p>
                      )}
                      <p className="text-xs text-slate-600 mt-1">
                        <strong>Tipo:</strong> {labelClasePara(grupo)} •
                        <strong>Precio unitario:</strong> {formatCurrency(precioUnit)} •
                        <strong>No mensuales:</strong> {noMensuales} •
                        <strong>Total:</strong> {formatCurrency(total)}
                      </p>
                    </div>
                    <div className="flex gap-2">
                      <button
                        onClick={() => abrirEditar(grupo)}
                        className="px-2 py-1 text-xs rounded-lg border text-slate-700 hover:bg-slate-100"
                      >
                        ✏️ Editar
                      </button>
                      <button
                        onClick={() => handleEliminarGrupo(grupo.id)}
                        className="px-2 py-1 text-xs rounded-lg border text-red-600 hover:bg-red-50"
                      >
                        🗑️ Eliminar
                      </button>
                    </div>
                  </div>
                </li>
              );
            })}
          </ul>
        </Card>
      )}

      {/* Modal de edición */}
      <Modal
        isOpen={!!editOpen}
        title="Editar grupo"
        onConfirm={guardarEdicion}
        onCancel={cerrarEditar}
      >
        <div className="grid gap-3 text-sm">
          <div>
            <label className="text-sm text-slate-600">Nombre</label>
            <input
              type="text"
              value={editForm.nombre}
              onChange={(e) => setEditForm({ ...editForm, nombre: e.target.value })}
              className="w-full mt-1 border rounded-lg px-3 py-2"
            />
          </div>
          <div>
            <label className="text-sm text-slate-600">Alumnos</label>
            <select
              multiple
              value={editForm.alumnosSeleccionados}
              onChange={(e) => setEditForm({ ...editForm, alumnosSeleccionados: Array.from(e.target.selectedOptions, o => o.value) })}
              className="w-full border rounded-lg p-2 h-40"
            >
              {alumnos.map(a => (
                <option key={a.id} value={a.id}>
                  {getNombreCompleto(a)}{a.plan === 'mensual' ? ' (mensual)' : ''}
                </option>
              ))}
            </select>
          </div>
          <div className="grid gap-3">
            <label className="text-sm text-slate-600">Días y horarios</label>
            {editForm.horarios?.map((h, i) => (
              <PeriodoHorarioRow
                key={i}
                value={h}
                onChange={(nv) => setEditForm(f => ({ ...f, horarios: f.horarios.map((x, idx) => idx === i ? nv : x) }))}
                onRemove={() => setEditForm(f => ({ ...f, horarios: f.horarios.filter((_, idx) => idx !== i) }))}
                disableRemove={editForm.horarios.length === 1}
              />
            ))}
            <div>
              <button
                type="button"
                onClick={() => setEditForm(f => ({ ...f, horarios: [...f.horarios, { diaSemana: "", hora: "" }] }))}
                className="px-3 py-1.5 text-sm rounded-lg border bg-white hover:bg-slate-50"
              >
                + Añadir día/horario
              </button>
            </div>
          </div>
        </div>
      </Modal>
    </div>
  );
}

function Rankings({ alumnos = [], user, clubActivoId }) {
  // === Tabs de vista principal ===
  const [view, setView] = React.useState('interno'); // 'interno' | 'torneos'
  const [tab, setTab] = React.useState('config');

  // === Listado de rankings y selección ===
  const [rankings, setRankings] = React.useState([]);
  const [selectedId, setSelectedId] = React.useState(null);
  const [loading, setLoading] = React.useState(true);

  // === Crear ranking ===
  const [newNombre, setNewNombre] = React.useState("");
  const [newNotas, setNewNotas] = React.useState("");

  // === Detalle del ranking seleccionado ===
  const [participantes, setParticipantes] = React.useState([]);
  const [puntosCfg, setPuntosCfg] = React.useState({ win: 3, draw: 1, loss: 0 });

  // Ajustes separados por vista
  const [ajustesManual, setAjustesManual] = React.useState({});
  const [ajustesTorneos, setAjustesTorneos] = React.useState({});

  // === Excluidos (editar tabla) ===
  const [excluidosInterno, setExcluidosInterno] = React.useState([]);
  const [excluidosTorneos, setExcluidosTorneos] = React.useState([]);
  const [editRowsInterno, setEditRowsInterno] = React.useState(false);
  const [editRowsTorneos, setEditRowsTorneos] = React.useState(false);

  // === Partidos (Ranking Interno) ===
  const [matches, setMatches] = React.useState([]);

  // === Torneos aplicados (Ranking Torneos) ===
  const [awardsTotals, setAwardsTotals] = React.useState({});
  const [awardsList, setAwardsList] = React.useState([]);

  // === PIN / Finalizado (Torneos) ===
  const [perfilPin, setPerfilPin] = React.useState(null);
  const [pinInput, setPinInput] = React.useState('');
  const [pinVerificado, setPinVerificado] = React.useState(false);

  // === Pestañas locales en vista Torneos ===
  const [rtTab, setRtTab] = React.useState("tabla");

  // === ESTADOS ADICIONALES PARA PARTIDOS DE DOBLES ===
  const [modalidadPartido, setModalidadPartido] = React.useState("singles");
  const [teams, setTeams] = React.useState([]);
  const [sel1, setSel1] = React.useState('');
  const [sel2, setSel2] = React.useState('');
  const [matchForm, setMatchForm] = React.useState({
    fecha: formatDate(new Date()),
    jugadorA: "",
    jugadorB: "",
    equipoA: "",
    equipoB: "",
    resultado: "A",
    score: ""
  });

  const alumnosMap = React.useMemo(
    () => new Map(alumnos.map(a => [a.id, a])),
    [alumnos]
  );

  const teamsMap = React.useMemo(() => {
    const m = new Map();
    (teams || []).forEach(t => m.set(t.id, t));
    return m;
  }, [teams]);

  // === Col de rankings ===
  const rankingsCol = React.useMemo(() => {
    if (!user || !clubActivoId) return null;
    return db
      .collection('users').doc(user.uid)
      .collection('clubs').doc(clubActivoId)
      .collection('rankings');
  }, [user, clubActivoId]);

  // === Funciones para manejar equipos/parejas ===
  const addTeam = () => {
    if (!sel1 || !sel2 || sel1 === sel2) {
      alert("Debes seleccionar dos jugadores diferentes.");
      return;
    }
    const newTeam = { id: `team_${Date.now()}`, members: [sel1, sel2] };
    setTeams([...teams, newTeam]);
    setSel1('');
    setSel2('');
  };

  const removeTeam = (teamId) => {
    setTeams(teams.filter(t => t.id !== teamId));
    setMatchForm(prev => ({
      ...prev,
      equipoA: prev.equipoA === teamId ? "" : prev.equipoA,
      equipoB: prev.equipoB === teamId ? "" : prev.equipoB,
    }));
  };

  const getTeamLabel = (teamId) => {
    const team = teamsMap.get(teamId);
    if (!team) return "Equipo no encontrado";
    const [p1, p2] = team.members;
    const name1 = getNombreCompleto(alumnosMap.get(p1));
    const name2 = getNombreCompleto(alumnosMap.get(p2));
    return `${name1} / ${name2}`;
  };

  // === Cargar PIN desde perfil ===
  React.useEffect(() => {
    if (!user) return;
    const unsubProfile = db.collection('users').doc(user.uid).collection('profile').doc('main')
      .onSnapshot(doc => {
        const d = doc.data() || {};
        let p = null;
        try {
          if (clubActivoId) {
            p = d?.clubs?.[clubActivoId]?.pin || d?.clubs?.[clubActivoId]?.pinSeguridad || null;
          }
          if (!p) p = d?.pin || d?.pinSeguridad || d?.perfil?.pin || null;
        } catch (e) {}
        if (p != null && p !== undefined) setPerfilPin(String(p).padStart(3, '0'));
      }, err => console.warn('perfil/main pin onSnapshot error', err));
    const unsubRoot = db.collection('users').doc(user.uid).onSnapshot(doc => {
      const d = doc.data() || {};
      const p = d?.pin ?? d?.perfil?.pin ?? d?.pinSeguridad ?? null;
      if (p != null && p !== undefined) setPerfilPin(String(p).padStart(3, '0'));
    }, err => console.warn('root pin onSnapshot error', err));
    return () => { try { unsubProfile(); } catch (e) {}; try { unsubRoot(); } catch (e) {}; };
  }, [user, clubActivoId]);

  // === Cargar rankings ===
  const migratedRef = React.useRef(false);
  React.useEffect(() => {
    if (!rankingsCol) return;
    let mounted = true;
    const unsub = rankingsCol.orderBy('createdAt', 'desc').onSnapshot(
      async snap => {
        if (!mounted) return;
        const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        setRankings(items);
        setLoading(false);
        if (!migratedRef.current) {
          const sinTipo = items.filter(r => typeof r.tipo === 'undefined' || r.tipo === null);
          if (sinTipo.length > 0) {
            try {
              const batch = db.batch();
              sinTipo.forEach(r => {
                batch.set(rankingsCol.doc(r.id), { tipo: 'interno', updatedAt: Date.now() }, { merge: true });
              });
              await batch.commit();
            } catch (e) { console.warn('Migración tipo->interno falló:', e); }
          }
          migratedRef.current = true;
        }
        if (!selectedId) {
          const firstOfView = items.find(r => ((r.tipo || 'interno') === view));
          if (firstOfView) setSelectedId(firstOfView.id);
        }
      },
      err => { console.error('rankings onSnapshot', err); setLoading(false); }
    );
    return () => { mounted = false; unsub && unsub(); };
  }, [rankingsCol, selectedId, view]);

  const selectedRanking = React.useMemo(
    () => rankings.find(r => r.id === selectedId) || null,
    [rankings, selectedId]
  );

  React.useEffect(() => {
    const cur = rankings.find(r => r.id === selectedId);
    const curTipo = cur ? (cur.tipo || 'interno') : null;
    if (!cur || curTipo !== view) {
      const first = rankings.find(r => (r.tipo || 'interno') === view);
      setSelectedId(first ? first.id : null);
    }
    setPinVerificado(false);
    setPinInput('');
    setTab("config");
  }, [view, rankings, selectedId]);

  // === Subcolecciones del ranking seleccionado ===
  const matchesCol = React.useMemo(() => {
    if (!rankingsCol || !selectedRanking) return null;
    return rankingsCol.doc(selectedRanking.id).collection('matches');
  }, [rankingsCol, selectedRanking]);

  const awardsCol = React.useMemo(() => {
    if (!rankingsCol || !selectedRanking) return null;
    try { return rankingsCol.doc(selectedRanking.id).collection('awards'); }
    catch (e) { console.warn('awardsCol error', e); return null; }
  }, [rankingsCol, selectedRanking]);

  // === Hidratar estado desde el ranking seleccionado ===
  React.useEffect(() => {
    if (!selectedRanking) {
      setParticipantes([]);
      setTeams([]);
      setPuntosCfg({ win: 3, draw: 1, loss: 0 });
      setAjustesManual({});
      setAjustesTorneos({});
      setExcluidosInterno([]);
      setExcluidosTorneos([]);
      setMatches([]);
      setAwardsList([]);
      setAwardsTotals({});
      return;
    }
    setParticipantes(Array.isArray(selectedRanking.participantes) ? selectedRanking.participantes : []);
    setTeams(Array.isArray(selectedRanking.teams) ? selectedRanking.teams : []);
    setPuntosCfg(selectedRanking.puntosCfg || { win: 3, draw: 1, loss: 0 });
    setAjustesManual(selectedRanking.ajustesManual || selectedRanking.ajustes || {});
    setAjustesTorneos(selectedRanking.ajustesTorneos || {});
    setExcluidosInterno(selectedRanking.excluidosInterno || []);
    setExcluidosTorneos(selectedRanking.excluidosTorneos || []);
    setPinVerificado(false);
    setPinInput('');
  }, [selectedRanking]);

  // === Suscripciones ===
  React.useEffect(() => {
    if (!matchesCol) return;
    const unsub = matchesCol.orderBy('fecha', 'desc').onSnapshot(
      snap => setMatches(snap.docs.map(d => ({ id: d.id, ...d.data() }))),
      err => console.error('matches onSnapshot', err)
    );
    return () => unsub && unsub();
  }, [matchesCol]);

  React.useEffect(() => {
    if (!awardsCol) { setAwardsTotals({}); setAwardsList([]); return; }
    const unsub = awardsCol.onSnapshot(
      snap => {
        const docs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        setAwardsList(docs);
        const tot = {};
        for (const doc of docs) {
          const res = doc.resumen || {};
          for (const [id, v] of Object.entries(res)) {
            const t = tot[id] || { PJ: 0, G: 0, E: 0, P: 0 };
            t.PJ += (v.PJ || 0); t.G += (v.G || 0); t.E += (v.E || 0); t.P += (v.P || 0);
            tot[id] = t;
          }
        }
        setAwardsTotals(tot);
      },
      err => { console.error('awards onSnapshot', err); setAwardsTotals({}); setAwardsList([]); }
    );
    return () => unsub && unsub();
  }, [awardsCol]);

  // === CRUD Rankings ===
  const createRanking = async () => {
    if (!rankingsCol) return;
    if (!newNombre.trim()) return alert("Poné un nombre para el ranking.");
    await rankingsCol.add({
      nombre: newNombre.trim(),
      notas: newNotas.trim(),
      participantes: [],
      teams: [],
      puntosCfg: { win: 3, draw: 1, loss: 0 },
      ajustesManual: {},
      ajustesTorneos: {},
      excluidosInterno: [],
      excluidosTorneos: [],
      tipo: view,
      torneosFinalizado: false,
      createdAt: Date.now(),
      updatedAt: Date.now()
    });
    setNewNombre(""); setNewNotas("");
  };

  const updateRanking = async () => {
    if (!rankingsCol || !selectedRanking) return;
    const payload = {
      participantes,
      teams,
      puntosCfg,
      ajustesManual,
      ajustesTorneos,
      excluidosInterno,
      excluidosTorneos,
      torneosFinalizado: !!selectedRanking.torneosFinalizado,
      updatedAt: Date.now()
    };
    await rankingsCol.doc(selectedRanking.id).set(payload, { merge: true });
    alert("Ranking guardado");
  };

  const handleSave = async () => {
    if (view === 'torneos' && selectedRanking?.torneosFinalizado && !pinVerificado) {
      alert('Para editar/guardar el Ranking de Torneos finalizado, ingresá tu PIN de 3 dígitos.');
      return;
    }
    await updateRanking();
  };

  const deleteRanking = async (id) => {
    if (!rankingsCol) return;
    if (!confirm("¿Eliminar este ranking? Se borrarán también los partidos.")) return;
    const col = rankingsCol.doc(id).collection('matches');
    const snap = await col.get();
    const batch = db.batch();
    snap.forEach(doc => batch.delete(doc.ref));
    batch.delete(rankingsCol.doc(id));
    await batch.commit();
    if (selectedId === id) setSelectedId(null);
  };

  const submitMatch = async (e) => {
    e.preventDefault();
    if (!matchesCol) return;

    const { fecha, resultado, score } = matchForm;
    const cfg = puntosCfg || { win: 3, draw: 1, loss: 0 };

    let puntosA = 0, puntosB = 0, ganador = null;
    if (resultado === "A") { puntosA = cfg.win; puntosB = cfg.loss; ganador = "A"; }
    else if (resultado === "B") { puntosA = cfg.loss; puntosB = cfg.win; ganador = "B"; }
    else { puntosA = cfg.draw; puntosB = cfg.draw; ganador = "D"; }

    const matchPayload = {
      fecha: fecha || formatDate(new Date()),
      resultado: ganador,
      score: score || "",
      puntosA,
      puntosB,
      modalidad: modalidadPartido,
      createdAt: Date.now()
    };

    if (modalidadPartido === "singles") {
      const { jugadorA, jugadorB } = matchForm;
      if (!jugadorA || !jugadorB || jugadorA === jugadorB) {
        return alert("Elegí dos alumnos distintos.");
      }
      if (!participantes.includes(jugadorA) || !participantes.includes(jugadorB)) {
        return alert("Ambos jugadores deben estar en el ranking.");
      }
      matchPayload.jugadorA = jugadorA;
      matchPayload.jugadorB = jugadorB;
    } else {
      const { equipoA, equipoB } = matchForm;
      if (!equipoA || !equipoB || equipoA === equipoB) {
        return alert("Elegí dos equipos distintos.");
      }
      matchPayload.equipoA = equipoA;
      matchPayload.equipoB = equipoB;
    }

    await matchesCol.add(matchPayload);
    setMatchForm(f => ({ ...f, score: "" }));
  };

  const deleteMatch = async (id) => {
    if (!matchesCol) return;
    await matchesCol.doc(id).delete();
  };

  const standingsInterno = React.useMemo(() => {
    const ids = participantes || [];
    const base = new Map(ids.map(id => [id, { alumnoId: id, PJ: 0, G: 0, E: 0, P: 0, PTS: 0 }]));

    Object.keys(ajustesManual || {}).forEach(id => {
      if (!base.has(id)) base.set(id, { alumnoId: id, PJ: 0, G: 0, E: 0, P: 0, PTS: 0 });
    });

    const teamsInRanking = teams || [];
    teamsInRanking.forEach(team => {
      team.members.forEach(id => {
        if (!base.has(id)) base.set(id, { alumnoId: id, PJ: 0, G: 0, E: 0, P: 0, PTS: 0 });
      });
    });

    for (const m of matches) {
      if (m.modalidad === 'singles') {
        const A = base.get(m.jugadorA); const B = base.get(m.jugadorB);
        if (!A || !B) continue;
        A.PJ += 1; B.PJ += 1;
        if (m.resultado === "A") { A.G += 1; B.P += 1; A.PTS += (m.puntosA || 0); B.PTS += (m.puntosB || 0); }
        else if (m.resultado === "B") { B.G += 1; A.P += 1; A.PTS += (m.puntosA || 0); B.PTS += (m.puntosB || 0); }
        else { A.E += 1; B.E += 1; A.PTS += (m.puntosA || 0); B.PTS += (m.puntosB || 0); }
      } else {
        const teamA = teamsMap.get(m.equipoA);
        const teamB = teamsMap.get(m.equipoB);
        if (!teamA || !teamB) continue;

        teamA.members.forEach(id => {
          const p = base.get(id);
          if (p) {
            p.PJ += 1;
            if (m.resultado === "A") { p.G += 1; p.PTS += (m.puntosA || 0); }
            else if (m.resultado === "B") { p.P += 1; p.PTS += (m.puntosB || 0); }
            else { p.E += 1; p.PTS += (m.puntosA || 0); }
          }
        });
        teamB.members.forEach(id => {
          const p = base.get(id);
          if (p) {
            p.PJ += 1;
            if (m.resultado === "B") { p.G += 1; p.PTS += (m.puntosB || 0); }
            else if (m.resultado === "A") { p.P += 1; p.PTS += (m.puntosA || 0); }
            else { p.E += 1; p.PTS += (m.puntosB || 0); }
          }
        });
      }
    }

    for (const [id, extra] of Object.entries(ajustesManual || {})) {
      const row = base.get(id);
      if (row) row.PTS += Number(extra) || 0;
    }

    const arr = Array.from(base.values());
    arr.sort((a, b) => {
      if (b.PTS !== a.PTS) return b.PTS - a.PTS;
      if (b.G !== a.G) return b.G - a.G;
      const nameA = (getNombreCompleto(alumnosMap.get(a.alumnoId)) || "").toLowerCase();
      const nameB = (getNombreCompleto(alumnosMap.get(b.alumnoId)) || "").toLowerCase();
      return nameA.localeCompare(nameB);
    });

    const excl = new Set(excluidosInterno || []);
    return arr.filter(r => !excl.has(r.alumnoId));
  }, [participantes, teams, matches, ajustesManual, puntosCfg, alumnosMap, excluidosInterno, teamsMap]);

  const num = (x, d = 0) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : d;
  };
  const pickNum = (obj, keys, d = 0) => {
    for (const k of keys) if (obj && obj[k] != null) return num(obj[k], d);
    return d;
  };

  function computePtsFromAward(v = {}, metaIn = {}) {
    if (typeof v === "number") return num(v, 0);

    const meta = metaIn || {};
    const koCfg = meta.ko || meta.KO || meta;
    const ligaCfg = meta.liga || meta.league || meta;

    const mode = String(meta.modo || meta.mode || meta.modoDePuntaje || "").toLowerCase();
    const mult = pickNum(meta, ["mult", "multiplier", "multiplicadorCategoria"], 1);
    const koWin = pickNum(meta, ["koPuntosPorVictoria", "koWinPts"], 0);
    const stage = String(v.stage || v.ronda || v.fase || "").toLowerCase();
    const pos = v.pos ?? v.position ?? v.place ?? null;
    const ligaPos = v.ligaPos ?? v.leaguePos ?? v.posLiga ?? null;
    let pts = 0;

    if (mode.includes("part")) {
      pts += num(v.G, 0) * koWin;
    }

    const ko = {
      champion: pickNum(koCfg, ["campeon", "champion", "koCampeon"], 0),
      runnerUp: pickNum(koCfg, ["subcampeon", "runnerUp", "koSubcampeon"], 0),
      semi: pickNum(koCfg, ["semifinal", "semi", "koSemifinal"], 0),
      quarter: pickNum(koCfg, ["cuartos", "quarter", "koCuartos"], 0),
      last16: pickNum(koCfg, ["r16", "last16", "koR16"], 0),
      last32: pickNum(koCfg, ["r32", "last32", "koR32"], 0),
    };
    if (pos === 1) pts += ko.champion;
    else if (pos === 2) pts += ko.runnerUp;
    else if (/semi/.test(stage)) pts += ko.semi;
    else if (/cuart|quart/.test(stage)) pts += ko.quarter;
    else if (/r16|octav|last ?16/.test(stage)) pts += ko.last16;
    else if (/r32|32avos|last ?32/.test(stage)) pts += ko.last32;

    const liga = {
      p1: pickNum(ligaCfg, ["ligaPos1", "pos1", "leaguePos1"], 0),
      p2: pickNum(ligaCfg, ["ligaPos2", "pos2", "leaguePos2"], 0),
      p3: pickNum(ligaCfg, ["ligaPos3", "pos3", "leaguePos3"], 0),
      p4: pickNum(ligaCfg, ["ligaPos4", "pos4", "leaguePos4"], 0),
      p5: pickNum(ligaCfg, ["ligaPos5", "pos5", "leaguePos5"], 0),
      part: pickNum(ligaCfg, ["ligaParticipacion", "participacion", "leagueParticipation"], 0),
    };
    if (num(ligaPos, 0) === 1) pts += liga.p1;
    else if (ligaPos === 2) pts += liga.p2;
    else if (ligaPos === 3) pts += liga.p3;
    else if (ligaPos === 4) pts += liga.p4;
    else if (ligaPos === 5) pts += liga.p5;
    else if (v.participacion || v.participation) pts += liga.part;

    if (!pts) pts = num(v.PTS ?? v.puntos, 0);
    return pts * mult;
  }

  const standingsTorneos = React.useMemo(() => {
    const torneoPTS = {};
    const idsFromResumen = new Set();
    for (const doc of (awardsList || [])) {
      const meta = doc.meta || doc.config || doc.puntos || doc.puntaje || doc.rankingConfig || {};
      const res = doc.resumen || {};
      for (const [id, v] of Object.entries(res)) {
        idsFromResumen.add(id);
        let pts = 0;
        if (typeof v === "number") {
          pts = num(v, 0);
        } else if (v && typeof v === "object") {
          pts = computePtsFromAward(v, meta);
          if (!pts) pts = num(v.PTS ?? v.puntos, 0);
        }
        torneoPTS[id] = (torneoPTS[id] || 0) + (pts || 0);
      }
    }
    const ids = Array.from(new Set([
      ...Object.keys(awardsTotals || {}),
      ...Object.keys(torneoPTS || {}),
      ...Object.keys(ajustesTorneos || {}),
      ...Array.from(idsFromResumen),
    ]));
    if (ids.length === 0) return [];
    const base = new Map(ids.map(id => [id, { alumnoId: id, PJ: 0, G: 0, E: 0, P: 0, PTS: 0 }]));
    for (const [id, cnt] of Object.entries(awardsTotals || {})) {
      const row = base.get(id);
      if (!row) continue;
      row.PJ += (cnt.PJ || 0); row.G += (cnt.G || 0); row.E += (cnt.E || 0); row.P += (cnt.P || 0);
    }
    for (const [id, pts] of Object.entries(torneoPTS)) {
      const row = base.get(id);
      if (row) row.PTS += pts || 0;
    }
    for (const [id, extra] of Object.entries(ajustesTorneos || {})) {
      const row = base.get(id);
      if (row) row.PTS += Number(extra) || 0;
    }
    const arr = Array.from(base.values());
    arr.sort((a, b) => {
      if (b.PTS !== a.PTS) return b.PTS - a.PTS;
      if (b.G !== a.G) return b.G - a.G;
      const nameA = (getNombreCompleto(alumnosMap.get(a.alumnoId)) || "").toLowerCase();
      const nameB = (getNombreCompleto(alumnosMap.get(b.alumnoId)) || "").toLowerCase();
      return nameA.localeCompare(nameB);
    });
    const excl = new Set(excluidosTorneos || []);
    return arr.filter(r => !excl.has(r.alumnoId));
  }, [awardsTotals, awardsList, ajustesTorneos, alumnosMap, excluidosTorneos]);

  const excluirInterno = (id) => {
    if (!id) return;
    if (!confirm("¿Quitar este alumno de la tabla?")) return;
    setExcluidosInterno(prev => prev.includes(id) ? prev : [...prev, id]);
    setParticipantes(prev => prev.filter(x => x !== id));
  };
  const restaurarInterno = (id) => setExcluidosInterno(prev => prev.filter(x => x !== id));

  const excluirTorneos = (id) => {
    if (!id) return;
    if (!confirm("¿Quitar este alumno de la tabla de torneos?")) return;
    setExcluidosTorneos(prev => prev.includes(id) ? prev : [...prev, id]);
  };
  const restaurarTorneos = (id) => setExcluidosTorneos(prev => prev.filter(x => x !== id));

  const torneosFinalizado = !!selectedRanking?.torneosFinalizado;
  const puedeEditarTorneos = !torneosFinalizado || pinVerificado;
  const ajustesBloqueados = torneosFinalizado && !pinVerificado;

  const onCheckPin = () => {
    if (!perfilPin) {
      alert('No hay PIN configurado en tu Perfil. Configuralo para poder editar rankings finalizados.');
      return;
    }
    const val = String(pinInput || '').trim();
    if (!/^\d{3}$/.test(val)) {
      alert('El PIN debe tener 3 dígitos.');
      return;
    }
    if (val === perfilPin) {
      setPinVerificado(true);
      alert('PIN verificado. Edición habilitada hasta que cambies de pestaña o ranking.');
    } else {
      alert('PIN incorrecto.');
    }
  };

  const toggleFinalizado = async () => {
    if (!rankingsCol || !selectedRanking) return;
    const next = !torneosFinalizado;
    if (torneosFinalizado && !pinVerificado) {
      alert('Para reabrir la edición de Torneos, ingresá tu PIN.');
      return;
    }
    await rankingsCol.doc(selectedRanking.id).set({ torneosFinalizado: next, updatedAt: Date.now() }, { merge: true });
    if (next === true) { setPinVerificado(false); setPinInput(''); }
  };

  const filteredRankings = rankings.filter(r => ((r.tipo || 'interno') === view));

  const tabBtn = (t) =>
    `px-3 py-1.5 rounded-lg text-sm transition
     ${tab === t ? "bg-white shadow-sm border border-slate-300" : "border border-transparent text-slate-600 hover:text-slate-800"}`;

  return (
    <div className="space-y-3">
      {/* TABS de vista */}
      <div className="mb-3 flex gap-2">
        <button
          className={`px-3 py-1.5 rounded-lg border ${view === 'interno' ? 'bg-emerald-50 border-emerald-300' : 'bg-white'}`}
          onClick={() => setView('interno')}
        >
          Ranking Interno
        </button>
        <button
          className={`px-3 py-1.5 rounded-lg border ${view === 'torneos' ? 'bg-emerald-50 border-emerald-300' : 'bg-white'}`}
          onClick={() => setView('torneos')}
        >
          Ranking Torneos
        </button>
      </div>

      {/* Layout en 2 columnas */}
      <div className="grid md:grid-cols-12 gap-6">
        {/* Columna izquierda: lista de rankings */}
        <div className="md:col-span-4">
          <Card title={<span className="text-[#34745B]">Rankings</span>} right={null}>
            {loading && <p className="text-sm text-slate-500">Cargando...</p>}
            <ul className="space-y-2">
              {filteredRankings.map(r => (
                <li
                  key={r.id}
                  className={`p-2 rounded-lg border cursor-pointer ${selectedId === r.id ? 'bg-green-50 border-green-300' : 'bg-white'}`}
                  onClick={() => setSelectedId(r.id)}
                >
                  <div className="flex justify-between items-center">
                    <div>
                      <p className="font-semibold text-slate-800">{r.nombre}</p>
                      {r.notas && <p className="text-xs text-slate-500 mt-0.5">{r.notas}</p>}
                      <p className="text-[10px] text-slate-400 mt-1 uppercase tracking-wide">Tipo: {(r.tipo || 'interno')}</p>
                    </div>
                    <button
                      className="text-xs px-2 py-1 rounded-lg border text-red-600 hover:bg-red-50"
                      onClick={(e) => { e.stopPropagation(); deleteRanking(r.id); }}
                      title="Eliminar ranking"
                    >
                      🗑️
                    </button>
                  </div>
                </li>
              ))}
              {filteredRankings.length === 0 && (
                <li className="text-sm text-slate-500 p-2">No hay rankings de tipo “{view}”.</li>
              )}
            </ul>
            <div className="mt-4 border-t pt-4">
              <p className="text-sm font-semibold text-slate-700 mb-1">
                Nuevo ranking <span className="text-xs text-slate-500">(tipo: {view})</span>
              </p>
              <input
                type="text"
                value={newNombre}
                onChange={e => setNewNombre(e.target.value)}
                placeholder="Ej: Ranking Avanzados 2024"
                className="w-full border rounded-lg px-3 py-2 mb-2"
              />
              <input
                type="text"
                value={newNotas}
                onChange={e => setNewNotas(e.target.value)}
                placeholder="Notas (opcional)"
                className="w-full border rounded-lg px-3 py-2 mb-2"
              />
              <button
                onClick={createRanking}
                className="px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white text-sm"
              >
                + Crear
              </button>
            </div>
          </Card>
        </div>

        {/* Columna derecha: detalle según vista */}
        <div className="md:col-span-8">
          {selectedRanking ? (
            view === 'interno' ? (
              <Card
                title={<span className="text-[#34745B]">{selectedRanking.nombre}</span>}
                right={<button onClick={handleSave} className="px-3 py-1.5 rounded-lg bg-[#34745B] hover:bg-green-800 text-white text-sm">Guardar</button>}
              >
                <div className="flex flex-wrap gap-2 mb-4">
                  <button className={tabBtn("config")} onClick={() => setTab("config")}>Configuración</button>
                  <button className={tabBtn("registrar")} onClick={() => setTab("registrar")}>Registrar Partido</button>
                  <button className={tabBtn("tabla")} onClick={() => setTab("tabla")}>Tabla de Posiciones</button>
                  <button className={tabBtn("historial")} onClick={() => setTab("historial")}>Historial de Partidos</button>
                </div>

                {tab === 'config' && (
                  <div className="grid md:grid-cols-2 gap-4">
                    <div>
                      <p className="text-sm font-semibold text-slate-700 mb-1">Agregar participante (Singles)</p>
                      <select
                        value=""
                        onChange={e => addParticipante(e.target.value)}
                        className="w-full border rounded-lg px-3 py-2"
                      >
                        <option value="">— Seleccionar alumno —</option>
                        {alumnos.map(a => (
                          <option key={a.id} value={a.id}>{getNombreCompleto(a)}</option>
                        ))}
                      </select>
                      {participantes.length > 0 && (
                        <ul className="mt-2 space-y-1 text-sm">
                          {participantes.map(id => (
                            <li key={id} className="flex justify-between items-center border rounded-lg px-2 py-1">
                              <span>{getNombreCompleto(alumnosMap.get(id))}</span>
                              <button className="text-xs px-2 py-0.5 rounded border hover:bg-slate-50" onClick={() => removeParticipante(id)}>Quitar</button>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                    <div>
                      <p className="text-sm font-semibold text-slate-700 mb-1">Crear parejas (Dobles)</p>
                      <div className="grid md:grid-cols-3 gap-2 items-end">
                        <select className="w-full border rounded-lg p-2" value={sel1} onChange={e => setSel1(e.target.value)}>
                          <option value="">Jugador 1</option>
                          {alumnos.map(a => <option key={a.id} value={a.id}>{getNombreCompleto(a)}</option>)}
                        </select>
                        <select className="w-full border rounded-lg p-2" value={sel2} onChange={e => setSel2(e.target.value)}>
                          <option value="">Jugador 2</option>
                          {alumnos.map(a => <option key={a.id} value={a.id}>{getNombreCompleto(a)}</option>)}
                        </select>
                        <button type="button" onClick={addTeam} className="px-3 py-2 rounded-lg bg-slate-800 text-white disabled:opacity-50" disabled={!sel1 || !sel2}>Crear</button>
                      </div>
                      {teams.length > 0 && (
                        <ul className="mt-2 space-y-1 text-sm">
                          {teams.map(t => (
                            <li key={t.id} className="flex justify-between items-center border rounded-lg px-2 py-1">
                              <span>{getTeamLabel(t.id)}</span>
                              <button className="text-xs px-2 py-0.5 rounded border hover:bg-slate-50" onClick={() => removeTeam(t.id)}>Quitar</button>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                    <div className="md:col-span-2">
                      <p className="text-sm font-semibold text-slate-700 mb-1">Puntos</p>
                      <div className="grid grid-cols-3 gap-2 mb-2">
                        <div><label className="text-xs">Ganar</label><input type="number" value={puntosCfg.win} onChange={e => setPuntosCfg(cfg => ({ ...cfg, win: Number(e.target.value) || 0 }))} className="w-full border rounded-lg px-2 py-1" /></div>
                        <div><label className="text-xs">Empatar</label><input type="number" value={puntosCfg.draw} onChange={e => setPuntosCfg(cfg => ({ ...cfg, draw: Number(e.target.value) || 0 }))} className="w-full border rounded-lg px-2 py-1" /></div>
                        <div><label className="text-xs">Perder</label><input type="number" value={puntosCfg.loss} onChange={e => setPuntosCfg(cfg => ({ ...cfg, loss: Number(e.target.value) || 0 }))} className="w-full border rounded-lg px-2 py-1" /></div>
                      </div>
                    </div>
                  </div>
                )}

                {tab === 'registrar' && (
                  <div>
                    <p className="text-sm font-semibold text-slate-700 mb-2">Registrar partido</p>
                    <form onSubmit={submitMatch} className="grid md:grid-cols-6 gap-2 items-end">
                      <div className="md:col-span-2">
                        <label className="text-xs">Modalidad</label>
                        <select value={modalidadPartido} onChange={e => setModalidadPartido(e.target.value)} className="w-full border rounded-lg px-2 py-1">
                          <option value="singles">Singles</option>
                          <option value="dobles">Dobles</option>
                        </select>
                      </div>
                      <div className="md:col-span-2">
                        <label className="text-xs">Fecha</label>
                        <input type="date" value={matchForm.fecha} onChange={e => setMatchForm(f => ({ ...f, fecha: e.target.value }))} className="w-full border rounded-lg px-2 py-1" />
                      </div>
                      {modalidadPartido === 'singles' ? (
                        <>
                          <div className="md:col-span-2">
                            <label className="text-xs">Jugador A</label>
                            <select value={matchForm.jugadorA} onChange={e => setMatchForm(f => ({ ...f, jugadorA: e.target.value }))} className="w-full border rounded-lg px-2 py-1">
                              <option value="">—</option>
                              {participantes.map(id => <option key={id} value={id}>{getNombreCompleto(alumnosMap.get(id))}</option>)}
                            </select>
                          </div>
                          <div className="md:col-span-2">
                            <label className="text-xs">Jugador B</label>
                            <select value={matchForm.jugadorB} onChange={e => setMatchForm(f => ({ ...f, jugadorB: e.target.value }))} className="w-full border rounded-lg px-2 py-1">
                              <option value="">—</option>
                              {participantes.map(id => <option key={id} value={id}>{getNombreCompleto(alumnosMap.get(id))}</option>)}
                            </select>
                          </div>
                        </>
                      ) : (
                        <>
                          <div className="md:col-span-2">
                            <label className="text-xs">Equipo A</label>
                            <select value={matchForm.equipoA} onChange={e => setMatchForm(f => ({ ...f, equipoA: e.target.value }))} className="w-full border rounded-lg px-2 py-1">
                              <option value="">—</option>
                              {teams.map(t => <option key={t.id} value={t.id}>{getTeamLabel(t.id)}</option>)}
                            </select>
                          </div>
                          <div className="md:col-span-2">
                            <label className="text-xs">Equipo B</label>
                            <select value={matchForm.equipoB} onChange={e => setMatchForm(f => ({ ...f, equipoB: e.target.value }))} className="w-full border rounded-lg px-2 py-1">
                              <option value="">—</option>
                              {teams.map(t => <option key={t.id} value={t.id}>{getTeamLabel(t.id)}</option>)}
                            </select>
                          </div>
                        </>
                      )}
                      <div className="md:col-span-2">
                        <label className="text-xs">Resultado</label>
                        <select value={matchForm.resultado} onChange={e => setMatchForm(f => ({ ...f, resultado: e.target.value }))} className="w-full border rounded-lg px-2 py-1">
                          <option value="A">Gana A</option>
                          <option value="B">Gana B</option>
                          <option value="D">Empate</option>
                        </select>
                      </div>
                      <div className="md:col-span-2">
                        <label className="text-xs">Score (opcional)</label>
                        <input type="text" value={matchForm.score} onChange={e => setMatchForm(f => ({ ...f, score: e.target.value }))} className="w-full border rounded-lg px-2 py-1" placeholder="Ej: 6-4 4-6 10-8" />
                      </div>
                      <div className="md:col-span-2">
                        <button type="submit" className="w-full px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white text-sm">+ Registrar</button>
                      </div>
                    </form>
                  </div>
                )}

                {tab === 'tabla' && (
                  <div>
                    <div className="flex items-center justify-between mb-2">
                      <p className="text-sm font-semibold text-slate-700">Tabla de Posiciones — Ranking Interno</p>
                      <button className="text-xs px-2 py-1 rounded-lg border hover:bg-slate-50"
                        onClick={() => setEditRowsInterno(s => !s)}>
                        {editRowsInterno ? "Listo" : "Editar tabla"}
                      </button>
                    </div>
                    <div className="overflow-x-auto max-h-[60vh] overflow-y-auto rounded-lg border">
                      <table className="min-w-full text-sm">
                        <thead className="sticky top-0 z-10 bg-white shadow-sm">
                          <tr className="text-left text-slate-700">
                            <th className="p-2">#</th>
                            <th className="p-2">Alumno</th>
                            <th className="p-2">PJ</th>
                            <th className="p-2">G</th>
                            <th className="p-2">E</th>
                            <th className="p-2">P</th>
                            <th className="p-2">PTS</th>
                            {editRowsInterno && <th className="p-2 w-12"></th>}
                          </tr>
                        </thead>
                        <tbody>
                          {standingsInterno.length === 0 && (
                            <tr><td colSpan={editRowsInterno ? 8 : 7} className="text-center py-6 text-slate-400">Sin participantes o partidos</td></tr>
                          )}
                          {standingsInterno.map((row, idx) => (
                            <tr key={row.alumnoId} className="border-t odd:bg-white even:bg-slate-50">
                              <td className="p-2">{idx + 1}</td>
                              <td className="p-2">{getNombreCompleto(alumnosMap.get(row.alumnoId))}</td>
                              <td className="p-2">{row.PJ}</td>
                              <td className="p-2">{row.G}</td>
                              <td className="p-2">{row.E}</td>
                              <td className="p-2">{row.P}</td>
                              <td className="p-2 font-bold">{row.PTS}</td>
                              {editRowsInterno && (
                                <td className="p-2 text-right">
                                  <button className="text-xs px-2 py-1 rounded-lg border text-red-600 hover:bg-red-50"
                                    onClick={() => excluirInterno(row.alumnoId)}
                                    title="Quitar de la tabla">
                                    🗑️
                                  </button>
                                </td>
                              )}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    {editRowsInterno && excluidosInterno.length > 0 && (
                      <div className="mt-2 text-xs">
                        <div className="font-medium mb-1">Excluidos</div>
                        <ul className="flex flex-wrap gap-2">
                          {excluidosInterno.map(id => (
                            <li key={id} className="px-2 py-1 rounded border bg-slate-50">
                              {getNombreCompleto(alumnosMap.get(id))}
                              <button className="ml-2 underline" onClick={() => restaurarInterno(id)}>Restaurar</button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                )}

                {tab === 'historial' && (
                  <div>
                    <p className="text-sm font-semibold text-slate-700 mb-2">Historial de Partidos</p>
                    {matches.length === 0 && <p className="text-sm text-slate-500">Sin partidos registrados.</p>}
                    <ul className="space-y-2">
                      {matches.map(m => (
                        <li key={m.id} className="p-2 border rounded-lg bg-white flex justify-between items-center">
                          <div className="text-sm">
                            <span className="text-slate-500 mr-2">{m.fecha}</span>
                            {m.modalidad === 'singles' ? (
                              <>
                                <b>{getNombreCompleto(alumnosMap.get(m.jugadorA))}</b> vs <b>{getNombreCompleto(alumnosMap.get(m.jugadorB))}</b>
                              </>
                            ) : (
                              <>
                                <b>{getTeamLabel(m.equipoA)}</b> vs <b>{getTeamLabel(m.equipoB)}</b>
                              </>
                            )}
                            {m.score ? <> — <span className="text-slate-600">{m.score}</span></> : null}
                            <span className="ml-2 text-xs px-2 py-0.5 rounded-full bg-emerald-100 text-emerald-700">
                              {m.resultado === "A" ? "Gana A" : m.resultado === "B" ? "Gana B" : "Empate"}
                            </span>
                          </div>
                          <button className="text-xs px-2 py-1 rounded-lg border text-red-600 hover:bg-red-50"
                            onClick={() => deleteMatch(m.id)}>
                            🗑️
                          </button>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </Card>
            ) : (
              // ====== VISTA TORNEOS ======
              <Card
                title={<span className="text-[#34745B]">{selectedRanking.nombre}</span>}
                right={<button onClick={handleSave} disabled={torneosFinalizado && !pinVerificado} className={`px-3 py-1.5 rounded-lg text-white text-sm ${torneosFinalizado && !pinVerificado ? 'bg-slate-400 cursor-not-allowed' : 'bg-[#34745B] hover:bg-green-800'}`}>Guardar</button>}
              >
                <div className="flex items-center justify-between mb-2">
                  <p className="text-xs text-slate-500">Vista basada en torneos aplicados</p>
                  <div className="flex items-center gap-2">
                    <span className={`text-xs ${torneosFinalizado ? 'text-rose-600' : 'text-emerald-700'}`}>
                      Estado: {torneosFinalizado ? 'Finalizado (bloqueado)' : 'Abierto'}
                    </span>
                    <button onClick={toggleFinalizado} className="text-xs px-2 py-1 rounded-lg border hover:bg-slate-50">
                      {torneosFinalizado ? 'Reabrir' : 'Marcar finalizado'}
                    </button>
                  </div>
                </div>

                {torneosFinalizado && !pinVerificado && (
                  <div className="mb-4 p-3 rounded-lg border bg-amber-50">
                    <p className="text-sm font-semibold text-amber-800">Edición bloqueada</p>
                    <p className="text-xs text-amber-700 mb-2">Este ranking de torneos está marcado como finalizado. Ingresá tu PIN (3 dígitos) para habilitar la edición.</p>
                    <div className="flex items-center gap-2">
                      <input
                        type="password"
                        inputMode="numeric"
                        maxLength={3}
                        value={pinInput}
                        onChange={e => setPinInput(e.target.value.replace(/\D/g, ''))}
                        className="w-24 border rounded-lg px-2 py-1 text-sm tracking-widest text-center"
                        placeholder="•••"
                      />
                      <button onClick={onCheckPin} className="text-xs px-3 py-1.5 rounded-lg bg-[#34745B] hover:bg-green-800 text-white">Desbloquear</button>
                    </div>
                    {!perfilPin && <p className="text-xs text-rose-600 mt-2">No hay PIN configurado en tu Perfil.</p>}
                  </div>
                )}

                <div className="flex items-center justify-between mb-3">
                  <div className="inline-flex rounded-xl border border-slate-200 bg-slate-50 p-0.5">
                    <button className={tabBtn("tabla")} onClick={() => setRtTab("tabla")}>Tabla</button>
                    <button className={tabBtn("ajustes")} onClick={() => setRtTab("ajustes")}>Ajustes</button>
                  </div>

                  {rtTab === "tabla" && (
                    <button className="text-xs px-2 py-1 rounded-lg border hover:bg-slate-50"
                      onClick={() => setEditRowsTorneos(s => !s)}>
                      {editRowsTorneos ? "Listo" : "Editar tabla"}
                    </button>
                  )}
                </div>

                {rtTab === "tabla" && (
                  <section>
                    <div className="overflow-x-auto max-h-[60vh] overflow-y-auto rounded-lg border">
                      <table className="min-w-full text-sm">
                        <thead className="sticky top-0 z-10 bg-white shadow-sm">
                          <tr className="text-left text-slate-700">
                            <th className="p-2">#</th>
                            <th className="p-2">Alumno</th>
                            <th className="p-2">PJ</th>
                            <th className="p-2">G</th>
                            <th className="p-2">E</th>
                            <th className="p-2">P</th>
                            <th className="p-2">PTS</th>
                            {editRowsTorneos && <th className="p-2 w-12"></th>}
                          </tr>
                        </thead>
                        <tbody>
                          {standingsTorneos.length === 0 && (
                            <tr><td colSpan={editRowsTorneos ? 8 : 7} className="text-center py-6 text-slate-400">Sin torneos aplicados</td></tr>
                          )}
                          {standingsTorneos.map((row, idx) => (
                            <tr key={row.alumnoId} className="border-t odd:bg-white even:bg-slate-50">
                              <td className="p-2">{idx + 1}</td>
                              <td className="p-2">{getNombreCompleto(alumnosMap.get(row.alumnoId))}</td>
                              <td className="p-2">{row.PJ}</td>
                              <td className="p-2">{row.G}</td>
                              <td className="p-2">{row.E}</td>
                              <td className="p-2">{row.P}</td>
                              <td className="p-2 font-bold">{row.PTS}</td>
                              {editRowsTorneos && (
                                <td className="p-2 text-right">
                                  <button className="text-xs px-2 py-1 rounded-lg border text-red-600 hover:bg-red-50"
                                    onClick={() => excluirTorneos(row.alumnoId)}
                                    title="Quitar de la tabla">
                                    🗑️
                                  </button>
                                </td>
                              )}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    {editRowsTorneos && excluidosTorneos.length > 0 && (
                      <div className="mt-2 text-xs">
                        <div className="font-medium mb-1">Excluidos</div>
                        <ul className="flex flex-wrap gap-2">
                          {excluidosTorneos.map(id => (
                            <li key={id} className="px-2 py-1 rounded border bg-slate-50">
                              {getNombreCompleto(alumnosMap.get(id))}
                              <button className="ml-2 underline" onClick={() => restaurarTorneos(id)}>Restaurar</button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </section>
                )}

                {rtTab === "ajustes" && (
                  <section className="mt-2">
                    <div className="font-semibold mb-2">Ajustes de puntos (torneos)</div>
                    {ajustesBloqueados && (
                      <div className="mb-2 text-xs text-rose-600">
                        Edición bloqueada. Desbloqueá con tu PIN para modificar ajustes.
                      </div>
                    )}
                    <div className="space-y-1 max-w-[520px]">
                      {Object.keys({
                        ...awardsTotals,
                        ...awardsList.reduce((acc, d) => ({ ...acc, ...(d.resumen || {}) }), {})
                      })
                        .filter(id => !excluidosTorneos.includes(id))
                        .map(id => (
                          <div key={id} className="flex items-center gap-2">
                            <span className="text-sm w-56 truncate">{getNombreCompleto(alumnosMap.get(id))}</span>
                            <input
                              type="number"
                              value={Number(ajustesTorneos?.[id] || 0)}
                              onChange={e => setAjustesTorneos(prev => ({ ...prev, [id]: Number(e.target.value) }))}
                              className="w-24 border rounded-lg px-2 py-1 text-sm"
                              placeholder="+/-"
                              disabled={!puedeEditarTorneos}
                              title={!puedeEditarTorneos ? 'Bloqueado. Ingresá PIN para editar.' : ''}
                            />
                          </div>
                        ))}
                      {Object.keys({
                        ...awardsTotals,
                        ...awardsList.reduce((acc, d) => ({ ...acc, ...(d.resumen || {}) }), {})
                      }).filter(id => !excluidosTorneos.includes(id)).length === 0 && (
                        <p className="text-xs text-slate-500">No hay torneos aplicados todavía.</p>
                      )}
                    </div>
                  </section>
                )}
              </Card>
            )
          ) : (
            <Card title={<span className="text-[#34745B]">Detalle</span>}>
              <p className="text-sm text-slate-500">Seleccioná o creá un ranking para comenzar.</p>
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}

// =========================
// RulesEditor (usa props)
// =========================
function RulesEditor({ title, scope, reglas, setReglas, modalidadUI }) {
  // Subobjeto de reglas que edita este editor ("grupos" o "elim")
  const r = reglas?.[scope] || {};

  // Actualiza solo la rama reglas[scope]
  const setR = (patch) =>
    setReglas(prev => ({
      ...(prev || {}),
      [scope]: { ...(prev?.[scope] || {}), ...patch }
    }));

  const isMatchOnly = !!r.matchOnly;

  return (
    <div className="border rounded-xl p-3 bg-white">
      <p className="text-sm font-semibold text-slate-700 mb-2">{title}</p>

      {/* Reglas base */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
        <div>
          <label className="text-xs text-slate-600">Modalidad</label>
          <select
            className="w-full border rounded-lg px-2 py-1 text-sm"
            value={modalidadUI}
            onChange={e => setR({ modalidad: e.target.value })}
          >
            <option value="singles">Singles</option>
            <option value="dobles">Dobles</option>
          </select>
        </div>

        <div>
          <label className="text-xs text-slate-600">Formato</label>
          <select
            className="w-full border rounded-lg px-2 py-1 text-sm"
            value={r.formatoSets || "bo3"}
            onChange={e => setR({ formatoSets: e.target.value })}
            disabled={isMatchOnly}
            title={isMatchOnly ? "Deshabilitado: partido al match tie-break" : ""}
          >
            <option value="bo1">1 set</option>
            <option value="bo3">Mejor de 3</option>
          </select>
        </div>

        <div>
          <label className="text-xs text-slate-600">Games por set</label>
          <input
            type="number"
            min="1"
            className="w-full border rounded-lg px-2 py-1 text-sm"
            value={r.gamesPorSet ?? 6}
            onChange={e => setR({ gamesPorSet: Number(e.target.value) || 6 })}
            disabled={isMatchOnly}
            title={isMatchOnly ? "Deshabilitado: partido al match tie-break" : ""}
          />
        </div>

        <div>
          <label className="text-xs text-slate-600">Tie-break</label>
          <select
            className="w-full border rounded-lg px-2 py-1 text-sm"
            value={r.tieBreak || "TB7"}
            onChange={e => setR({ tieBreak: e.target.value })}
            disabled={isMatchOnly}
            title={isMatchOnly ? "Deshabilitado: partido al match tie-break" : ""}
          >
            <option value="TB7">TB a 7</option>
            <option value="TB10">TB a 10</option>
            <option value="SinTB">Sin tie-break</option>
          </select>
        </div>
      </div>

      {/* Decider / Match TB */}
      <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
        <div>
          <label className="text-xs text-slate-600 mb-1 block">Set decisivo</label>
          <div className="space-y-1 text-sm">
            <label className="flex flex-wrap items-center gap-2 leading-tight">
              <input
                type="radio"
                name={`decider-${scope}`}
                checked={(r.decider || "set") === "set" && !isMatchOnly}
                onChange={() => setR({ decider: "set", matchOnly: false })}
                disabled={isMatchOnly}
              />
              <span className={isMatchOnly ? "opacity-50" : ""}>Otro set normal</span>
            </label>

            <label className="flex flex-wrap items-center gap-2 leading-tight">
              <input
                type="radio"
                name={`decider-${scope}`}
                checked={(r.decider || "set") === "matchTB" && !isMatchOnly}
                onChange={() => setR({ decider: "matchTB", matchOnly: false })}
                disabled={isMatchOnly}
              />
              <span className={isMatchOnly ? "opacity-50" : ""}>Match tie-break a</span>
              <input
                type="number"
                min={7}
                step={1}
                className="w-20 border rounded px-2 py-1"
                value={Number(r.matchTBPoints || 10)}
                onChange={e => setR({ matchTBPoints: Number(e.target.value) || 10 })}
                disabled={isMatchOnly}
              />
              <span className={isMatchOnly ? "opacity-50" : ""}>puntos</span>
            </label>
          </div>
        </div>

        <div className="sm:pl-2">
          <label className="text-xs text-slate-600 mb-1 block">Partido al match tie-break</label>
          <label className="flex flex-wrap items-center gap-2 text-sm leading-tight">
            <input
              type="checkbox"
              checked={isMatchOnly}
              onChange={e => setR({ matchOnly: e.target.checked })}
            />
            <span>Usar sólo un match tie-break a</span>
            <input
              type="number"
              min={7}
              step={1}
              className="w-20 border rounded px-2 py-1"
              value={Number(r.matchTBPoints || 10)}
              onChange={e => setR({ matchTBPoints: Number(e.target.value) || 10 })}
              disabled={!isMatchOnly}
            />
            <span>puntos</span>
          </label>
          <p className="text-[11px] text-slate-500 mt-1">
            Ignora games por set y tie-breaks de set cuando está activado.
          </p>
        </div>
      </div>

      {/* Solo grupos: ida y vuelta */}
      {scope === "grupos" && (
        <div className="mt-2">
          <label className="inline-flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={!!r.idaVuelta}
              onChange={e => setR({ idaVuelta: e.target.checked })}
              disabled={isMatchOnly}
              title={isMatchOnly ? "No aplica cuando el partido es sólo match TB" : ""}
            />
            <span className={isMatchOnly ? "opacity-50" : ""}>Ida y vuelta</span>
          </label>
        </div>
      )}
    </div>
  );
}


// =========================
// Torneos (pasa reglas/setReglas)
// =========================
// ===== Torneos – Modo Pro por pestañas (drop‑in replacement) =====
// Pega este bloque COMPLETO dentro de tu <script type="text/babel">,
// reemplazando tu componente `Torneos(...)`. No requiere librerías nuevas.
// Usa únicamente Tailwind y React 17 UMD (como tu proyecto actual).

function Torneos({ alumnos = [], user, clubActivoId, perfil = {} }) {
  // ================== Estado general ==================
  const [torneos, setTorneos] = React.useState(() => loadTorneosLS());
  const [selectedId, setSelectedId] = React.useState(null);
  const [creating, setCreating] = React.useState(false);

  // ====== Defaults/normalización de reglas (fallback interno) ======
  const REGLAS_BASE = React.useMemo(() => (
    (typeof DEFAULT_REGLAS !== "undefined" && DEFAULT_REGLAS) || {
      grupos: {
        puntos: { win: 3, draw: 1, loss: 0 },
        wo: {                // Walkover (no presentación)
          ptsWin: 3,
          ptsLoss: 0,
          gf: 0,
          gc: 0
        },
        bye: {               // BYE estructural (descanso)
          cuenta: false,     // true = cuenta como victoria automática
          ptsWin: 3,
          gf: 0,
          gc: 0
        }
      }
    }
  ), []);

  const mergeReglas = React.useCallback((r = {}) => {
    const g = r.grupos || {};
    return {
      ...REGLAS_BASE,
      ...r,
      grupos: {
        ...REGLAS_BASE.grupos,
        ...g,
        puntos: {
          ...REGLAS_BASE.grupos.puntos,
          ...(g.puntos || {})
        },
        wo: {
          ...REGLAS_BASE.grupos.wo,
          ...(g.wo || {})
        },
        bye: {
          ...REGLAS_BASE.grupos.bye,
          ...(g.bye || {})
        }
      }
    };
  }, [REGLAS_BASE]);

  // Normalizar reglas de torneos cargados (solo 1 vez)
  const normalizedOnce = React.useRef(false);
  React.useEffect(() => {
    if (!normalizedOnce.current) {
      setTorneos(ts => ts.map(t => ({ ...t, reglas: mergeReglas(t.reglas) })));
      normalizedOnce.current = true;
    }
  }, [mergeReglas]);

  const selected = React.useMemo(
    () => torneos.find(t => t.id === selectedId) || null,
    [torneos, selectedId]
  );

  // Persistencia Local
  React.useEffect(() => {
    saveTorneosLS(torneos);
  }, [torneos]);

  // ====== Helpers locales ======
  const genId = React.useCallback(() => (
    crypto?.randomUUID?.() ??
    ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    )
  ), []);

  // Crear torneo con reglas por defecto + estructura base
  const crearTorneo = React.useCallback(() => {
    const nuevo = {
      id: genId(),
      nombre: "Torneo nuevo",
      formato: "grupos",     // 'grupos' | 'eliminacion' | 'grupos_y_eliminacion'
      modalidad: "singles",  // 'singles' | 'dobles'
      reglas: REGLAS_BASE,   // defaults con WO/BYE
      grupos: [],
      fixture: {},
      cuadro: {},
      estado: "config",
      createdAt: Date.now()
    };
    setTorneos(prev => [nuevo, ...prev]);
    setSelectedId(nuevo.id);
    setCreating(true);
  }, [genId, REGLAS_BASE]);

  const handleCreate = () => {
    crearTorneo();
  };

  const handleClone = (id) => {
    const base = torneos.find(t => t.id === id);
    if (!base) return;
    const clone = {
      ...deepClone(base),
      id: genId(),
      nombre: (base.nombre || "Torneo") + " (copia)",
      estado: "config",
      reglas: mergeReglas(base.reglas) // asegurar defaults en el clon
    };
    setTorneos(prev => [clone, ...prev]);
    setSelectedId(clone.id);
  };

  const handleDelete = (id) => {
    if (!confirm("¿Eliminar este torneo?")) return;
    setTorneos(prev => prev.filter(t => t.id !== id));
    if (selectedId === id) setSelectedId(null);
  };

  const upsert = (patch) => {
    setTorneos(prev => prev.map(t => {
      if (t.id !== patch.id) return t;
      const next = { ...t, ...patch };
      if (patch.reglas) next.reglas = mergeReglas({ ...(t.reglas || {}), ...(patch.reglas || {}) });
      return next;
    }));
  };

  // === Helpers para etiquetar en la tarjeta (robustos) ===
  const alumnoByIdCard = React.useCallback(
    (id) => (alumnos || []).find(a => a && a.id === id) || null,
    [alumnos]
  );

  const labelEntradaCard = (e, t) => {
    try {
      if (!t || t.modalidad !== 'dobles') {
        const id = typeof e === 'string' ? e : e?.id;
        const a = alumnoByIdCard(id) || {};
        const ap = a.apellido || "";
        const no = a.nombre || a.name || "";
        return `${ap ? ap + ", " : ""}${no || a.id || "—"}`.trim();
      } else {
        let team = e && e.members ? e : (t.teams || []).find(tt => tt.id === (typeof e === 'string' ? e : e?.id));
        if (!team) return "—";
        const [id1, id2] = team.members || [];
        const A = alumnoByIdCard(id1) || {};
        const B = alumnoByIdCard(id2) || {};
        const fmt = (x) => `${x.apellido ? x.apellido + ", " : ""}${x.nombre || x.name || x.id || ""}`.trim();
        const la = fmt(A);
        const lb = fmt(B);
        return (la && lb) ? `${la} / ${lb}` : (la || lb || "—");
      }
    } catch (err) {
      console.error("labelEntradaCard error:", err, { e, t });
      return "—";
    }
  };

  // ================== UI ==================
  return (
    <div className="grid gap-4">
      {/* Header */}
      <header className="flex items-center justify-between flex-wrap gap-2">
        <h2 className="text-xl font-bold text-[#34745B]">Torneos</h2>
        <div className="flex gap-2">
          <button className="px-3 py-2 rounded-xl bg-[#34745B] text-white hover:opacity-90" onClick={handleCreate}>
            + Nuevo torneo
          </button>
        </div>
      </header>

      {/* Lista VERTICAL de torneos */}
      <section className="border rounded-2xl p-3">
        {torneos.length === 0 ? (
          <div className="text-slate-500 text-sm">
            Aún no hay torneos. Creá uno con “+ Nuevo torneo”.
          </div>
        ) : (
          <div className="space-y-3">
            {torneos.map(t => {
              // Campeón/Sub de KO o de Liga (para mostrar en la tarjeta)
              const fin  = bracketFinalInfo(t.cuadro);
              const liga = leagueWinnersInfo(t);

              const champLabel = fin?.done
                ? labelEntradaCard(findEntry(fin.champion, t), t)
                : (liga?.done && liga.type === 'single'
                    ? labelEntradaCard(findEntry(liga.champion, t), t)
                    : null);

              const runnerLabel = fin?.done
                ? labelEntradaCard(findEntry(fin.runnerUp, t), t)
                : (liga?.done && liga.type === 'single' && liga.runnerUp
                    ? labelEntradaCard(findEntry(liga.runnerUp, t), t)
                    : null);

              return (
                <div
                  key={t.id}
                  className={cx(
                    "w-full border rounded-2xl p-3 transition cursor-pointer",
                    selectedId === t.id ? "border-[#34745B] bg-[#34745B]/5" : "border-slate-200 hover:bg-slate-50"
                  )}
                  onClick={() => { setSelectedId(t.id); setCreating(false); }}
                >
                  <div className="flex items-start justify-between gap-2">
                    <div className="min-w-0">
                      <div className="font-semibold text-slate-800 truncate">{t.nombre || "(Sin nombre)"}</div>
                      <div className="text-xs text-slate-500">
                        {formatLabel(t.formato)} · {t.modalidad === 'dobles' ? 'Dobles' : 'Singles'} · {prettyEstado(t.estado)}
                      </div>
                      {(champLabel || runnerLabel) && (
                        <div className="text-xs text-emerald-700 mt-1">
                          {champLabel && <>🏆 {champLabel}</>}
                          {runnerLabel && <> · 🥈 {runnerLabel}</>}
                        </div>
                      )}
                    </div>
                    <div className="flex items-center gap-1 shrink-0">
                      <IconButton title="Duplicar" onClick={(e)=>{e.stopPropagation(); handleClone(t.id);}} icon={IconCopy} />
                      <IconButton title="Eliminar" onClick={(e)=>{e.stopPropagation(); handleDelete(t.id);}} icon={IconTrash} />
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </section>

      {/* Editor a ancho completo (una sola columna) */}
      <section>
        {!selected ? (
          <div className="border border-slate-200 rounded-2xl p-8 text-center text-slate-500">
            Seleccioná un torneo de la lista o creá uno nuevo para continuar.
          </div>
        ) : (
          <TorneoEditorPro
  key={selected.id}
  torneo={selected}
  onChange={upsert}
  alumnos={alumnos}
  perfil={perfil}
  clubActivoId={clubActivoId}
  user={user}
/>
        )}
      </section>
    </div>
  );
}



// ================== Editor PRO por pestañas ==================
function TorneoEditorPro({ torneo, onChange, alumnos, perfil, clubActivoId, user }) {
  const [tab, setTab] = React.useState(() => inferStartTab(torneo));

  // === NUEVO: lista de rankings del club para la pestaña Reglas ===
  const [rankingsList, setRankingsList] = React.useState([]);

  React.useEffect(() => {
    const uid = firebase.auth().currentUser?.uid;
    if (!uid || !clubActivoId) return;
    const q = db.collection('users').doc(String(uid))
      .collection('clubs').doc(String(clubActivoId))
      .collection('rankings').orderBy('nombre');
    const unsub = q.onSnapshot((snap) => {
      const rows = [];
      snap.forEach(d => rows.push({ id: d.id, ...d.data() }));
      setRankingsList(rows);
    });
    return () => unsub();
  }, [clubActivoId]);

  // === Modo según formato ===
  const isLiga  = isLeagueMode(torneo);                         // formato === 'grupos'
  const isElim  = torneo.formato === 'eliminacion';
  const isMixto = torneo.formato === 'grupos_y_eliminacion';

  // Auto-build del cuadro al abrir la pestaña "fase" en eliminación directa
  React.useEffect(() => {
    if (tab !== 'fase') return;
    if (isLiga) return; // en liga no hay fase final
    if (torneo.formato !== 'eliminacion') return;
    if (torneo.cuadro) return; // ya existe

    // Ids según modalidad
    const ids = (torneo.modalidad === 'dobles'
      ? (torneo.teams || []).map(t => t.id)   // parejas
      : (torneo.participantes || []).slice()  // jugadores (ids)
    ).filter(Boolean);

    const unique = Array.from(new Set(ids));
    if (unique.length < 2) return; // no alcanza para armar llaves

    const cuadro = buildBracket(unique, {
      seeding: torneo?.reglas?.ko?.seeding || 'serpentina'
    });

    onChange({ ...torneo, cuadro, lockedGrupos: true });
  }, [tab, torneo, isLiga, onChange]);

  // Redirecciones sanas si cambia el formato
  React.useEffect(() => {
    // En Liga, no tiene sentido "Fase final"
    if (isLiga && tab === 'fase') setTab('partidos');
    // En Eliminación directa, no existen "Grupos/Fixture" ni "Partidos"
    if (isElim && (tab === 'estructura' || tab === 'partidos')) setTab('fase');
  }, [isLiga, isElim, tab]);

  // === Lock de fase de grupos (PIN desde PERFIL)
  const locked = !!torneo.lockedGrupos;
  const gotoTab = (k) => setTab(k);
  const tryUnlock = () => {
    const perfilPIN = getPerfilPIN(perfil, clubActivoId);
    if (!perfilPIN) { alert("No hay PIN configurado en PERFIL."); return; }
    const pin = prompt("Ingresá el PIN de PERFIL (3 dígitos):");
    if (pin != null && String(pin).trim() === perfilPIN) {
      onChange({ ...torneo, lockedGrupos: false });
      alert("Fase de grupos desbloqueada.");
    } else {
      alert("PIN incorrecto.");
    }
  };

  // === Generar cuadro para Eliminación directa (siembra + BYEs las maneja buildBracket)
  const generarCuadroEliminacion = React.useCallback(() => {
    if (torneo.formato !== "eliminacion") {
      alert("Este torneo no es de eliminación directa.");
      return;
    }

    const ids = (torneo.modalidad === "dobles"
      ? (torneo.teams || []).map(t => t.id)     // parejas
      : (torneo.participantes || []).slice()    // jugadores
    ).filter(Boolean);

    const unique = Array.from(new Set(ids));
    if (unique.length < 2) {
      alert("Necesitás al menos 2 participantes/parejas para generar el cuadro.");
      return;
    }

    const cuadro = buildBracket(unique, {
      seeding: torneo?.reglas?.ko?.seeding || 'serpentina'
    });

    onChange({ ...torneo, cuadro, lockedGrupos: true });
    gotoTab("fase"); // ir directo a Fase final
  }, [torneo, onChange, gotoTab]);

  // === “Siguiente paso” (Mixto: de grupos a KO con PIN)
  const handleSiguientePaso = () => {
    if (torneo.formato !== "grupos_y_eliminacion") {
      alert("Este torneo no usa fase final.");
      return;
    }
    if (!groupsAllMatchesDone(torneo)) {
      const faltan = countPendingGroupMatches(torneo);
      alert(`Faltan ${faltan} partido(s) de grupos por cargar. Completalos antes de pasar a Fase final.`);
      return;
    }
    const perfilPIN = getPerfilPIN(perfil, clubActivoId);
    if (!perfilPIN) { alert("Configurá primero un PIN en PERFIL."); return; }
    const pin = prompt("Confirmá el PIN de PERFIL (3 dígitos) para cerrar grupos:");
    if (pin == null || String(pin).trim() !== perfilPIN) { alert("PIN incorrecto."); return; }

    const K = Math.max(1, parseInt(torneo.topK || 2, 10));
    const ids = computeQualifiers(torneo, K);
    const clean = Array.from(new Set((ids || []).filter(Boolean)));
    if (clean.length < 2) {
      alert(`Se necesitan al menos 2 clasificados para el cuadro. Recibidos: ${clean.length}.`);
      return;
    }

    if (torneo.cuadro && hasKOResults(torneo.cuadro)) {
      const ok = confirm("Ya hay resultados cargados en Fase final. Regenerar el cuadro los borrará. ¿Continuar?");
      if (!ok) return;
    }
    const cuadro = buildBracket(clean);
    onChange({ ...torneo, cuadro, lockedGrupos: true });
    gotoTab("fase");
  };

  // Accesos rápidos
  const patch = (p) => onChange({ ...torneo, ...p });
  const patchReglas = (r) => patch({ reglas: { ...torneo.reglas, ...r } });

  // Guardas automáticas simples: nombre/formato/modalidad
  const setNombre = (v) => patch({ nombre: v });
  const setFormato = (v) => patch({ formato: v, estado: "config" });
  const setModalidad = (v) => patch({ modalidad: v, estado: "config" });

  // Grupos / KO config
  const setGruposCount = (n) => patch({ gruposCount: n });
  const setIdaVuelta = (b) => patch({ idaVuelta: b });
  const setTopK = (n) => patch({ topK: n });

  // Participantes
  const entradas = torneo.modalidad === 'dobles' ? (torneo.teams || []) : (torneo.participantes || []);

  // Helper label alumno / entrada
  const alumnoById = React.useCallback((id) => alumnos.find(a => a.id === id) || { id, nombre: id }, [alumnos]);
  const labelAlumno = (a) => {
    if (!a) return "";
    const ap = a.apellido || "";
    const no = a.nombre || a.name || "";
    return `${ap ? ap + ", " : ""}${no || a.id}`.trim();
  };
  const labelEntrada = (e) => {
    if (torneo.modalidad !== 'dobles') {
      const id = typeof e === 'string' ? e : e?.id;
      const a = alumnoById(id);
      return labelAlumno(a);
    } else {
      let team = null;
      if (e && e.members) team = e;
      else if (typeof e === 'string') team = (torneo.teams || []).find(t => t.id === e) || null;
      if (!team) return '—';
      const [id1, id2] = team.members || [];
      return `${labelAlumno(alumnoById(id1))} / ${labelAlumno(alumnoById(id2))}`;
    }
  };

  // ====== Acciones de estructura ======
  const canGenGrupos = () =>
    torneo.formato !== 'eliminacion' && (entradas?.length || 0) >= 2 && (torneo.gruposCount || 0) >= 1;
  const canGenCuadro  = () =>
    (torneo.formato === 'eliminacion' || torneo.formato === 'grupos_y_eliminacion') && (entradas?.length || 0) >= 2;

  const generarGruposYFixture = () => {
    if (!canGenGrupos()) return;
    const ids = torneo.modalidad === 'dobles'
      ? (torneo.teams || []).map(t => t.id)
      : (torneo.participantes || []);
    const grupos = buildGroups(ids, torneo.gruposCount || 2);
    const fixture = {};
    grupos.forEach((g) => {
      const rondas = buildRoundRobin(g.entradas, !!torneo.idaVuelta);
      fixture[g.id] = rondas;
    });
    patch({ grupos, fixture, estado: 'en_juego' });
  };

  const generarCuadro = () => {
    if (!canGenCuadro()) return;
    const ids = torneo.formato === 'eliminacion'
      ? (torneo.modalidad === 'dobles' ? (torneo.teams || []).map(t => t.id) : (torneo.participantes || []))
      : tomarTopK(torneo, torneo.topK || 2);
    const cuadro = buildBracket(ids);
    patch({ cuadro, estado: 'en_juego' });
  };

  const tabs = [
    { key: 'formato',       label: 'Formato' },
    { key: 'reglas',        label: 'Reglas' },
    { key: 'participantes', label: torneo.modalidad === 'dobles' ? 'Participantes · Parejas' : 'Participantes' },
    ...(!isElim ? [{ key: 'estructura', label: 'Grupos / Fixture' }] : []),
    // 👇 Antes estaba solo isLiga. Debe ser (isLiga || isMixto) para ver los partidos de grupos.
    ...((isLiga || isMixto) ? [{ key: 'partidos', label: 'Partidos' }] : []),
    ...((isMixto || isElim) ? [{ key: 'fase', label: 'Fase final' }] : []),
  ];

  return (
    <div className="border border-slate-200 rounded-2xl">
      {/* Tabs header */}
      <div className="flex flex-wrap gap-2 p-3 border-b bg-slate-50 rounded-t-2xl">
        {tabs.map(t => (
          <button
            key={t.key}
            onClick={() => setTab(t.key)}
            className={cx(
              'px-3 py-1.5 rounded-xl text-sm',
              tab === t.key ? 'bg-white border border-slate-200 font-semibold' : 'hover:bg-white'
            )}
          >
            {t.label}
          </button>
        ))}
      </div>

      {locked && (
        <div className="mx-3 my-2 p-3 border border-amber-300 bg-amber-50 rounded-xl text-sm flex items-center justify-between">
          <div>
            <span className="font-semibold">Fase de grupos bloqueada.</span> Para editar reglas, participantes o fixture necesitás el PIN guardado en PERFIL.
          </div>
          <button className="px-3 py-1.5 rounded-lg border border-amber-300" onClick={tryUnlock}>Desbloquear</button>
        </div>
      )}

      <div className="p-4">
        {tab === 'formato' && (
          <FormatoTab
            nombre={torneo.nombre}
            setNombre={v => !locked && setNombre(v)}
            formato={torneo.formato}
            setFormato={v => !locked && setFormato(v)}
            modalidad={torneo.modalidad}
            setModalidad={v => !locked && setModalidad(v)}
            fechaInicio={torneo.fechaInicio}
            setFechaInicio={(v) => !locked && patch({ fechaInicio: v })}
            fechaFin={torneo.fechaFin}
            setFechaFin={(v) => !locked && patch({ fechaFin: v })}
            disabled={locked}
          />
        )}

        {tab === 'reglas' && (
  <>
    <ReglasTab
      reglas={torneo.reglas}
      setReglas={r => !locked && patchReglas(r)}
      modalidad={torneo.modalidad}
      disabled={locked}

      // NUEVO: props para elegir ranking
      rankings={rankingsList}
      rankingId={torneo.rankingId || ""}
      setRankingId={(v) => !locked && patch({ rankingId: v || null })}
    />

    <ResumenReglasBox
      torneo={torneo}
      disabled={locked}
      onGuardar={(texto) => !locked && patch({ reglamentoTexto: texto })}
    />
  </>
)}


        {tab === 'participantes' && (
          <ParticipantesTab
            modalidad={torneo.modalidad}
            participantes={torneo.participantes || []}
            setParticipantes={(arr) => patch({ participantes: arr })}
            teams={torneo.teams || []}
            setTeams={(arr) => patch({ teams: arr })}
            alumnos={alumnos}
            labelAlumno={labelAlumno}
            disabled={locked}
          />
        )}

        {tab === 'estructura' && (
          <EstructuraTab
            torneo={torneo}
            setGruposCount={setGruposCount}
            setIdaVuelta={setIdaVuelta}
            setTopK={setTopK}
            onGenerarGrupos={generarGruposYFixture}
            onGenerarCuadro={torneo.formato === 'eliminacion' ? generarCuadroEliminacion : undefined}
            onSiguientePaso={!isLiga ? handleSiguientePaso : undefined}
            labelEntrada={labelEntrada}
            locked={locked}
          />
        )}

        {tab === 'partidos' && (
          <PartidosTab
            torneo={torneo}
            onChange={onChange}
            labelEntrada={labelEntrada}
            perfil={perfil}
            clubActivoId={clubActivoId}
            user={user}
          />
        )}

        {tab === 'fase' && (
          <FaseFinalTab
            torneo={torneo}
            onChange={onChange}
            labelEntrada={labelEntrada}
            onGenerarCuadro={torneo.formato === 'eliminacion' ? generarCuadroEliminacion : undefined}
            clubActivoId={clubActivoId}
            user={user}
          />
        )}
      </div>
    </div>
  );
}



// ================== Tabs – Implementación ==================
function FormatoTab({
  nombre, setNombre,
  formato, setFormato,
  modalidad, setModalidad,
  fechaInicio, setFechaInicio,
  fechaFin, setFechaFin,
  disabled
}) {
  // Helpers para compatibilidad con distintos tipos de fecha
  const toInputDate = (v) => {
    if (!v) return '';
    const d = typeof v === 'number' ? new Date(v) : new Date(String(v));
    if (isNaN(d)) return '';
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  };
  // Guardamos como timestamp (ms) para máxima compatibilidad con tu código
  const fromInputDate = (s) => s ? new Date(`${s}T00:00:00`).getTime() : null;

  return (
    <div className="grid gap-4">
      {/* Fila: Nombre + Fechas */}
      <div className="grid gap-3 md:grid-cols-[1fr,180px,180px]">
        {/* Nombre */}
        <div>
          <label className="block text-sm text-slate-600 mb-1">Nombre del torneo</label>
          <input
            type="text"
            className="w-full border rounded-xl px-3 py-2"
            placeholder="Ej: Torneo Apertura"
            value={nombre || ''}
            onChange={(e) => !disabled && setNombre(e.target.value)}
            disabled={disabled}
          />
        </div>

        {/* Fecha de inicio */}
        <div>
          <label className="block text-sm text-slate-600 mb-1">Fecha de inicio</label>
          <input
            type="date"
            className="w-full border rounded-xl px-3 py-2"
            value={toInputDate(fechaInicio)}
            onChange={(e) => !disabled && setFechaInicio(fromInputDate(e.target.value))}
            disabled={disabled}
          />
        </div>

        {/* Fecha de finalización */}
        <div>
          <label className="block text-sm text-slate-600 mb-1">Fecha de finalización</label>
          <input
            type="date"
            className="w-full border rounded-xl px-3 py-2"
            value={toInputDate(fechaFin)}
            min={toInputDate(fechaInicio) || undefined}
            onChange={(e) => !disabled && setFechaFin(fromInputDate(e.target.value))}
            disabled={disabled}
          />
        </div>
      </div>

      {/* Modalidad / Formato (lo básico para que no pierdas nada) */}
      <div className="grid gap-3 sm:grid-cols-2">
        <div>
          <label className="block text-sm text-slate-600 mb-1">Modalidad</label>
          <div className="flex gap-3">
            <label className="inline-flex items-center gap-2 text-sm">
              <input
                type="radio"
                name="modalidad"
                checked={modalidad !== 'dobles'}
                onChange={() => !disabled && setModalidad('singles')}
                disabled={disabled}
              />
              Singles
            </label>
            <label className="inline-flex items-center gap-2 text-sm">
              <input
                type="radio"
                name="modalidad"
                checked={modalidad === 'dobles'}
                onChange={() => !disabled && setModalidad('dobles')}
                disabled={disabled}
              />
              Dobles
            </label>
          </div>
        </div>

        <div>
          <label className="block text-sm text-slate-600 mb-1">Formato</label>
          <select
            className="w-full border rounded-xl px-3 py-2"
            value={formato || 'grupos'}
            onChange={(e) => !disabled && setFormato(e.target.value)}
            disabled={disabled}
          >
            <option value="grupos">Sólo grupos (Liga)</option>
            <option value="eliminacion">Eliminación directa</option>
            <option value="grupos_y_eliminacion">Grupos + Eliminación</option>
          </select>
        </div>
      </div>

      {/* tip */}
      <div className="text-xs text-slate-500">
        Las fechas se usarán en el resumen de reglas y en las exportaciones (PNG/PDF).
      </div>
    </div>
  );
}


function ReglasTab({
  reglas,
  setReglas,
  modalidad,
  disabled = false,
  // === NUEVO: props para asociar el torneo a un ranking ===
  rankings = [],
  rankingId = "",
  setRankingId = () => {}
}) {
  const r = normalizeReglas(reglas);

  // si está bloqueado, ignoro cambios
  const set = React.useCallback((path, value) => {
    if (disabled) return;
    setReglas(deepSet(r, path, value)); // deepSet: tu util existente
  }, [disabled, r, setReglas]);

  return (
    <div className="grid gap-6">
      {/* Puntuación + Sets */}
      <div className="grid md:grid-cols-2 gap-4">
        <div className="border rounded-xl p-3">
          <div className="font-semibold text-slate-800 mb-2">Puntuación</div>
          <div className="flex items-center gap-3">
            <NumberField
              label="Win"
              value={r?.grupos?.puntos?.win ?? 3}
              onChange={v => set(['grupos','puntos','win'], v)}
              disabled={disabled}
            />
            <NumberField
              label="Loss"
              value={r?.grupos?.puntos?.loss ?? 0}
              onChange={v => set(['grupos','puntos','loss'], v)}
              disabled={disabled}
            />
            {/* Si querés empates más adelante:
            <NumberField
              label="Draw"
              value={r?.grupos?.puntos?.draw ?? 1}
              onChange={v => set(['grupos','puntos','draw'], v)}
              disabled={disabled}
            />
            */}
          </div>
        </div>

        <div className="border rounded-xl p-3">
          <div className="font-semibold text-slate-800 mb-2">Sets / Tie-break</div>
          <div className="grid gap-2 md:grid-cols-2">
            <SelectField
              label="Formato sets"
              value={r?.sets?.formato ?? 'bo3'}
              onChange={v => set(['sets','formato'], v)}
              options={[
                { value:'bo1',        label:'Al mejor de 1 set' },
                { value:'bo3',        label:'Al mejor de 3 sets' },
                { value:'match_tb10', label:'Match tie-break a 10' },
              ]}
              disabled={disabled}
            />
            <SelectField
              label="Tie-break"
              value={r?.sets?.tb ?? 'tb7'}
              onChange={v => set(['sets','tb'], v)}
              options={[
                { value:'tb7',   label:'TB a 7' },
                { value:'tb10',  label:'TB a 10' },
                { value:'none',  label:'Sin TB' },
              ]}
              disabled={disabled}
            />
          </div>
          <div className="text-xs text-slate-500 mt-2">
            Si elegís “Match tie-break a 10”, el tercer set se define con un TB a 10 (ej: 10-7).
          </div>
        </div>
      </div>

      {/* === NUEVO: Ranking asociado === */}
      <div className="border rounded-xl p-3">
        <div className="font-semibold text-slate-800 mb-2">Ranking asociado</div>
        <div className="grid md:grid-cols-2 gap-3">
          <div>
            <label className="block text-sm text-slate-600 mb-1">Actualizar resultados en</label>
            <select
              className="w-full border rounded-xl px-3 py-2"
              value={rankingId}
              onChange={e => setRankingId(e.target.value)}
              disabled={disabled}
            >
              <option value="">— No actualizar ranking —</option>
              {(rankings || []).map(rk => (
                <option key={rk.id} value={rk.id}>
                  {rk.nombre || rk.id}
                </option>
              ))}
            </select>
            <p className="text-xs text-slate-500 mt-1">
              Si elegís un ranking, cada resultado del fixture sumará puntos a ese ranking
              usando los valores de <b>Puntuación</b>.
            </p>
          </div>
        </div>
      </div>

      {/* Reglas KO */}
      <div className="border rounded-xl p-3">
        <div className="font-semibold text-slate-800 mb-2">Reglas de eliminación</div>
        <div className="grid gap-2 md:grid-cols-3">
          <SelectField
            label="Orden de siembra"
            value={r?.ko?.seeding ?? 'serpentina'}
            onChange={v => set(['ko','seeding'], v)}
            options={[
              { value:'serpentina', label:'Serpentina' },
              { value:'aleatorio',  label:'Aleatorio' },
            ]}
            disabled={disabled}
          />
          <SelectField
            label="Sets KO"
            value={r?.ko?.sets ?? 'bo3'}
            onChange={v => set(['ko','sets'], v)}
            options={[
              { value:'bo1',        label:'Bo1' },
              { value:'bo3',        label:'Bo3' },
              { value:'match_tb10', label:'Match TB10' },
            ]}
            disabled={disabled}
          />
          <SelectField
            label="TB KO"
            value={r?.ko?.tb ?? 'tb7'}
            onChange={v => set(['ko','tb'], v)}
            options={[
              { value:'tb7',  label:'TB7' },
              { value:'tb10', label:'TB10' },
              { value:'none', label:'Sin TB' },
            ]}
            disabled={disabled}
          />
        </div>
      </div>

      <InfoTip>
        La modalidad actual es <b>{modalidad === 'dobles' ? 'Dobles' : 'Singles'}</b>. En Dobles, armá las parejas
        manualmente en la pestaña Participantes.
      </InfoTip>
    </div>
  );
}



function ParticipantesTab({ modalidad, participantes, setParticipantes, teams, setTeams, alumnos, labelAlumno }) {
  const [busca, setBusca] = React.useState('');
  const pool = React.useMemo(() => alumnos
    .filter(a => (a.nombre||'').toLowerCase().includes(busca.toLowerCase()) || (a.apellido||'').toLowerCase().includes(busca.toLowerCase()))
    .sort((a,b)=> (a.apellido||'').localeCompare(b.apellido||'')), [alumnos, busca]);

  // Para dobles: creador de parejas
  const [sel1, setSel1] = React.useState('');
  const [sel2, setSel2] = React.useState('');

  const agregarParticipante = (id) => {
    if (participantes.includes(id)) return;
    setParticipantes([...participantes, id]);
  };
  const quitarParticipante = (id) => setParticipantes(participantes.filter(x => x !== id));

  const agregarPareja = () => {
    if (!sel1 || !sel2 || sel1 === sel2) return;
    // evitar repetir jugador ya usado
    const usados = new Set(teams.flatMap(t => t.members));
    if (usados.has(sel1) || usados.has(sel2)) { alert('Uno de los jugadores ya está en una pareja.'); return; }
    const nueva = { id: genId('team_'), members: [sel1, sel2] };
    setTeams([...(teams||[]), nueva]);
    setSel1(''); setSel2('');
  };
  const quitarPareja = (id) => setTeams((teams||[]).filter(t => t.id !== id));

  return (
    <div className="grid gap-6">
      {modalidad === 'singles' && (
        <div className="grid md:grid-cols-2 gap-4">
          <div className="border rounded-xl p-3">
            <div className="font-semibold mb-2">Alumnos</div>
            <input className="w-full border rounded-xl px-3 py-2 mb-2" value={busca} onChange={e=>setBusca(e.target.value)} placeholder="Buscar por nombre o apellido"/>
            <div className="max-h-64 overflow-auto divide-y">
              {pool.map(a => (
                <div key={a.id} className="py-2 flex items-center justify-between">
                  <div className="text-sm">{labelAlumno(a)}</div>
                  <button className="text-xs px-2 py-1 rounded-lg bg-slate-800 text-white" onClick={()=>agregarParticipante(a.id)}>Agregar</button>
                </div>
              ))}
            </div>
          </div>

          <div className="border rounded-xl p-3">
            <div className="font-semibold mb-2">Seleccionados ({participantes.length})</div>
            {participantes.length === 0 && <div className="text-sm text-slate-500">Aún no hay jugadores.</div>}
            <div className="flex flex-wrap gap-2">
              {participantes.map(id => (
                <span key={id} className="text-xs bg-slate-100 rounded-xl px-2 py-1 flex items-center gap-1">
                  {labelAlumno(alumnos.find(a=>a.id===id))}
                  <button className="ml-1" onClick={()=>quitarParticipante(id)} title="Quitar">✕</button>
                </span>
              ))}
            </div>
          </div>
        </div>
      )}

      {modalidad === 'dobles' && (
        <div className="grid gap-4">
          <div className="border rounded-xl p-3">
            <div className="font-semibold mb-2">Crear parejas</div>
            <div className="grid md:grid-cols-3 gap-2 items-end">
              <SelectAlumno value={sel1} onChange={setSel1} alumnos={alumnos} placeholder="Jugador A" />
              <SelectAlumno value={sel2} onChange={setSel2} alumnos={alumnos} placeholder="Jugador B" />
              <button className="px-3 py-2 rounded-xl bg-slate-800 text-white" onClick={agregarPareja}>Agregar pareja</button>
            </div>
            <div className="text-xs text-slate-500 mt-2">Cada jugador puede pertenecer a una única pareja.</div>
          </div>

          <div className="border rounded-xl p-3">
            <div className="font-semibold mb-2">Parejas ({(teams||[]).length})</div>
            {(teams||[]).length === 0 && <div className="text-sm text-slate-500">Aún no hay parejas.</div>}
            <div className="space-y-2">
              {(teams||[]).map(t => (
                <div key={t.id} className="flex items-center justify-between border rounded-xl px-3 py-2">
                  <div className="text-sm">{renderTeamLabel(t, alumnos)}</div>
                  <button className="text-xs px-2 py-1 rounded-lg bg-slate-800 text-white" onClick={()=>quitarPareja(t.id)}>Quitar</button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      <InfoTip>
        Recordá: el orden visible se usa como orden de entrada para generar fixture/cuadro. Podés reordenar más adelante si lo necesitás.
      </InfoTip>
    </div>
  );
}

// === Layout de llaves (SVG + cajas absolutas) ===
function computeBracketLayout(cuadro, colW = 240, rowGap = 90, boxW = 210, boxH = 54) {
  // rounds ordenados 1..N
  const rnums = Object.keys(cuadro || {}).map(n => Number(n)).sort((a,b)=>a-b);
  const rmap = Object.fromEntries(rnums.map((n, i) => [String(n), i]));
  const first = (cuadro && cuadro[String(rnums[0])]) || [];
  const firstLen = first.length || 1;

  // altura total aproximada
  const totalH = Math.max(1, firstLen) * rowGap;

  const boxes = [];   // {match, roundIdx, x, y, w, h}
  const centers = {}; // map[match.id] = {x,y}

  rnums.forEach((rnum, rIndex) => {
    const matches = cuadro[String(rnum)] || [];
    const ySpacing = rowGap * (2 ** rIndex);
    matches.forEach((m, j) => {
      const x = 16 + rIndex * colW;
      const y = ySpacing * (j + 0.5);
      boxes.push({ match: m, roundIdx: rIndex, x, y, w: boxW, h: boxH });
      centers[m.id] = { x: x + boxW, y }; // punto de salida (lado derecho de la caja)
    });
  });

  // edges (conectores)
  const edges = [];
  rnums.forEach((rnum) => {
    const matches = cuadro[String(rnum)] || [];
    matches.forEach((m) => {
      const n = m?.next;
      if (!n) return;
      const from = centers[m.id];
      const destRoundIdx = rmap[String(n.round)];
      const dest = (cuadro[String(n.round)] || [])[n.slot];
      if (!dest) return;
      const destBox = boxes.find(b => b.match.id === dest.id);
      if (!destBox) return;
      const destPoint = { x: destBox.x, y: destBox.y }; // entra por la izquierda

      // Polyline en forma de ├───┐
      edges.push({
        d: `M ${from.x} ${from.y} 
            L ${destPoint.x - 14} ${from.y} 
            L ${destPoint.x - 14} ${destPoint.y} 
            L ${destPoint.x} ${destPoint.y}`
      });
    });
  });

  const width = 16 + rnums.length * colW + 16;
  const height = totalH + 40;

  return { width, height, boxes, edges };
}

// Render del bracket como SVG (líneas) + cajas absolutas (partidos)
function BracketViewSVG({ cuadro, labelEntrada, resumenMarcador, onMatchClick, containerId, layout }) {
  if (!cuadro) return null;
  const { width, height, boxes, edges } = computeBracketLayout(cuadro);

  const sideLabel = (side) => {
    // side puede ser id, objeto con id, o BYE
    if (!side || side?.BYE) return "—";
    return labelEntrada(side);
  };

  return (
    <div id={containerId || undefined} className="relative overflow-auto border rounded-xl" style={{ minHeight: 120 }}>
      {/* Conectores */}
      <svg width={width} height={height} style={{ display: 'block' }}>
        <defs>
          <marker id="dot" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="6" markerHeight="6">
            <circle cx="4" cy="4" r="3" />
          </marker>
        </defs>
        {edges.map((e, i) => (
          <path key={i} d={e.d} fill="none" stroke="#CBD5E1" strokeWidth="2" />
        ))}
      </svg>

      {/* Cajas */}
      <div className="absolute inset-0">
        {boxes.map(({ match: m, x, y, w, h }) => (
          <div
            key={m.id}
            className="bg-white border border-slate-200 rounded-xl shadow-sm hover:shadow cursor-pointer"
            style={{
              position: 'absolute',
              left: x,
              top: y - h/2,
              width: w,
              height: h,
              padding: '8px 10px',
              boxSizing: 'border-box'
            }}
            onClick={() => onMatchClick && onMatchClick(m)}
            title="Cargar/editar resultado"
          >
            <div className="text-xs font-medium truncate">{sideLabel(m.a)} <span className="text-slate-400">vs</span> {sideLabel(m.b)}</div>
            <div className="text-[11px] text-slate-500 mt-1">
              {m.done ? (resumenMarcador ? resumenMarcador(m) : "Finalizado") : "Sin resultado"}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// --- Helper: tabla de posiciones para un grupo (Liga) ---
function computeTablaGrupo(torneo, gid) {
  // Config de puntos (grupos)
  const cfg = (torneo?.reglas?.grupos?.puntos) || { win: 3, draw: 1, loss: 0 };

  // Helpers locales
  const normId = (e) => {
    if (!e) return null;
    if (typeof e === 'string') return e;
    if (e.BYE) return null;             // tratamos BYE como "no entrada"
    return e.id ?? e.alumnoId ?? null;
  };
  const parseSet = (s) => {
    if (!s) return [0, 0];
    if (Array.isArray(s)) return [Number(s[0])||0, Number(s[1])||0];
    if (typeof s === 'string') {
      const m = s.match(/(\d+)\s*[-x:]\s*(\d+)/i);
      return m ? [Number(m[1])||0, Number(m[2])||0] : [0,0];
    }
    const a = s.a ?? s.A ?? s[0];
    const b = s.b ?? s.B ?? s[1];
    return [Number(a)||0, Number(b)||0];
  };

  // Entradas del grupo
  const grupo = (torneo?.grupos || []).find(g => g.id === gid) || { entradas: [] };
  const entradas = (grupo.entradas || []).map(normId).filter(Boolean);

  // Fila base
  const mkRow = (id) => ({
    alumnoId: id,
    PJ: 0, G: 0, E: 0, P: 0,
    GF: 0, GC: 0,          // games a favor / en contra
    SF: 0, SC: 0,          // sets a favor / en contra (opcional)
    PTS: 0,
  });

  // Mapa { id -> fila }
  const rows = new Map();
  entradas.forEach(id => { if (id) rows.set(id, mkRow(id)); });

  // Flatten del fixture del grupo (puede venir por rondas o plano)
  const fx = torneo?.fixture?.[gid] || [];
  const list = Array.isArray(fx[0]) ? fx.flat() : fx;

  for (const m of list) {
    const aId = normId(m.a);
    const bId = normId(m.b);
    if (!aId || !bId) continue; // salteamos BYE o entradas inválidas

    if (!rows.has(aId)) rows.set(aId, mkRow(aId));
    if (!rows.has(bId)) rows.set(bId, mkRow(bId));
    const A = rows.get(aId);
    const B = rows.get(bId);

    const res = m?.result || {};
    const wo = res.wo || m.wo || m.woWinner || null;
    const isDraw = !!(res.draw || res.empate);
    const winnerSide =
      res.winner ||
      (wo === 'a' ? 'a' : wo === 'b' ? 'b' : null);

    const played = isDraw || winnerSide === 'a' || winnerSide === 'b' || !!res.done || !!m.done;
    if (!played) continue;

    // PJ
    A.PJ++; B.PJ++;

    // Sumar GF/GC y SF/SC si hay sets cargados
    const sets = res.sets || [];
    if (Array.isArray(sets) && sets.length) {
      let sa = 0, sb = 0; // sets ganados por cada lado
      for (const s of sets) {
        const [ga, gb] = parseSet(s);
        A.GF += ga; A.GC += gb;
        B.GF += gb; B.GC += ga;
        if (ga > gb) sa++; else if (gb > ga) sb++;
      }
      A.SF += sa; A.SC += sb;
      B.SF += sb; B.SC += sa;
    }

    // Puntos de tabla
    if (isDraw) {
      A.E++; B.E++;
      A.PTS += cfg.draw; B.PTS += cfg.draw;
    } else if (winnerSide === 'a') {
      A.G++; B.P++;
      A.PTS += cfg.win;  B.PTS += cfg.loss;
    } else if (winnerSide === 'b') {
      B.G++; A.P++;
      B.PTS += cfg.win;  A.PTS += cfg.loss;
    }
  }

  // Orden: PTS desc, (GF-GC) desc, GF desc, G desc
  const arr = Array.from(rows.values());
  arr.sort((x, y) => {
    if (y.PTS !== x.PTS) return y.PTS - x.PTS;
    const dx = (x.GF - x.GC), dy = (y.GF - y.GC);
    if (dy !== dx) return dy - dx;
    if (y.GF !== x.GF) return y.GF - x.GF;
    if (y.G !== x.G)   return y.G   - x.G;
    return String(x.alumnoId).localeCompare(String(y.alumnoId));
  });

  return arr;
}



function TablaGrupo({ torneo, gid, labelEntrada }) {
  const rows = React.useMemo(() => computeTablaGrupo(torneo, gid), [torneo, gid]);

  if (!rows.length) {
    return <div className="text-sm text-slate-500">Aún sin posiciones.</div>;
  }

  // Resuelve un nombre “bonito” aunque el id sea team_*
  const resolveName = (id) => {
    try {
      const ent = findEntry(id, torneo);
      // 1) Intento principal
      let s = typeof labelEntrada === "function"
        ? labelEntrada(ent, torneo)
        : (ent?.label || id);

      // 2) Si quedó como team_* o vacío, intento armarlo con miembros del team
      if (!s || /^team_/i.test(String(s))) {
        const team = (torneo.teams || []).find(t => t.id === (ent?.id || id));
        if (team?.members?.length) {
          const names = team.members.map(mid => {
            const me = findEntry(mid, torneo);
            return (typeof labelEntrada === "function"
              ? labelEntrada(me, torneo)
              : (me?.label || String(mid)));
          }).filter(Boolean);
          if (names.length) s = names.join(" / ");
        }
      }
      return String(s);
    } catch {
      return String(id);
    }
  };

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full text-sm">
        <thead className="sticky top-0 bg-white">
          <tr className="text-left text-slate-600">
            <th className="p-2">#</th>
            <th className="p-2">Jugador</th>
            <th className="p-2">PJ</th>
            <th className="p-2">G</th>
            <th className="p-2">E</th>
            <th className="p-2">P</th>
            <th className="p-2">GF</th>
            <th className="p-2">GC</th>
            <th className="p-2">PTS</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r, i) => (
            <tr key={r.id || i} className={i % 2 ? "bg-slate-50" : "bg-white"}>
              <td className="p-2">{i + 1}</td>
              <td className="p-2">{resolveName(r.alumnoId || r.id)}</td>
              <td className="p-2">{r.PJ}</td>
              <td className="p-2">{r.G}</td>
              <td className="p-2">{r.E}</td>
              <td className="p-2">{r.P}</td>
              <td className="p-2">{r.GF}</td>
              <td className="p-2">{r.GC}</td>
              <td className="p-2 font-semibold">{r.PTS}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


function EstructuraTab({
  torneo,
  setGruposCount,
  setIdaVuelta,
  setTopK,
  onGenerarGrupos,
  onGenerarCuadro,
  onSiguientePaso,
  onIrFaseFinal,
  labelEntrada,   // << se usa para nombres
  locked
}) {
  // Fallback de etiqueta por si no llega labelEntrada
  const labelFallback = React.useCallback((entry) => {
    try {
      if (!entry) return "—";
      // singles: entry es id
      if (torneo.modalidad !== "dobles") {
        const a = (window.alumnos || []).find(x => x.id === (entry.id || entry)) || {};
        return `${a.apellido ? a.apellido + ", " : ""}${a.nombre || a.name || a.id || "—"}`.trim();
      }
      // dobles: entry es {id} o id; busco team
      const teamId = typeof entry === "string" ? entry : entry.id;
      const team = (torneo.teams || []).find(tt => tt.id === teamId) || entry;
      if (!team || !team.members) return String(teamId || "—");
      const [id1, id2] = team.members;
      const fmt = (id) => {
        const a = (window.alumnos || []).find(x => x.id === id) || {};
        return `${a.apellido ? a.apellido + ", " : ""}${a.nombre || a.name || a.id || ""}`.trim();
      };
      const la = fmt(id1), lb = fmt(id2);
      return (la && lb) ? `${la} / ${lb}` : (la || lb || "—");
    } catch {
      return "—";
    }
  }, [torneo]);

  const _labelEntrada = React.useCallback(
    (e) => (typeof labelEntrada === "function" ? labelEntrada(e) : labelFallback(e)),
    [labelEntrada, labelFallback]
  );

  const entradasCount =
    torneo.modalidad === "dobles"
      ? (torneo.teams || []).length
      : (torneo.participantes || []).length;

  const tieneGrupos = torneo.formato !== "eliminacion";
  const tieneKO = torneo.formato !== "grupos";

  const canG =
    tieneGrupos &&
    !locked &&
    entradasCount >= 2 &&
    (torneo.gruposCount || 0) >= 1;

  const pending = countPendingGroupMatches(torneo);
  const groupsDone = groupsAllMatchesDone(torneo);
  const canNext =
    tieneKO &&
    torneo.formato === "grupos_y_eliminacion" &&
    groupsDone;

    const fixtureListo = !!torneo.fixture && Object.keys(torneo.fixture || {}).length > 0;

  return (
    <div className="grid gap-6">
      {tieneGrupos && (
        <div className="border rounded-xl p-3 grid md:grid-cols-3 gap-3 items-end">
          <NumberField
            label="# de grupos"
            value={torneo.gruposCount || 2}
            onChange={(v) => setGruposCount(v)}
            min={1}
            disabled={locked}
          />
          <ToggleField
            label="Ida y vuelta"
            checked={!!torneo.idaVuelta}
            onChange={setIdaVuelta}
            disabled={locked}
          />
          <button
            className={`px-3 py-2 rounded-xl ${canG ? "bg-[#34745B] text-white" : "border"}`}
            onClick={() => { if (canG) onGenerarGrupos && onGenerarGrupos(); }}
            disabled={!canG}
            title={locked ? "Bloqueado por PIN" : ""}
          >
            Generar grupos y fixture
          </button>
          <div className="md:col-span-3 text-xs text-slate-500">
            Entradas: {entradasCount} {locked && "· (Bloqueado)"}
          </div>
        </div>
      )}

      {tieneKO && torneo.formato === "grupos_y_eliminacion" && (
        <div className="border rounded-xl p-3 grid md:grid-cols-3 gap-3 items-end">
          <NumberField
            label="Top-K desde grupos"
            value={torneo.topK || 2}
            onChange={v => setTopK(v)}
            min={1}
            disabled={locked}
          />
          <div className="md:col-span-2" />
          <button
            className={`px-3 py-2 rounded-xl ${canNext ? "bg-[#34745B] text-white" : "border"}`}
            onClick={() => { if (canNext) onSiguientePaso && onSiguientePaso(); }}
            disabled={!canNext}
            title={!canNext ? "Generá grupos y cargá TODOS los resultados primero" : ""}
          >
            Siguiente paso a Fase final (PIN de PERFIL)
          </button>

          <div className="md:col-span-3 text-xs text-slate-500">
            {groupsDone ? "Todos los partidos de grupos están cargados." : `Faltan ${pending} partido(s) de grupos por cargar.`}
          </div>
        </div>
      )}

      {torneo.formato === "eliminacion" && (
        <div className="border rounded-xl p-3 grid md:grid-cols-3 gap-3 items-end">
          {!torneo.cuadro ? (
            <>
              <div className="md:col-span-2 text-sm text-slate-600">
                Generá el cuadro de eliminación directa con las parejas/participantes cargados.
              </div>
              <button
                className={`px-3 py-2 rounded-xl ${!locked &&
                  ((torneo.modalidad === "dobles" ? (torneo.teams || []).length : (torneo.participantes || []).length) >= 2)
                  ? "bg-[#34745B] text-white" : "border"}`}
                onClick={() => onGenerarCuadro && onGenerarCuadro()}
                disabled={locked}
                title={locked ? "Bloqueado por PIN" : ""}
              >
                Generar cuadro de eliminación
              </button>
            </>
          ) : (
            <>
              <div className="md:col-span-2 text-sm text-slate-600">
                Los resultados de eliminación directa se cargan en la pestaña <b>Fase final</b>.
              </div>
              <button className="px-3 py-2 rounded-xl border" onClick={() => onIrFaseFinal && onIrFaseFinal()}>
                Ir a Fase final
              </button>
            </>
          )}
        </div>
      )}

      {fixtureListo && (
  <div className="border rounded-xl p-3">
    <div className="font-semibold mb-2">Vista previa de grupos</div>
    <div className="grid md:grid-cols-2 gap-4">
      {torneo.grupos.map((g) => (
        <div key={g.id} className="border rounded-xl p-2">
          <div className="font-medium">{g.nombre}</div>
          <ul className="list-disc pl-5 text-sm text-slate-700">
            {(g.entradas || []).map((e) => (
              <li key={typeof e === "string" ? e : (e?.id || Math.random())}>
                {labelEntrada(findEntry(e, torneo))}
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  </div>
)}


      {!!torneo.cuadro && (
        <div className="border rounded-xl p-3">
          <div className="font-semibold mb-2">Vista previa de cuadro</div>
          <BracketViewSVG
  cuadro={torneo.cuadro}
  labelEntrada={(id)=>labelEntrada(findEntry(id, torneo))}
  resumenMarcador={resumenMarcador /* o safeResumen si usás ese */}
  onMatchClick={(m) => setEdit(edit === (m?.id ?? m) ? null : (m?.id ?? m))}
  layout={{ colW: 300, rowGap: 130, boxW: 360, boxH: 68 }}  // <- si lo usabas
/>
        </div>
      )}
    </div>
  );
}

function ProgramacionEditor({ initial = {}, onSave, onCancel }) {
  const [fecha, setFecha]   = React.useState(initial.fecha  || "");
  const [hora, setHora]     = React.useState(initial.hora   || "");
  const [cancha, setCancha] = React.useState(initial.cancha || "");
  const [sede, setSede]     = React.useState(initial.sede   || initial.club || "");

  const save = () => onSave({
    fecha:  fecha  || null,
    hora:   hora   || null,
    cancha: cancha || null,
    sede:   sede   || null,
  });

  return (
    <div className="grid grid-cols-1 sm:grid-cols-6 gap-2 text-xs mt-2">
      <input
        type="date"
        className="border rounded-lg px-2 py-1 sm:col-span-2"
        value={fecha}
        onChange={e => setFecha(e.target.value)}
      />
      <input
        type="time"
        className="border rounded-lg px-2 py-1 sm:col-span-1"
        value={hora}
        onChange={e => setHora(e.target.value)}
      />
      <input
        type="text"
        placeholder="Cancha"
        className="border rounded-lg px-2 py-1 sm:col-span-1"
        value={cancha}
        onChange={e => setCancha(e.target.value)}
      />
      <input
        type="text"
        placeholder="Club"
        className="border rounded-lg px-2 py-1 sm:col-span-2"
        value={sede}
        onChange={e => setSede(e.target.value)}
      />

      <div className="flex gap-2 sm:col-span-6">
        <button className="px-2 py-1 rounded-lg border" onClick={onCancel}>Cancelar</button>
        <button className="px-2 py-1 rounded-lg bg-[#34745B] text-white" onClick={save}>Guardar</button>
      </div>
    </div>
  );
}


function PartidosTab({ torneo, onChange, labelEntrada, perfil, clubActivoId }) {
  // === Estado editor / programación ===
  const [edit, setEdit] = React.useState(null);         // { gid, mid }
  const [progEdit, setProgEdit] = React.useState(null); // { gid, mid }

  // Helpers
  const sideLabel = (id) => {
    try { return labelEntrada(findEntry(id, torneo)); }
    catch { return String(id || '—'); }
  };

  const isPlayed = (m) =>
    !!m && (m.done || m?.result?.done || m?.result?.wo || m?.wo || m?.woWinner || m?.winner != null || m?.result?.winner != null);

  const safeResumen = (m) => {
    if (!m) return "Sin resultado";
    const wo = m?.result?.wo || m?.wo || m?.woWinner || null;
    if (wo === 'a' || wo === 'b') {
      const ganador = wo === 'a' ? sideLabel(m.a) : sideLabel(m.b);
      return `WO ${ganador}`;
    }
    return typeof resumenMarcador === 'function' ? resumenMarcador(m) : (isPlayed(m) ? 'OK' : 'Sin resultado');
  };

  // === Mutaciones: guardar resultado de GRUPOS ===
  const guardarResultadoGrupo = async (gid, mid, result) => {
    const t = deepClone(torneo);
    const orig = t.fixture?.[gid];
    if (!orig) return;

    const matchOriginal = getMatch(gid, mid);
    if (!matchOriginal) return;

    // Derivar flags/resultados
    const esWO = result?.wo === 'a' || result?.wo === 'b';
    const esEmpate = !!(result?.draw || result?.empate || result?.winner === 'draw');
    const winnerSide =
      esWO ? result.wo :
      (result?.winner === 'a' || result?.winner === 'b') ? result.winner :
      null;

    const winnerId = winnerSide ? (winnerSide === 'a' ? matchOriginal.a : matchOriginal.b) : null;
    const loserId  = winnerSide ? (winnerSide === 'a' ? matchOriginal.b : matchOriginal.a) : null;

    // Parchar el partido
    const patchedMatch = {
      ...matchOriginal,
      result,
      done: !!result?.done || esWO || !!winnerSide || esEmpate,
      winner: winnerSide ?? (esEmpate ? null : matchOriginal.winner)
    };

    const patchFn = (mm) => (mm.id === mid ? patchedMatch : mm);
    const mapIn = (arr) => Array.isArray(arr[0]) ? arr.map(r => r.map(patchFn)) : arr.map(patchFn);
    t.fixture[gid] = mapIn(orig);

    // --- Acreditar puntos en Ranking asociado (si hay uno elegido en Reglas) ---
    const rankingId = torneo?.rankingId || null;
    if (rankingId) {
      // Si tenés helper centralizado:
      if (typeof applyMatchResultToRanking === 'function') {
        await applyMatchResultToRanking({
          clubId: clubActivoId,
          torneo,
          winnerId,
          loserId,
          draw: esEmpate,
          wo:   esWO
        });
      } else if (typeof updateRankingPuntosEn === 'function') {
        // Fallback inline usando reglas básicas de grupos
        const reglas = torneo?.reglas?.grupos?.puntos || {};
        const ptsWin  = Number(reglas.win  ?? 3);
        const ptsLoss = Number(reglas.loss ?? 0);
        const ptsDraw = Number(reglas.draw ?? 1);

        if (esEmpate && matchOriginal?.a && matchOriginal?.b) {
          await Promise.all([
            updateRankingPuntosEn(clubActivoId, rankingId, matchOriginal.a, ptsDraw, { pj: 1, pe: 1 }),
            updateRankingPuntosEn(clubActivoId, rankingId, matchOriginal.b, ptsDraw, { pj: 1, pe: 1 }),
          ]);
        } else if (winnerId && loserId) {
          await Promise.all([
            updateRankingPuntosEn(clubActivoId, rankingId, winnerId, ptsWin,  { pj: 1, pg: 1, wo: esWO ? 1 : 0 }),
            updateRankingPuntosEn(clubActivoId, rankingId, loserId,  ptsLoss, { pj: 1, pp: 1 }),
          ]);
        }
      }
    }

    // Finalizar edición
    onChange(t);
    setEdit(null);
  };

  // === Mutaciones: guardar programación (opcional) ===
  const guardarProgramacionGrupo = (gid, mid, prog) => {
    const t = deepClone(torneo);
    const orig = t.fixture?.[gid];
    if (!orig) return;

    const patch = (mm) => (mm.id === mid
      ? { ...mm, programacion: prog, fecha: prog.fecha, hora: prog.hora, cancha: prog.cancha, sede: prog.sede }
      : mm);

    const mapIn = (arr) => Array.isArray(arr[0]) ? arr.map(r => r.map(patch)) : arr.map(patch);

    t.fixture[gid] = mapIn(orig);
    onChange(t);
    setProgEdit(null);
  };

  // AUTOFIX: si hay grupos pero todavía no hay fixture, generarlo
  React.useEffect(() => {
    const grupos = torneo.grupos || [];
    const tieneGrupos = grupos.length > 0;
    const tieneFixture = !!torneo.fixture && Object.keys(torneo.fixture).length > 0;
    if (!tieneGrupos || tieneFixture) return;

    const fixture = {};
    grupos.forEach(g => {
      const entradas = (g.entradas || [])
        .map(x => (typeof x === 'object' ? x.id : x))
        .filter(Boolean);

      fixture[g.id] = buildRoundRobin(entradas, !!torneo.idaVuelta);
    });

    onChange({ ...torneo, fixture });
  }, [torneo.grupos, torneo.idaVuelta, onChange]);

  // === Buscar match actual para el drawer ===
  const getMatch = (gid, mid) => {
    const f = torneo.fixture?.[gid];
    if (!f) return null;
    const list = Array.isArray(f[0]) ? f.flat() : f;
    return list.find(m => m.id === mid) || null;
  };

  // === Render listado de partidos por grupo (solo grupos / liga) ===
  const gruposKeys = Object.keys(torneo.fixture || {});
  const hayGrupos = gruposKeys.length > 0;

  return (
    <div className="grid lg:grid-cols-[1fr,0px] gap-4">
      <div className="space-y-4">
        {!hayGrupos && (
          <div className="text-sm text-slate-500">No hay fixture generado.</div>
        )}

        {/* Tablas de posiciones — Liga */}
        {torneo.formato === 'grupos' && Array.isArray(torneo.grupos) && torneo.grupos.length > 0 && (
          <div className="border rounded-2xl p-3">
            <div className="font-semibold mb-2">Tablas de posiciones — Liga</div>
            <div className="grid md:grid-cols-2 gap-4">
              {torneo.grupos.map((g) => (
                <div key={g.id} className="border rounded-xl p-2 bg-white">
                  <div className="font-medium mb-2">{g.nombre}</div>
                  <TablaGrupo torneo={torneo} gid={g.id} labelEntrada={labelEntrada} />
                </div>
              ))}
            </div>
          </div>
        )}

        {gruposKeys.map((gid) => {
          const rounds = torneo.fixture[gid] || [];
          const lista = Array.isArray(rounds[0]) ? rounds.flat() : rounds;

          return (
            <div key={gid} className="border rounded-xl p-3">
              <div className="font-semibold mb-2">
                {torneo.grupos?.find(g => g.id === gid)?.nombre || `Grupo ${gid}`}
              </div>

              {lista.length === 0 && (
                <div className="text-sm text-slate-500">Sin partidos.</div>
              )}

              <div className="space-y-2">
                {lista.map(m => {
                  const editable = !isBYE(m.a) && !isBYE(m.b);
                  return (
                    <div key={m.id} className="p-2 border rounded-lg bg-white flex items-center justify-between">
                      <div className="text-sm">
                        <b>{sideLabel(m.a)}</b> vs <b>{sideLabel(m.b)}</b>
                        <span className="ml-2 text-xs text-slate-600">{safeResumen(m)}</span>
                        <div className="text-xs text-slate-500 mt-0.5">
                          🗓️ {(() => {
                            const p = m.programacion || {};
                            const fecha  = p.fecha  ?? m.fecha  ?? null;
                            const hora   = p.hora   ?? m.hora   ?? null;
                            const cancha = p.cancha ?? m.cancha ?? null;
                            const sede   = p.sede   ?? m.sede   ?? m.club ?? null;
                            const fmtF = (iso) => iso ? iso.split('-').reverse().join('/') : null;
                            const partes = [];
                            if (fecha || hora) partes.push(`${fecha ? fmtF(fecha) : ''}${fecha && hora ? ' ' : ''}${hora ? `${hora} hs` : ''}`.trim());
                            if (cancha) partes.push(`Cancha: ${cancha}`);
                            if (sede)   partes.push(`Club: ${sede}`);
                            return partes.join(' · ') || 'Sin programación';
                          })()}
                          {' '}
                          <button className="underline hover:no-underline"
                                  onClick={() => setProgEdit({ gid, mid: m.id })}>
                            {m.programacion ? 'editar' : 'programar'}
                          </button>
                        </div>
                      </div>

                      <div className="flex items-center gap-2">
                        {/* WO rápidos */}
                        <button
                          type="button"
                          className="px-2 py-1 rounded-lg text-xs border border-slate-300 disabled:opacity-50"
                          onClick={() => editable && guardarResultadoGrupo(gid, m.id, { wo: 'a', done: true })}
                          disabled={!editable}
                          title={`WO para ${sideLabel(m.a)}`}
                        >
                          WO {sideLabel(m.a)}
                        </button>
                        <button
                          type="button"
                          className="px-2 py-1 rounded-lg text-xs border border-slate-300 disabled:opacity-50"
                          onClick={() => editable && guardarResultadoGrupo(gid, m.id, { wo: 'b', done: true })}
                          disabled={!editable}
                          title={`WO para ${sideLabel(m.b)}`}
                        >
                          WO {sideLabel(m.b)}
                        </button>

                        <button
                          className="px-2 py-1 rounded-lg text-xs bg-slate-800 text-white disabled:opacity-50"
                          onClick={() => editable && setEdit({ gid, mid: m.id })}
                          disabled={!editable}
                        >
                          {isPlayed(m) ? 'Editar' : 'Cargar'}
                        </button>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>

      {/* === DRAWER: ResultadoEditor (grupos) === */}
      {edit && (() => {
        const mm = getMatch(edit.gid, edit.mid);
        if (!mm) return null;
        return (
          <div className="fixed inset-0 z-50">
            <div className="absolute inset-0 bg-black/30" onClick={() => setEdit(null)} />
            <div className="absolute right-0 top-0 h-full w-full max-w-md bg-white shadow-xl p-4 overflow-y-auto">
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold text-slate-700 text-sm">
                  {sideLabel(mm.a)} <span className="text-slate-400">vs</span> {sideLabel(mm.b)}
                </div>
                <button className="text-xs px-2 py-1 rounded border" onClick={() => setEdit(null)}>Cerrar</button>
              </div>

              <ResultadoEditor
                reglas={torneo.reglas}
                initial={mm.result}
                onSave={(res) => guardarResultadoGrupo(edit.gid, edit.mid, res)}
                onCancel={() => setEdit(null)}
                aLabel={sideLabel(mm.a)}
                bLabel={sideLabel(mm.b)}
              />
            </div>
          </div>
        );
      })()}

      {/* === DRAWER: Programación (grupos) === */}
      {progEdit && (() => {
        const mm = getMatch(progEdit.gid, progEdit.mid);
        if (!mm) return null;
        const pInit = mm.programacion || { fecha: mm.fecha, hora: mm.hora, cancha: mm.cancha, sede: mm.sede || mm.club };
        return (
          <div className="fixed inset-0 z-40">
            <div className="absolute inset-0 bg-black/30" onClick={() => setProgEdit(null)} />
            <div className="absolute right-0 top-0 h-full w-full max-w-md bg-white shadow-xl p-4 overflow-y-auto">
              <div className="flex items-center justify-between mb-2">
                <div className="font-semibold text-slate-700 text-sm">
                  Programar: {sideLabel(mm.a)} <span className="text-slate-400">vs</span> {sideLabel(mm.b)}
                </div>
                <button className="text-xs px-2 py-1 rounded border" onClick={() => setProgEdit(null)}>Cerrar</button>
              </div>

              <ProgramacionEditor
                initial={pInit}
                onSave={(prog) => guardarProgramacionGrupo(progEdit.gid, progEdit.mid, prog)}
                onCancel={() => setProgEdit(null)}
              />
            </div>
          </div>
        );
      })()}
    </div>
  );
}


// === Info de la final (campeón / subcampeón) ===
function bracketFinalInfo(cuadro){
  if (!cuadro) return null;
  const rounds = Object.keys(cuadro).map(n => Number(n)).sort((a,b)=>a-b);
  if (!rounds.length) return null;
  const last = String(rounds[rounds.length-1]);
  const finalMatch = (cuadro[last] || [])[0];
  if (!finalMatch) return { done:false, round:last, match:null };

  if (!finalMatch.done || !finalMatch.result || !finalMatch.result.winner) {
    return { done:false, round:last, match:finalMatch };
  }
  const champion = finalMatch.result.winner === 'a' ? finalMatch.a : finalMatch.b;
  const runnerUp = finalMatch.result.winner === 'a' ? finalMatch.b : finalMatch.a;
  return { done:true, round:last, match:finalMatch, champion, runnerUp };
}


function FaseFinalTab({ torneo, onChange, labelEntrada, onGenerarCuadro, clubActivoId, user }) {
  const [edit, setEdit] = React.useState(null);         // editor de resultado (abre drawer)
  const [progEdit, setProgEdit] = React.useState(null); // editor de programación
  const [showBracket, setShowBracket] = React.useState(true);

  const koHasResults = React.useMemo(() => hasKOResults(torneo.cuadro), [torneo.cuadro]);
  const finalInfo = React.useMemo(() => bracketFinalInfo(torneo.cuadro), [torneo.cuadro]);

  // Exportación A4 (tus funciones existentes)
  const exportPNG = React.useCallback(
    () => exportPNG_A4(torneo, showBracket, setShowBracket),
    [torneo, showBracket]
  );
  const exportPDF = React.useCallback(
    () => exportPDF_A4(torneo, showBracket, setShowBracket),
    [torneo, showBracket]
  );

  // ✅ PDF completo (tablas + cuadro)
  const exportarPDFCompleto = async () => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4');
    const docW = doc.internal.pageSize.getWidth();
    const docH = doc.internal.pageSize.getHeight();
    let yPos = 40;

    // Portada
    doc.setFontSize(22);
    doc.text(torneo.nombre || 'Torneo', docW / 2, yPos, { align: 'center' });
    yPos += 20;
    doc.setFontSize(12);
    doc.text(
      (torneo.modalidad === 'dobles' ? 'Modalidad: Dobles' : 'Modalidad: Singles') +
        ` | Formato: ${torneo.formato === 'eliminacion' ? 'Eliminación Directa' : 'Grupos + Eliminación'}`,
      docW / 2, yPos, { align: 'center' }
    );
    yPos += 20;

    // Tablas de posiciones (si hay grupos)
    if (torneo.formato !== 'eliminacion' && torneo.grupos?.length) {
      yPos += 20;
      doc.setFontSize(16);
      doc.text('Tablas de Posiciones', 40, yPos);
      yPos += 15;

      for (const grupo of torneo.grupos) {
        const tablaData = computeTablaGrupo(torneo, grupo.id);
        const tableBody = tablaData.map((row, i) => [
          i + 1,
          labelEntrada(row.alumnoId, torneo),
          row.PJ, row.G, row.E, row.P, row.GF, row.GC, row.PTS,
        ]);

        doc.setFontSize(12);
        doc.text(grupo.nombre, 40, yPos);
        doc.autoTable({
          startY: yPos + 5,
          head: [['#', 'Jugador', 'PJ', 'G', 'E', 'P', 'GF', 'GC', 'PTS']],
          body: tableBody,
          theme: 'grid',
          styles: { fontSize: 10, cellPadding: 3 },
          headStyles: { fillColor: [63, 63, 65], textColor: 255 },
          margin: { left: 40, right: 40 },
        });
        yPos = doc.autoTable.previous.finalY + 20;
      }
    }

    // Partidos de grupos (si hay)
    if (torneo.formato !== 'eliminacion' && torneo.fixture && Object.keys(torneo.fixture).length) {
      if (yPos > docH - 100) { doc.addPage(); yPos = 40; }
      yPos += 20;
      doc.setFontSize(16);
      doc.text('Partidos de Grupos', 40, yPos);
      yPos += 15;

      const partidosBody = Object.entries(torneo.fixture).flatMap(([grupoId, rondas]) =>
        (Array.isArray(rondas[0]) ? rondas.flat() : rondas).map(match => [
          torneo.grupos?.find(g => g.id === grupoId)?.nombre || '—',
          labelEntrada(match.a, torneo),
          labelEntrada(match.b, torneo),
          match.result?.sets?.map(s => `${s.a}-${s.b}`).join(', ') || '—',
          match.result?.winner === 'a' ? labelEntrada(match.a, torneo)
            : match.result?.winner === 'b' ? labelEntrada(match.b, torneo) : 'Empate'
        ])
      );
      doc.autoTable({
        startY: yPos + 5,
        head: [['Grupo', 'Jugador A', 'Jugador B', 'Resultado', 'Ganador']],
        body: partidosBody,
        theme: 'grid',
        styles: { fontSize: 10, cellPadding: 3 },
        headStyles: { fillColor: [63, 63, 65], textColor: 255 },
        margin: { left: 40, right: 40 },
      });
      yPos = doc.autoTable.previous.finalY + 20;
    }

    // Cuadro de eliminación
    if (torneo.cuadro) {
      if (yPos > docH - 100) { doc.addPage(); yPos = 40; }
      doc.addPage();
      yPos = 40;
      doc.setFontSize(16);
      doc.text('Cuadro de Eliminación', docW / 2, yPos, { align: 'center' });
      yPos += 20;

      const el = document.getElementById('a4-export-root');
      if (el) {
        setShowBracket(true);
        await new Promise(r => setTimeout(r, 60));
        const canvas = await html2canvas(el, { scale: 2, useCORS: true });
        const imgData = canvas.toDataURL('image/png');
        const imgWidth = doc.internal.pageSize.getWidth();
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        doc.addImage(imgData, 'PNG', 0, yPos, imgWidth, imgHeight);
        setShowBracket(false);
      } else {
        doc.setFontSize(12);
        doc.text('No se pudo generar el cuadro de eliminación.', docW / 2, yPos + 20, { align: 'center' });
      }
    }

    doc.save(`Reporte_Torneo_${(torneo.nombre || '').replace(/\s/g, '_')}.pdf`);
  };

  // Regenerar cuadro (según formato)
  const regenerarDesdeTabla = () => {
    if (koHasResults && !window.confirm("Ya hay resultados en KO. Regenerar borrará esos resultados. ¿Continuar?")) return;

    let ids = [];
    if (torneo.formato === "eliminacion") {
      ids = torneo.modalidad === "dobles"
        ? (torneo.teams || []).map(t => t.id)
        : (torneo.participantes || []);
    } else {
      const faltan = countPendingGroupMatches(torneo);
      if (faltan > 0) {
        window.alert(`Faltan ${faltan} partido(s) de grupos. Cargá esos resultados antes de armar la fase final.`);
        return;
      }
      const K = Math.max(1, parseInt(torneo.topK || 2, 10));
      ids = computeQualifiers(torneo, K);
    }

    const clean = Array.from(new Set((ids || []).filter(Boolean)));
    if (clean.length < 2) {
      window.alert("Se necesitan al menos 2 participantes o clasificados.");
      return;
    }

    const cuadro = buildBracket(clean, { seeding: torneo?.reglas?.ko?.seeding || 'serpentina' });
    onChange({ ...torneo, cuadro });
  };

  if (!torneo.cuadro) {
    const isElim = torneo.formato === 'eliminacion';
    return (
      <div className="p-4 border rounded-xl">
        <div className="text-slate-700 mb-2">Aún no se generó el cuadro.</div>

        {isElim ? (
          <button
            className="px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white text-sm"
            onClick={regenerarDesdeTabla}
          >
            Generar cuadro de eliminación
          </button>
        ) : (
          <div className="text-xs text-slate-500">
            Para “Grupos + Eliminación”, primero completá los grupos y luego usá “Regenerar desde tabla”.
          </div>
        )}
      </div>
    );
  }

  // ===== Helpers =====
  const sideLabel = (side) => (!side || side?.BYE) ? "—" : labelEntrada(findEntry(side, torneo));
  const isPlayed = (m) =>
    !!m && (m.done || m?.result?.done || m?.result?.wo || m?.wo || m?.woWinner || m?.winner != null || m?.result?.winner != null);

  const safeResumen = (m) => {
    if (!m) return "Sin resultado";
    const wo = m?.result?.wo || m?.wo || m?.woWinner || null;
    if (wo === 'a' || wo === 'b') {
      const ganador = wo === 'a' ? sideLabel(m.a) : sideLabel(m.b);
      return `WO ${ganador}`;
    }
    if (typeof resumenMarcador === 'function') return resumenMarcador(m);
    return isPlayed(m) ? 'OK' : 'Sin resultado';
  };

  // Buscar partido KO por id
  const matchById = React.useCallback((id) => {
    for (const arr of Object.values(torneo.cuadro || {})) {
      const found = (arr || []).find(mm => mm.id === id);
      if (found) return found;
    }
    return null;
  }, [torneo.cuadro]);

  // Guardar RESULTADO KO (con ranking asociado)
  const guardar = async (matchId, result) => {
    const matchOriginal = matchById(matchId);
    if (!matchOriginal) return;

    // Derivar flags
    const esWO = result?.wo === 'a' || result?.wo === 'b';
    const esEmpate = !!(result?.draw || result?.empate || result?.winner === 'draw');
    const winnerSide =
      esWO ? result.wo :
      (result?.winner === 'a' || result?.winner === 'b') ? result.winner :
      null;

    const winnerId = winnerSide ? (winnerSide === 'a' ? matchOriginal.a : matchOriginal.b) : null;
    const loserId  = winnerSide ? (winnerSide === 'a' ? matchOriginal.b : matchOriginal.a) : null;

    // Aplicar resultado al cuadro
    const nuevo = applyResultToBracket(deepClone(torneo), matchId, result);

    // === Ranking asociado (si hay uno elegido en Reglas) ===
    const rankingId = torneo?.rankingId || null;
    if (rankingId) {
      if (typeof applyMatchResultToRanking === 'function') {
        // Helper centralizado (recomendado)
        await applyMatchResultToRanking({
          clubId: clubActivoId,
          torneo,
          winnerId,
          loserId,
          draw: esEmpate,
          wo:   esWO
        });
      } else if (typeof updateRankingPuntosEn === 'function') {
        // Fallback: usar reglas básicas de grupos (win/loss/draw)
        const reglas = torneo?.reglas?.grupos?.puntos || {};
        const ptsWin  = Number(reglas.win  ?? 3);
        const ptsLoss = Number(reglas.loss ?? 0);
        const ptsDraw = Number(reglas.draw ?? 1);

        if (esEmpate && matchOriginal?.a && matchOriginal?.b) {
          await Promise.all([
            updateRankingPuntosEn(clubActivoId, rankingId, matchOriginal.a, ptsDraw, { pj: 1, pe: 1 }),
            updateRankingPuntosEn(clubActivoId, rankingId, matchOriginal.b, ptsDraw, { pj: 1, pe: 1 }),
          ]);
        } else if (winnerId && loserId) {
          await Promise.all([
            updateRankingPuntosEn(clubActivoId, rankingId, winnerId, ptsWin,  { pj: 1, pg: 1, wo: esWO ? 1 : 0 }),
            updateRankingPuntosEn(clubActivoId, rankingId, loserId,  ptsLoss, { pj: 1, pp: 1 }),
          ]);
        }
      }
    }

    // Finalizar
    onChange(nuevo);
    setEdit(null);

    const info = bracketFinalInfo(nuevo.cuadro);
    if (info?.done) {
      const champ = labelEntrada(findEntry(info.champion, nuevo));
      const sub = labelEntrada(findEntry(info.runnerUp, nuevo));
      window.alert(`¡Fin del torneo!\n🏆 Campeón: ${champ}\n🥈 Subcampeón: ${sub}`);
    }
  };

  // Programación KO
  const formatDate = (iso) => {
    if (!iso) return null;
    const [y, m, d] = iso.split("-").map(Number);
    if (!y || !m || !d) return iso;
    return `${String(d).padStart(2, "0")}/${String(m).padStart(2, "0")}/${y}`;
  };
  const fmtProg = (m) => {
    const p = m?.programacion || {};
    const fecha = p.fecha ?? m.fecha ?? null;
    const hora = p.hora ?? m.hora ?? null;
    const cancha = p.cancha ?? m.cancha ?? null;
    const sede = p.sede ?? m.sede ?? m.club ?? null;

    const partes = [];
    if (fecha || hora) {
      const fh = `${fecha ? formatDate(fecha) : ""}${fecha && hora ? " " : ""}${hora ? `${hora} hs` : ""}`.trim();
      if (fh) partes.push(fh);
    }
    if (cancha) partes.push(`Cancha: ${cancha}`);
    if (sede) partes.push(`Club: ${sede}`);
    return partes.join(" · ");
  };

  const guardarProgramacion = (matchId, prog) => {
    const t = deepClone(torneo);
    Object.keys(t.cuadro || {}).forEach(k => {
      t.cuadro[k] = (t.cuadro[k] || []).map(mm =>
        mm.id === matchId
          ? { ...mm, programacion: prog, fecha: prog.fecha, hora: prog.hora, cancha: prog.cancha, sede: prog.sede }
          : mm
      );
    });
    onChange(t);
    setProgEdit(null);
  };

  const ProgramacionEditor = ({ initial = {}, onSave, onCancel }) => {
    const [fecha, setFecha] = React.useState(initial.fecha || "");
    const [hora, setHora] = React.useState(initial.hora || "");
    const [cancha, setCancha] = React.useState(initial.cancha || "");
    const [sede, setSede] = React.useState(initial.sede || initial.club || "");

    const save = () =>
      onSave({
        fecha: fecha || null,
        hora: hora || null,
        cancha: cancha || null,
        sede: sede || null,
      });

    return (
      <div className="grid grid-cols-1 sm:grid-cols-12 gap-2 text-xs mt-2 items-center">
        <input type="date" className="sm:col-span-3 border rounded-lg px-2 h-9" value={fecha} onChange={(e) => setFecha(e.target.value)} />
        <input type="time" className="sm:col-span-3 border rounded-lg px-2 h-9" value={hora} onChange={(e) => setHora(e.target.value)} />
        <input type="text" placeholder="Cancha" className="sm:col-span-3 border rounded-lg px-2 h-9" value={cancha} onChange={(e) => setCancha(e.target.value)} />
        <input type="text" placeholder="Club" className="sm:col-span-3 border rounded-lg px-2 h-9" value={sede} onChange={(e) => setSede(e.target.value)} />
        <div className="sm:col-span-12 flex justify-end gap-2 mt-1">
          <button className="px-3 py-2 rounded-lg border" onClick={onCancel}>Cancelar</button>
          <button className="px-3 py-2 rounded-lg bg-[#34745B] text-white" onClick={save}>Guardar</button>
        </div>
      </div>
    );
  };

  const nombreRondaPorPartidos = (n) => {
    const map = { 1: "Final", 2: "Semifinales", 4: "Cuartos de final", 8: "Octavos de final", 16: "Dieciseisavos", 32: "Treintaidosavos" };
    return map[n] || `Ronda (${n} partido${n !== 1 ? "s" : ""})`;
  };

  const esDobles = torneo.modalidad === 'dobles';
  const parejas = (torneo.teams || []).length;
  const jugadores = esDobles ? parejas * 2 : (torneo.participantes || []).length;
  const formatoLabel =
    torneo.formato === "grupos" ? "Sólo grupos (Liga)" :
    torneo.formato === "eliminacion" ? "Eliminación directa" :
    torneo.formato === "grupos_y_eliminacion" ? "Grupos + Eliminación" : (torneo.formato || "—");
  const creado = new Date(torneo.createdAt || torneo.fechaCreacion || Date.now()).toLocaleDateString();

  return (
    <div className="grid gap-4">
      {/* Toolbar */}
      <div className="flex items-center justify-between gap-2">
        <div className="text-lg font-semibold">Fase final</div>
        <div className="flex gap-2">
          <button className="px-3 py-1.5 rounded-lg border" onClick={() => setShowBracket(s => !s)}>
            {showBracket ? "Ver lista" : "Ver llaves"}
          </button>
          <button className="px-3 py-1.5 rounded-lg border" onClick={regenerarDesdeTabla}>Regenerar desde tabla</button>
          <button className="px-3 py-1.5 rounded-lg bg-[#34745B] text-white" onClick={exportarPDFCompleto} title="Exportar a PDF">PDF</button>
        </div>
      </div>

      {/* Campeón/Subcampeón */}
      {finalInfo?.done && (
        <div className="p-3 rounded-xl bg-emerald-50 border border-emerald-300">
          <div className="font-semibold">🏆 Campeón: {labelEntrada(findEntry(finalInfo.champion, torneo))}</div>
          <div className="text-sm">🥈 Subcampeón: {labelEntrada(findEntry(finalInfo.runnerUp, torneo))}</div>
        </div>
      )}

      {/* Tablas de posiciones (si hay grupos) */}
      {torneo.formato !== 'eliminacion' && Array.isArray(torneo.grupos) && torneo.grupos.length > 0 && (
        <div className="border rounded-2xl p-3">
          <div className="font-semibold mb-2">Tablas de posiciones — Grupos</div>
          <div className="grid md:grid-cols-2 gap-4">
            {torneo.grupos.map((g) => (
              <div key={g.id} className="border rounded-xl p-2 bg-white">
                <div className="font-medium mb-2">{g.nombre}</div>
                <TablaGrupo torneo={torneo} gid={g.id} labelEntrada={labelEntrada} />
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Contenedor A4 off-screen */}
      <div
        id="a4-export-root"
        style={{ position:'absolute', left:-99999, top:0, width:'1123px', minHeight:'794px', background:'#fff', padding:'16px', border:'1px solid #e2e8f0', borderRadius:'12px' }}
        aria-hidden="true"
      >
        <div className="flex items-center gap-3 mb-2">
          <img src="logo_favicon.png" alt="Coachex-Pro" width="28" height="28" />
          <div className="text-xl font-bold">Coachex-Pro</div>
        </div>
        <div className="text-base font-semibold">{torneo.nombre || "(Sin nombre)"}</div>
        <div className="text-xs text-slate-500">
          {formatoLabel} · {esDobles ? `${parejas} parejas (${jugadores} jugadores)` : `${jugadores} jugadores`} · Creado: {creado}
          {torneo.formato === "grupos_y_eliminacion" ? ` · Top-K: ${parseInt(torneo.topK || 2, 10)}` : ""}
          {torneo.formato !== "eliminacion" ? ` · Ida y vuelta: ${torneo.idaVuelta ? "Sí" : "No"}` : ""}
        </div>

        {showBracket ? (
          <BracketViewSVG
            cuadro={torneo.cuadro}
            labelEntrada={(id)=>labelEntrada(findEntry(id, torneo))}
            resumenMarcador={safeResumen}
            onMatchClick={(m)=>setEdit(edit===m.id?null:m.id)}
            containerId="bracket-canvas"
            layout={{ colW: 360, rowGap: 150, boxW: 400, boxH: 76 }}
          />
        ) : null}
      </div>

      {/* Vista principal: llaves / lista */}
      <div className="grid lg:grid-cols-[1fr,320px] gap-4">
        <div className="border rounded-2xl p-3">
          {showBracket ? (
            <BracketViewSVG
              cuadro={torneo.cuadro}
              labelEntrada={(id) => labelEntrada(findEntry(id, torneo))}
              resumenMarcador={safeResumen}
              onMatchClick={(m) =>
                setEdit((prev) => prev === (m?.id ?? m) ? null : (m?.id ?? m))
              }
              layout={{ colW: 300, rowGap: 130, boxW: 360, boxH: 68 }}
            />
          ) : (
            Object.entries(torneo.cuadro || {})
              .sort((a, b) => (b[1]?.length || 0) - (a[1]?.length || 0))
              .map(([rk, matches]) => {
                const rondaName = nombreRondaPorPartidos((matches || []).length);
                return (
                  <div key={rk} className="border rounded-xl p-3 mb-3">
                    <div className="font-semibold">{rondaName}</div>

                    <div className="space-y-2 mt-2">
                      {(matches || []).map((m) => {
                        const byeA = !!(m?.a && m.a.BYE), byeB = !!(m?.b && m.b.BYE);
                        const editable = !byeA && !byeB;
                        const pInit = m.programacion || { fecha: m.fecha, hora: m.hora, cancha: m.cancha, sede: m.sede || m.club };

                        return (
                          <div key={m.id} className="border rounded-xl p-2">
                            <div className="flex flex-wrap items-center justify-between gap-2 min-h-[56px]">
                              <div className="min-w-0">
                                <div className="text-sm font-medium leading-5 truncate max-w-[680px]">
                                  {sideLabel(m.a)} {" vs "} {sideLabel(m.b)}
                                </div>
                                <div className="text-xs text-slate-500 mt-0.5">
                                  🗓️ {fmtProg(m) || "Sin programación"}
                                  <button
                                    className="ml-2 underline hover:no-underline"
                                    onClick={() => setProgEdit(progEdit === m.id ? null : m.id)}
                                  >
                                    {progEdit === m.id ? "cerrar" : "programar"}
                                  </button>
                                </div>
                              </div>

                              <div className="flex items-center gap-2 shrink-0">
                                <span className="text-xs text-slate-500">{safeResumen(m)}</span>

                                <button
                                  type="button"
                                  className="h-7 px-2 rounded-lg text-xs border border-slate-300 disabled:opacity-50"
                                  onClick={() => { if (!editable) return; if (window.confirm(`Confirmar WO: gana ${sideLabel(m.a)}.`)) guardar(m.id, { wo: 'a', done: true }); }}
                                  disabled={!editable}
                                  title={`WO para ${sideLabel(m.a)}`}
                                >
                                  WO {sideLabel(m.a)}
                                </button>
                                <button
                                  type="button"
                                  className="h-7 px-2 rounded-lg text-xs border border-slate-300 disabled:opacity-50"
                                  onClick={() => { if (!editable) return; if (window.confirm(`Confirmar WO: gana ${sideLabel(m.b)}.`)) guardar(m.id, { wo: 'b', done: true }); }}
                                  disabled={!editable}
                                  title={`WO para ${sideLabel(m.b)}`}
                                >
                                  WO {sideLabel(m.b)}
                                </button>

                                <button
                                  className={`h-7 px-3 rounded-lg text-xs disabled:opacity-50 ${isPlayed(m) ? 'bg-emerald-600 text-white hover:bg-emerald-700' : 'bg-slate-800 text-white hover:bg-slate-900'}`}
                                  onClick={() => editable && setEdit(edit === m.id ? null : m.id)}
                                  disabled={!editable}
                                >
                                  {edit === m.id ? "Cerrar" : (isPlayed(m) ? "Editar" : "Cargar")}
                                </button>
                              </div>
                            </div>

                            {progEdit === m.id && (
                              <ProgramacionEditor
                                initial={pInit}
                                onCancel={() => setProgEdit(null)}
                                onSave={(prog) => guardarProgramacion(m.id, prog)}
                              />
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })
          )}
        </div>

        <aside className="lg:sticky lg:top-2 self-start border rounded-2xl p-3 bg-slate-50">
          <div className="font-semibold text-slate-800 mb-2">Resumen</div>
          <div className="text-sm text-slate-600 space-y-1">
            {(() => {
              const niveles = Object.values(torneo.cuadro || {});
              const all = niveles.flat();
              const partidos = all.length || 0;
              const jugados = all.filter(isPlayed).length || 0;
              const pendientes = Math.max(0, partidos - jugados);
              return (
                <>
                  <div><span className="text-slate-500">Partidos:</span> {partidos}</div>
                  <div><span className="text-slate-500">Jugados:</span> {jugados}</div>
                  <div><span className="text-slate-500">Pendientes:</span> {pendientes}</div>
                </>
              );
            })()}
          </div>

          {!!finalInfo?.done && <div className="h-px bg-slate-200 my-3" />}
          {finalInfo?.done && (
            <>
              <div className="text-sm"><span className="text-slate-500">🏆 Campeón:</span> <b>{labelEntrada(findEntry(finalInfo.champion, torneo))}</b></div>
              <div className="text-sm mt-1"><span className="text-slate-500">🥈 Subcampeón:</span> <b>{labelEntrada(findEntry(finalInfo.runnerUp, torneo))}</b></div>
            </>
          )}

          <div className="h-px bg-slate-200 my-3" />
          <div className="text-xs text-slate-500">Tip: podés exportar PDF apaisado desde los botones de arriba.</div>
        </aside>
      </div>

      {/* Drawer con editor de resultados */}
      <RightDrawer open={!!(edit ? matchById(edit) : null)} title={(edit && matchById(edit)) ? `${sideLabel(matchById(edit).a)} vs ${sideLabel(matchById(edit).b)}` : ""} onClose={() => setEdit(null)}>
        {edit && (() => {
          const mm = matchById(edit);
          if (!mm) return null;
          return (
            <ResultadoEditor
              reglas={torneo.reglas}
              initial={mm.result}
              onSave={(res) => { guardar(mm.id, res); }}
              onCancel={() => setEdit(null)}
              aLabel={sideLabel(mm.a)}
              bLabel={sideLabel(mm.b)}
            />
          );
        })()}
      </RightDrawer>
    </div>
  );
}


// === Panel lateral derecha (drawer) ===
function RightDrawer({ open, title, onClose, children }) {
  return (
    <div className={cx(
      "fixed inset-0 z-[100]",
      open ? "pointer-events-auto" : "pointer-events-none"
    )}>
      {/* Fondo */}
      <div
        onClick={onClose}
        className={cx(
          "absolute inset-0 bg-black/30 transition-opacity",
          open ? "opacity-100" : "opacity-0"
        )}
      />
      {/* Panel */}
      <div
        className={cx(
          "absolute right-0 top-0 h-full w-full max-w-[520px] bg-white shadow-2xl",
          "transition-transform", open ? "translate-x-0" : "translate-x-full"
        )}
      >
        <div className="p-3 border-b flex items-center justify-between">
          <div className="font-semibold">{title}</div>
          <button onClick={onClose} className="px-2 py-1 rounded-lg border">Cerrar</button>
        </div>
        <div className="p-3 h-[calc(100%-48px)] overflow-y-auto">
          {children}
        </div>
      </div>
    </div>
  );
}


// ================== Componentes UI pequeños ==================
function RadioItem({ checked, onChange, title, desc }) {
  return (
    <label className={cx('flex gap-3 items-start p-2 rounded-xl border cursor-pointer', checked ? 'border-slate-400 bg-white' : 'border-slate-200 hover:bg-slate-50')}>
      <input type="radio" className="mt-1" checked={!!checked} onChange={onChange} />
      <div>
        <div className="font-medium text-slate-800">{title}</div>
        {desc && <div className="text-xs text-slate-500">{desc}</div>}
      </div>
    </label>
  );
}
function NumberField({ label, value, onChange, min=0 }) {
  return (
    <label className="block">
      <div className="text-sm text-slate-600 mb-1">{label}</div>
      <input type="number" min={min} className="w-full border rounded-xl px-3 py-2" value={value ?? 0} onChange={e=>onChange(parseInt(e.target.value||0))} />
    </label>
  );
}
function SelectField({ label, value, onChange, options }) {
  return (
    <label className="block">
      <div className="text-sm text-slate-600 mb-1">{label}</div>
      <select className="w-full border rounded-xl px-3 py-2" value={value} onChange={e=>onChange(e.target.value)}>
        {options.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
      </select>
    </label>
  );
}
function ToggleField({ label, checked, onChange }) {
  return (
    <label className="flex items-center gap-2 text-sm">
      <input type="checkbox" checked={!!checked} onChange={e=>onChange(e.target.checked)} /> {label}
    </label>
  );
}
function SelectAlumno({ value, onChange, alumnos, placeholder }) {
  return (
    <select className="w-full border rounded-xl px-3 py-2" value={value} onChange={e=>onChange(e.target.value)}>
      <option value="">{placeholder}</option>
      {alumnos.sort((a,b)=> (a.apellido||'').localeCompare(b.apellido||'')).map(a => (
        <option key={a.id} value={a.id}>{(a.apellido? a.apellido + ', ' : '') + (a.nombre||a.name||'')}</option>
      ))}
    </select>
  );
}

// === Editor de resultado: 3 sets con A y B por set
function ResultadoEditor({ reglas, initial, onSave, onCancel, aLabel = "A", bLabel = "B" }) {
  // Modo: sets (3) vs WO
  const [mode, setMode] = React.useState(initial?.wo ? "wo" : "sets");

  // Sets: array de 3 objetos {a:"", b:""} en UI (strings para inputs)
  const initSets = (() => {
    const s = Array.isArray(initial?.sets) ? initial.sets : [];
    const toStr = (x) => (Number.isFinite(Number(x)) ? String(Number(x)) : "");
    return [
      { a: toStr(s[0]?.a), b: toStr(s[0]?.b) },
      { a: toStr(s[1]?.a), b: toStr(s[1]?.b) },
      { a: toStr(s[2]?.a), b: toStr(s[2]?.b) },
    ];
  })();
  const [sets, setSets] = React.useState(initSets);

  // WO winner
  const [woWinner, setWoWinner] = React.useState(initial?.wo || null);

  const setSetVal = (i, side, val) => {
    setSets(prev => {
      const next = prev.map(x => ({ ...x }));
      // Sólo números >= 0 o vacío
      const clean = val === "" ? "" : Math.max(0, Number(val));
      next[i][side] = (val === "" || Number.isFinite(clean)) ? String(val).replace(/^0+(\d)$/, "$1") : prev[i][side];
      return next;
    });
  };

  // Calcula ganador por sets ganados
  const computeWinnerFromSets = (arr) => {
    let winA = 0, winB = 0;
    arr.forEach(s => {
      const a = Number(s.a), b = Number(s.b);
      if (Number.isFinite(a) && Number.isFinite(b)) {
        if (a > b) winA++;
        else if (b > a) winB++;
      }
    });
    if (winA > winB) return 'a';
    if (winB > winA) return 'b';
    return 'draw';
  };

  const save = () => {
    if (mode === "wo") {
      if (woWinner !== "a" && woWinner !== "b") {
        alert("Elegí quién gana por WO.");
        return;
      }
      onSave({ wo: woWinner, done: true });
      return;
    }

    // Validar que haya al menos 1 set con ambos lados cargados
    const filled = sets.filter(s => s.a !== "" && s.b !== "");
    if (filled.length === 0) {
      alert("Cargá al menos un set con ambos lados.");
      return;
    }

    // Normalizar a números (vacíos -> 0)
    const norm = sets.map(s => ({
      a: Number.isFinite(Number(s.a)) ? Number(s.a) : 0,
      b: Number.isFinite(Number(s.b)) ? Number(s.b) : 0,
    }));

    const winner = computeWinnerFromSets(norm);
    onSave({ sets: norm, winner, done: true });
  };

  const limpiar = () => {
    setSets([{a:"",b:""}, {a:"",b:""}, {a:"",b:""}]);
    setWoWinner(null);
    setMode("sets");
  };

  return (
    <div className="border rounded-xl p-3 space-y-3 bg-white">
      {/* Modo */}
      <div className="flex gap-4 text-sm">
        <label className="flex items-center gap-2 cursor-pointer">
          <input
            type="radio"
            name="modo-res"
            checked={mode === "sets"}
            onChange={() => setMode("sets")}
          />
          <span>Resultado por sets (3)</span>
        </label>
        <label className="flex items-center gap-2 cursor-pointer">
          <input
            type="radio"
            name="modo-res"
            checked={mode === "wo"}
            onChange={() => setMode("wo")}
          />
          <span>WO (no presentación)</span>
        </label>
      </div>

      {mode === "wo" ? (
        // ---- UI WO ----
        <div className="space-y-2">
          <div className="text-sm text-slate-600">Marcá quién gana por WO.</div>
          <div className="flex gap-2">
            <button
              type="button"
              className={`px-3 py-1 rounded-lg border ${woWinner === "a" ? "bg-emerald-600 text-white border-emerald-600" : "border-slate-300"}`}
              onClick={() => setWoWinner("a")}
              title={`Gana ${aLabel} por WO`}
            >
              Gana {aLabel} por WO
            </button>
            <button
              type="button"
              className={`px-3 py-1 rounded-lg border ${woWinner === "b" ? "bg-emerald-600 text-white border-emerald-600" : "border-slate-300"}`}
              onClick={() => setWoWinner("b")}
              title={`Gana ${bLabel} por WO`}
            >
              Gana {bLabel} por WO
            </button>
          </div>
          <p className="text-xs text-slate-500">
            Los <b>puntos</b> por WO se toman de <code>reglas.grupos.wo</code> (si configuraste gf/gc, se usan como “puntos”).
          </p>
        </div>
      ) : (
        // ---- UI SETS (3) ----
        <div className="space-y-3">
          {[0,1,2].map(i => (
            <div key={i} className="grid grid-cols-2 gap-3">
              <div>
                <label
                  className="block text-xs text-slate-500 mb-1 whitespace-nowrap truncate max-w-[280px]"
                  title={aLabel}
                >
                  {`Set ${i+1} · ${aLabel}`}
                </label>
                <input
                  type="number"
                  min="0"
                  inputMode="numeric"
                  className="w-full border rounded-lg px-3 py-2"
                  value={sets[i].a}
                  onChange={(e) => setSetVal(i, "a", e.target.value)}
                  placeholder="0"
                />
              </div>
              <div>
                <label
                  className="block text-xs text-slate-500 mb-1 whitespace-nowrap truncate max-w-[280px]"
                  title={bLabel}
                >
                  {`Set ${i+1} · ${bLabel}`}
                </label>
                <input
                  type="number"
                  min="0"
                  inputMode="numeric"
                  className="w-full border rounded-lg px-3 py-2"
                  value={sets[i].b}
                  onChange={(e) => setSetVal(i, "b", e.target.value)}
                  placeholder="0"
                />
              </div>
            </div>
          ))}
          <p className="text-xs text-slate-500">
            Ingresá los <b>puntos</b> de cada set (mejor de 3). El ganador se calcula por cantidad de sets ganados.
          </p>
        </div>
      )}

      <div className="flex items-center justify-end gap-2 pt-2">
        <button className="px-3 py-2 rounded-lg border border-slate-300" onClick={limpiar}>
          Limpiar
        </button>
        <button className="px-3 py-2 rounded-lg border border-slate-300" onClick={onCancel}>
          Cancelar
        </button>
        <button className="px-3 py-2 rounded-lg bg-[#34745B] text-white" onClick={save}>
          Guardar
        </button>
      </div>
    </div>
  );
}




function SetRow({ label, va, vb, setVa, setVb, placeholderA='', placeholderB='' }) {
  return (
    <div>
      <div className="text-sm text-slate-600 mb-1">{label}</div>
      <div className="flex items-center gap-2">
        <input type="number" className="w-20 border rounded-xl px-2 py-1" value={va} onChange={e=>setVa(e.target.value)} placeholder={placeholderA} />
        <span className="text-slate-500">–</span>
        <input type="number" className="w-20 border rounded-xl px-2 py-1" value={vb} onChange={e=>setVb(e.target.value)} placeholder={placeholderB} />
      </div>
    </div>
  );
}

function BracketPreview({ cuadro, labelEntrada }) {
  const rounds = Object.keys(cuadro).sort((a,b)=>parseInt(a)-parseInt(b));
  return (
    <div className="overflow-auto">
      <div className="flex gap-6 min-w-[600px]">
        {rounds.map(rk => (
          <div key={rk} className="min-w-[250px]">
            <div className="font-semibold mb-2">Ronda {rk}</div>
            <div className="space-y-2">
              {cuadro[rk].map(m => (
                <div key={m.id} className="border rounded-xl p-2 text-sm">
                  <div>{labelEntrada(m.a)}</div>
                  <div>{labelEntrada(m.b)}</div>
                  <div className="text-xs text-slate-500 mt-1">{m.done ? resumenMarcador(m) : '·'}</div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

function InfoTip({ children }) {
  return (
    <div className="text-xs bg-slate-50 border border-slate-200 rounded-xl p-3 text-slate-600">{children}</div>
  );
}
function IconButton({ title, onClick, icon:Icon }) {
  return (
    <button title={title} onClick={onClick} className="p-2 rounded-lg hover:bg-slate-100">
      <Icon className="w-4 h-4" />
    </button>
  );
}
function IconCopy(props){return (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={props.className}><rect x="9" y="9" width="13" height="13" rx="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>);} 
function IconTrash(props){return (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={props.className}><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>);} 

// ================== Helpers de dominio ==================
function newTorneo(){
  return {
    id: genId('t_'),
    nombre: '',
    formato: 'grupos_y_eliminacion', // 'grupos' | 'eliminacion' | 'grupos_y_eliminacion'
    modalidad: 'singles', // 'singles' | 'dobles'
    reglas: normalizeReglas(),
    gruposCount: 2,
    idaVuelta: false,
    topK: 2,
    participantes: [],
    teams: [],
    grupos: [],
    fixture: {}, // { G1: [ { id,a,b,done,result }, ... por rondas ] }
    cuadro: null, // { '1': [ {id,a,b,done,result,next:{round,slot}} ], '2': [...] }
    estado: 'config',
  };
}

// ==== REGLAS POR DEFECTO (arriba del archivo) ====
const DEFAULT_REGLAS = {
  grupos: {
    puntos: { win: 3, draw: 1, loss: 0 },
    wo: {              // Walkover (no presentación)
      ptsWin: 3,
      ptsLoss: 0,
      gf: 0,          // ej: 12 para 6-0 6-0 si querés reflejar games
      gc: 0
    },
    bye: {            // BYE estructural (descanso)
      cuenta: false,  // true = cuenta como victoria automática
      ptsWin: 3,
      gf: 0,
      gc: 0
    }
  }
};

// Normaliza reglas para que nunca tire undefined en el UI
function normalizeReglas(input) {
  const r = input || {};
  const g = r.grupos || {};
  const p = g.puntos || {};
  const s = r.sets || {};
  const k = r.ko || {};

  const toNum = (x, d) => (Number.isFinite(Number(x)) ? Number(x) : d);

  return {
    grupos: {
      puntos: {
        win:  toNum(p.win,  3),
        draw: toNum(p.draw, 1),
        loss: toNum(p.loss, 0),
      },
    },
    sets: {
      formato: s.formato || "bo1",     // "bo1" | "bo3" | "match_tb10"
      tb:      s.tb      || "tb7",     // "tb7" | "tb10" | "none"
    },
    ko: {
      seeding: k.seeding || "serpentina",
      sets:    k.sets    || "bo1",
      tb:      k.tb      || "tb7",
    },
  };
}


function formatLabel(f){
  return f==='grupos' ? 'Sólo grupos' : f==='eliminacion' ? 'Eliminación directa' : 'Grupos + Eliminación';
}
function prettyEstado(e){
  return e==='config' ? 'configuración' : e==='en_juego' ? 'en juego' : 'finalizado';
}
function inferStartTab(t){
  if (!t.nombre || !t.formato) return 'formato';
  if (!t.reglas) return 'reglas';
  return 'participantes';
}

// ===== LocalStorage (placeholder simple) =====
function loadTorneosLS(uid, clubId){
  const key = `torneos_v2__${uid||'anon'}__${clubId||'noClub'}`;
  try { return JSON.parse(localStorage.getItem(key) || '[]'); } catch { return []; }
}
function saveTorneosLS(uid, clubId, arr){
  const key = `torneos_v2__${uid||'anon'}__${clubId||'noClub'}`;
  try { localStorage.setItem(key, JSON.stringify(arr)); } catch {}
}

// ===== Generación de grupos y fixture =====
function buildGroups(ids, gruposCount){
  const G = [];
  const by = Math.ceil(ids.length / gruposCount);
  for (let i=0;i<gruposCount;i++){
    const slice = ids.slice(i*by, (i+1)*by);
    if (slice.length) G.push({ id: `G${i+1}`, nombre: `Grupo ${i+1}`, entradas: slice });
  }
  return G;
}

function buildRoundRobin(entries = [], idaVuelta = false) {
  const mkId = () =>
    (typeof genId === 'function' ? genId('m_') : `m_${Math.random().toString(36).slice(2,10)}`);

  // Copia y normalización
  const arr = (entries || []).filter(Boolean).slice();

  // Si es impar, agrego BYE como null (tu código ya lo filtraba)
  if (arr.length % 2 === 1) arr.push(null);

  const n = arr.length;
  if (n < 2) return [];

  const rounds = [];
  for (let r = 0; r < n - 1; r++) {
    const matches = [];
    for (let i = 0; i < n / 2; i++) {
      const a = arr[i];
      const b = arr[n - 1 - i];
      if (a != null && b != null) {
        matches.push({ id: mkId(), a, b, done: false });
      }
    }
    rounds.push(matches);

    // Rotación del algoritmo del círculo (primer elemento fijo)
    const fixed = arr[0];
    const rest = arr.slice(1);
    rest.unshift(rest.pop());
    arr.splice(0, arr.length, fixed, ...rest);
  }

  if (idaVuelta) {
    const rev = rounds.map(rs =>
      rs.map(m => ({ id: mkId(), a: m.b, b: m.a, done: false }))
    );
    return [...rounds, ...rev];
  }
  return rounds;
}

function flattenFixture(fx){
  const out = [];
  Object.entries(fx).forEach(([gid, rondas]) => {
    rondas.forEach(rs => rs.forEach(m => out.push({ ...m, grupo: gid })));
  });
  return out;
}

function resumenMarcador(m){
  if (!m?.result?.sets?.length) return '';
  const s = m.result.sets.map(x => `${x.a}-${x.b}${x.tb?' (TB)':''}`).join(', ');
  return `${s} · Ganador ${m.result.winner?.toUpperCase?.()}`;
}

function applyResultToFixture(torneo, matchId, result){
  const fx = torneo.fixture || {};
  Object.keys(fx).forEach(gid => {
    fx[gid] = fx[gid].map(rs => rs.map(m => (m.id===matchId ? { ...m, result, done:true } : m)));
  });
  torneo.fixture = fx;
  return torneo;
}

// Espera a que carguen imágenes dentro de un nodo
function waitImages(root) {
  const imgs = Array.from(root.querySelectorAll('img')).filter(img => !img.complete);
  if (!imgs.length) return Promise.resolve();
  return Promise.all(imgs.map(img => new Promise(res => {
    img.onload = img.onerror = () => res();
  })));
}

(function(){
  function defaultLabel(x, t){
    return (typeof x === 'string') ? x : (x?.label || x?.id || '—');
  }
  const lab = (e,t) => (window.labelEntradaCard ? window.labelEntradaCard(e,t) : defaultLabel(e,t));

  // Recorre cualquier estructura de KO (cuadro) y junta los matches
  function collectKOMatches(node, acc){
    acc = acc || [];
    if (!node) return acc;
    if (Array.isArray(node)){ node.forEach(n => collectKOMatches(n, acc)); return acc; }
    if (typeof node === 'object'){
      if ('jugadorA' in node || 'jugadorB' in node || 'resultado' in node || 'score' in node) acc.push(node);
      Object.values(node).forEach(v => { if (v && typeof v === 'object') collectKOMatches(v, acc); });
    }
    return acc;
  }

  // Aplana el fixture por grupo (si existe)
  function flattenGroupFixture(t){
    const out = [];
    const fixture = t?.fixture || {};
    const grupos = t?.grupos || [];
    grupos.forEach(g => {
      const gid = g.id || g.nombre;
      const rondas = fixture[gid];
      const list = [];
      if (Array.isArray(rondas)){
        rondas.forEach(r => ((r?.matches || r?.partidos || r || [])).forEach(m => {
          if (m && (m.jugadorA != null || m.jugadorB != null)) list.push(m);
        }));
      }
      out.push({ group: g, matches: list });
    });
    return out;
  }

  // Intenta determinar campeón desde KO
  function computeChampion(t){
    const ms = collectKOMatches(t?.cuadro, []);
    if (!ms.length) return null;
    // Preferí el que marque final; sino, el último
    const finalM = ms.find(m => m.isFinal || m.final || m.ronda === 'final' || m.round === 'final') || ms[ms.length-1];
    const res = finalM?.resultado;
    if (res === 'A' || res === 'B') {
      const winner = res === 'A' ? finalM.jugadorA : finalM.jugadorB;
      return { label: lab(winner, t), score: finalM.score || '', match: finalM };
    }
    return null;
  }

  // Construye una hoja A4 limpia y centrada con todo el contenido
  function buildA4TorneoSheet(torneo, showBracket){
    const sheet = document.createElement('div');
    sheet.style.cssText = [
      'width:1123px','min-height:794px','background:#fff','color:#0f172a',
      'padding:40px 48px','box-sizing:border-box','border-radius:12px',
      'box-shadow:0 0 0 1px rgba(0,0,0,.04)','font-family:ui-sans-serif,system-ui'
    ].join(';');

    // ===== Header centrado =====
    const header = document.createElement('div');
    header.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:8px;margin-bottom:16px';

    const brand = document.createElement('div');
    brand.style.cssText = 'display:flex;align-items:center;justify-content:center;gap:10px;font-weight:800;font-size:22px;margin:0 auto';
    (function setLogo(){
      const trySel = ['img[alt*="Coachex"]','img[alt*="logo"]','.topbar img','link[rel="icon"]'];
      let src = null;
      for (const s of trySel){
        const el = document.querySelector(s);
        if (!el) continue;
        src = el.tagName === 'LINK' ? el.href : el.src;
        if (src) break;
      }
      if (src){
        const img = document.createElement('img');
        img.src = src; img.alt = 'Coachex-Pro';
        img.style.cssText = 'width:28px;height:28px;border-radius:9999px;object-fit:cover';
        brand.appendChild(img);
      }
    })();
    const btxt = document.createElement('div'); btxt.textContent = 'Coachex-Pro';
    brand.appendChild(btxt);

    const title = document.createElement('div');
    title.textContent = torneo?.nombre || 'Torneo';
    title.style.cssText = 'font-size:26px;line-height:1.2;font-weight:800;text-align:center;margin-top:4px';

    const sub = document.createElement('div');
    const modo = torneo?.formato === 'eliminacion' ? 'Eliminación' : (torneo?.formato === 'grupos_y_eliminacion' ? 'Grupos + Eliminación' : 'Grupos');
    const count = (torneo?.modalidad === 'dobles' ? (torneo?.teams || []).length + ' parejas' : (torneo?.participantes || []).length + ' jugadores');
    const created = torneo?.createdAt ? new Date(torneo.createdAt).toLocaleDateString() : '';
    const topk = (torneo?.topK != null ? `Top-K: ${torneo.topK}` : '');
    const idaVuelta = torneo?.idaVuelta ? 'Ida y vuelta: Sí' : 'Ida y vuelta: No';
    sub.textContent = [modo, count, (created ? 'Creado: ' + created : ''), topk, idaVuelta].filter(Boolean).join(' · ');
    sub.style.cssText = 'font-size:12px;line-height:1.5;color:#64748b;text-align:center';

    header.appendChild(brand); header.appendChild(title); header.appendChild(sub);
    sheet.appendChild(header);

    const section = document.createElement('div');
    section.style.cssText = 'display:flex;flex-direction:column;gap:12px';

    // ===== Resultado Final =====
    const champion = computeChampion(torneo);
    if (champion){
      const card = document.createElement('div');
      card.style.cssText = 'border:1px solid #e2e8f0;border-radius:10px;padding:12px';
      const h = document.createElement('div');
      h.textContent = 'Resultado final';
      h.style.cssText = 'font-weight:700;margin-bottom:6px';
      const line = document.createElement('div');
      line.style.cssText = 'font-size:13px';
      line.textContent = `Campeón: ${champion.label}${champion.score ? ' · ' + champion.score : ''}`;
      card.appendChild(h); card.appendChild(line);
      section.appendChild(card);
    }

    // ===== Fase Final (resumen) =====
    if (showBracket && torneo?.cuadro){
      const ko = document.createElement('div');
      ko.style.cssText = 'border:1px solid #e2e8f0;border-radius:10px;padding:12px';
      const h = document.createElement('div');
      h.textContent = 'Fase Final (resumen)';
      h.style.cssText = 'font-weight:700;margin-bottom:6px';
      ko.appendChild(h);

      const list = document.createElement('div');
      list.style.cssText = 'display:grid;grid-template-columns:1fr;gap:6px';

      const matches = collectKOMatches(torneo.cuadro, []);
      if (!matches.length){
        const item = document.createElement('div');
        item.style.cssText = 'border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px';
        item.textContent = 'No hay cruces registrados.';
        list.appendChild(item);
      } else {
        matches.forEach(m => {
          const A = lab(m.jugadorA, torneo), B = lab(m.jugadorB, torneo);
          const res = (m.resultado==='A' ? 'Ganador A' : (m.resultado==='B' ? 'Ganador B' : (m.resultado==='D' ? 'Empate' : '')));
          const item = document.createElement('div');
          item.style.cssText = 'border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px';
          item.textContent = `${A || '—'} vs ${B || '—'}${m.score ? ' · ' + m.score : ''}${res ? ' · ' + res : ''}`;
          list.appendChild(item);
        });
      }
      ko.appendChild(list);
      section.appendChild(ko);
    }

    // ===== Grupos (resumen) =====
    if (torneo?.grupos){
      const gc = document.createElement('div');
      gc.style.cssText = 'border:1px solid #e2e8f0;border-radius:10px;padding:12px';
      const h2 = document.createElement('div');
      h2.textContent = 'Grupos (resumen)';
      h2.style.cssText = 'font-weight:700;margin-bottom:6px';
      gc.appendChild(h2);

      const fx = flattenGroupFixture(torneo);
      (torneo.grupos || []).forEach((g, idx) => {
        const gh = document.createElement('div');
        gh.textContent = `Grupo ${g.nombre || g.id || ''}`;
        gh.style.cssText = 'color:#64748b;margin:6px 0 4px 0';
        gc.appendChild(gh);

        // Entradas
        const elist = document.createElement('div');
        elist.style.cssText = 'display:grid;grid-template-columns:1fr;gap:4px';
        (g.entradas || []).forEach(e => {
          const item = document.createElement('div');
          item.style.cssText = 'border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px';
          item.textContent = lab(e, torneo);
          elist.appendChild(item);
        });
        gc.appendChild(elist);

        // Partidos del fixture (si hay)
        const mx = fx[idx]?.matches || [];
        if (mx.length){
          const t = document.createElement('div');
          t.textContent = 'Partidos:';
          t.style.cssText = 'color:#64748b;margin:6px 0 2px 0';
          gc.appendChild(t);

          const mlist = document.createElement('div');
          mlist.style.cssText = 'display:grid;grid-template-columns:1fr;gap:4px';
          mx.forEach(m => {
            const A = lab(m.jugadorA, torneo), B = lab(m.jugadorB, torneo);
            const res = (m.resultado==='A' ? 'Ganador A' : (m.resultado==='B' ? 'Ganador B' : (m.resultado==='D' ? 'Empate' : '')));
            const item = document.createElement('div');
            item.style.cssText = 'border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px';
            item.textContent = `${A || '—'} vs ${B || '—'}${m.score ? ' · ' + m.score : ''}${res ? ' · ' + res : ''}`;
            mlist.appendChild(item);
          });
          gc.appendChild(mlist);
        }
      });

      section.appendChild(gc);
    }

    if (!section.children.length){
      const empty = document.createElement('div');
      empty.style.cssText = 'border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px';
      empty.textContent = 'Sin datos para mostrar.';
      section.appendChild(empty);
    }

    sheet.appendChild(section);
    return sheet;
  }

  // Exponer helpers en window
  window.__buildA4TorneoSheet = buildA4TorneoSheet;
})();

// Exportar A4 a PDF (apaisado)



// ===== Bracket =====

// === Bracket (eliminación directa) ===
// Genera todas las rondas: R1 (semis si hay 4), R2 (final), etc.
// Soporta singles y dobles (le pasás IDs de alumnos o de teams).
function buildBracket(entryIds = [], opts = {}) {
  const seeding = (opts.seeding || 'serpentina').toLowerCase();

  // 1) Entradas únicas y válidas
  const ids = Array.from(new Set((entryIds || []).filter(Boolean)));
  const n = Math.max(2, ids.length);
  const size = 1 << Math.ceil(Math.log2(n)); // próxima potencia de 2

  // slots iniciales
  const slots = new Array(size).fill(null);
  for (let i = 0; i < ids.length; i++) slots[i] = ids[i];

  // 2) Orden de siembra (serpentina o aleatorio)
  const order = (seeding === 'aleatorio')
    ? shuffle([...Array(size).keys()])
    : serpentinaOrder(size);

  // 3) Primera ronda
  const round1 = [];
  for (let i = 0; i < size; i += 2) {
    const a = slots[order[i]];
    const b = slots[order[i + 1]];
    round1.push({
      id: `r1-m${(i / 2) + 1}`,
      a: a ?? { BYE: true },
      b: b ?? { BYE: true },
      done: false,
      result: null,
      next: { round: 2, slot: Math.floor(i / 2), side: null } // side se define abajo
    });
  }

  const cuadro = { '1': round1 };

  // 4) Rondas siguientes (conexiones)
  let prev = round1;
  let round = 2;
  while (prev.length > 1) {
    const curr = [];
    for (let j = 0; j < Math.ceil(prev.length / 2); j++) {
      curr.push({
        id: `r${round}-m${j + 1}`,
        a: null,
        b: null,
        done: false,
        result: null,
        next: { round: round + 1, slot: Math.floor(j / 2), side: null }
      });
    }
    // Enlazar prev -> curr y marcar el lado de destino (A/B) para cada ganador
    prev.forEach((m, j) => {
      const dest = curr[Math.floor(j / 2)];
      if (!dest) return;
      m.next.side = (j % 2 === 0) ? 'a' : 'b';
    });

    cuadro[String(round)] = curr;
    prev = curr;
    round++;
  }

  // 5) La última ronda (final) no tiene "next"
  const lastKey = String(round - 1);
  (cuadro[lastKey] || []).forEach(m => { delete m.next; });

  // 6) Avance automático de BYEs en la primera ronda
  // (usa isBYE + placeWinner; mantené esas funciones)
  (cuadro['1'] || []).forEach(m => {
    const byeA = !!m?.a?.BYE, byeB = !!m?.b?.BYE;
    if (byeA && !byeB) {
      m.result = { winner: 'b', sets: [], done: true };
      m.done = true;
      placeWinner(cuadro, m, m.b);
    } else if (byeB && !byeA) {
      m.result = { winner: 'a', sets: [], done: true };
      m.done = true;
      placeWinner(cuadro, m, m.a);
    } else if (byeA && byeB) {
      // ambos BYE: avanzamos arbitrariamente 'a' para no dejar hueco
      m.result = { winner: 'a', sets: [], done: true };
      m.done = true;
      placeWinner(cuadro, m, m.a);
    }
  });

  // Debug (opcional)
  try {
    console.log('buildBracket -> size:', size, 'R1:', round1.length, 'totalRounds:', Object.keys(cuadro).length);
  } catch {}

  return cuadro;
}

// Siembra serpentina (0,1, size-1, size-2, 2,3, size-3, size-4, ...)
function serpentinaOrder(size) {
  const out = [];
  let l = 0, r = size - 1, dir = 1;
  for (let i = 0; i < size; i++) {
    out.push(dir > 0 ? l++ : r--);
    if ((i + 1) % 2 === 0) dir *= -1;
  }
  return out;
}

// Shuffle simple (si querés seeding "aleatorio")
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function isBYE(x){ return !!(x && x.BYE); }
function findEntry(id, torneo){
  if (!id) return { id:"?" };
  if (typeof id === 'object' && id.BYE) return id; // BYE
  const arr = torneo.modalidad==='dobles' ? (torneo.teams||[]) : (torneo.participantes||[]);
  if (torneo.modalidad==='dobles') return arr.find(t => t.id===id) || { id };
  return id; // en singles, id es alumnoId
}

function placeWinner(cuadro, match, winnerEntry){
  const n = match?.next;
  if (!n) return;

  const destRound = cuadro[String(n.round)];
  if (!destRound) return;

  const dest = destRound[n.slot];
  if (!dest) return;

  // Usar el side indicado por buildBracket; si no viene, inferir por paridad
  let side = n.side;
  if (!side) {
    const prev = cuadro[String(n.round - 1)] || [];
    const idx = prev.findIndex(m => m.id === match.id); // 0,1,2,...
    side = (idx % 2 === 0) ? 'a' : 'b';
  }

  dest[side] = winnerEntry;
}

function recomputeNextSlots(cuadro) {
  if (!cuadro) return;
  const rounds = Object.keys(cuadro).map(Number).sort((a,b)=>a-b);
  for (let k = 1; k < rounds.length; k++) {
    const prev = cuadro[String(rounds[k-1])] || [];
    const curr = cuadro[String(rounds[k])]   || [];
    prev.forEach((m, j) => {
      const dest = curr[Math.floor(j / 2)];
      if (!dest) return;

      let winnerEntry = null;
      const wo = m?.result?.wo || m?.wo || m?.woWinner || null;
      if (wo === 'a') winnerEntry = m.a;
      else if (wo === 'b') winnerEntry = m.b;
      else if (m?.done && (m?.result?.winner === 'a' || m?.result?.winner === 'b')) {
        winnerEntry = (m.result.winner === 'a') ? m.a : m.b;
      }
      if (!winnerEntry) return;

      const side = m?.next?.side ?? ((j % 2 === 0) ? 'a' : 'b');
      dest[side] = winnerEntry;
    });
  }
}

function applyResultToBracket(torneo, matchId, result){
  const cuadro = torneo.cuadro; if (!cuadro) return torneo;
  let found = null;
  Object.values(cuadro).forEach(arr => {
    const f = arr.find(m => m.id === matchId);
    if (f) found = f;
  });
  if (!found) return torneo;

  found.result = result;
  found.done   = true;

  // Propagación puntual
  const winner = result.winner === 'a' ? found.a : found.b;
  placeWinner(cuadro, found, winner);

  // RECOMPUTE: asegura que la final tenga ambos lados cuando ambas semis terminaron
  recomputeNextSlots(cuadro);

  torneo.cuadro = cuadro;
  return torneo;
}

// Devuelve los clasificados en el ORDEN DE SIEMBRA que espera buildBracket.
// - G grupos (>=2)
// - Top-K por grupo (K >= 1)
// Regla: 1º de cada grupo se cruza con 2º de OTRO grupo (evita mismo grupo).
// Para K>2, empareja 3º vs 4º, 5º vs 6º, etc. con la misma lógica.
// Si sobra un "bucket" (K impar), esos entran al final y pueden cruzarse entre sí.
function computeQualifiers(torneo, K = 2) {
  const grupos = Array.isArray(torneo?.grupos) ? torneo.grupos : [];
  if (grupos.length === 0 || K <= 0) return [];

  // Tablas ordenadas por grupo (usa tu computeTablaGrupo actual)
  const tablas = grupos.map(g => (computeTablaGrupo(torneo, g.id) || []));

  // Buckets por posición: pos[0] => 1ºs, pos[1] => 2ºs, ...
  // Para favorecer cruces de grupos distintos, los "pares" (2º, 4º, ...) se invierten.
  const buckets = [];
  for (let p = 0; p < K; p++) {
    const fila = [];
    for (let gi = 0; gi < grupos.length; gi++) {
      const row = tablas[gi][p];
      const id = row && (row.alumnoId ?? row.id);
      if (id) fila.push({ id, gi }); // guardo también índice de grupo
    }
    // pares (p=1,3,5,...) los invierto para desalinear grupos
    buckets.push(p % 2 === 1 ? fila.reverse() : fila);
  }

  // Caso súper común: 2 grupos y K=2 → [A1, B2, A2, B1]
  if (grupos.length === 2 && K === 2) {
    const A1 = buckets[0][0]?.id, B1 = buckets[0][1]?.id;
    const B2 = buckets[1][0]?.id, A2 = buckets[1][1]?.id; // buckets[1] ya está "reverso"
    return [A1, B2, A2, B1].filter(Boolean);
  }

  // Empareja bucket 1 con 2, 3 con 4, ... tratando de evitar mismo grupo
  const pairs = [];
  const L = Math.floor(buckets.length / 2);
  for (let i = 0; i < L; i++) {
    const A = buckets[2 * i];     // 1ºs, 3ºs, 5ºs, ...
    const B = buckets[2 * i + 1]; // 2ºs, 4ºs, 6ºs, ...
    const usedB = new Array(B.length).fill(false);

    for (let k = 0; k < A.length; k++) {
      const a = A[k];
      if (!a) continue;

      // Intento emparejar con mismo índice k
      let pick = -1;
      if (B[k] && !usedB[k] && B[k].gi !== a.gi) pick = k;

      // Si cae mismo grupo o no hay, busco otro B libre de distinto grupo
      if (pick === -1) {
        for (let j = 0; j < B.length; j++) {
          if (!usedB[j] && B[j] && B[j].gi !== a.gi) { pick = j; break; }
        }
      }

      if (pick !== -1) {
        usedB[pick] = true;
        pairs.push([a.id, B[pick].id]); // par completo
      } else {
        // No encontré rival “distinto grupo” (bucket asimétrico o grupos dispares): entra solo → BYE posible
        pairs.push([a.id]);
      }
    }

    // Si quedaron B sin usar (cuando B > A), los agrego solos
    for (let j = 0; j < B.length; j++) {
      if (!usedB[j] && B[j]) pairs.push([B[j].id]);
    }
  }

  // Si K es impar, queda un bucket “sueltito” (p.ej. 3ºs). Los emparejo entre ellos evitando, si se puede,
  // cruces del mismo grupo. Si no se puede, van como queden.
  if (buckets.length % 2 === 1) {
    const last = buckets[buckets.length - 1]; // ej: todos los 5ºs
    const used = new Array(last.length).fill(false);
    for (let i = 0; i < last.length; i++) {
      if (used[i]) continue;
      let jPick = -1;
      for (let j = i + 1; j < last.length; j++) {
        if (!used[j] && last[j].gi !== last[i].gi) { jPick = j; break; }
      }
      if (jPick !== -1) {
        used[i] = used[jPick] = true;
        pairs.push([last[i].id, last[jPick].id]);
      } else {
        // sin pareja válida distinta: solo → BYE posible
        used[i] = true;
        pairs.push([last[i].id]);
      }
    }
  }

  // Aplanar a orden de siembra: [a1,b1, a2,b2, ...] (los “solos” quedan como están)
  const seedOrder = [];
  for (const p of pairs) seedOrder.push(...p.filter(Boolean));

  // Unicidad por las dudas (y sin "undefined")
  return Array.from(new Set(seedOrder.filter(Boolean)));
}



function renderTeamLabel(team, alumnos){
  const a = alumnos.find(x=>x.id===team.members[0]);
  const b = alumnos.find(x=>x.id===team.members[1]);
  const la = a ? (a.apellido? a.apellido+", "+(a.nombre||a.name||'') : (a.nombre||a.name||'')) : team.members[0];
  const lb = b ? (b.apellido? b.apellido+", "+(b.nombre||b.name||'') : (b.nombre||b.name||'')) : team.members[1];
  return `${la} / ${lb}`;
}

// ================== Utilidades generales ==================
function genId(prefix='id_'){ return prefix + Math.random().toString(36).slice(2, 9); }
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
function cx(){ return Array.from(arguments).filter(Boolean).join(' '); }
function deepSet(obj, pathArr, value){
  const o = deepClone(obj);
  let cur = o;
  for (let i=0;i<pathArr.length-1;i++){
    const k = pathArr[i];
    if (!cur[k] || typeof cur[k] !== 'object') cur[k] = {};
    cur = cur[k];
  }
  cur[pathArr[pathArr.length-1]] = value;
  return o;
}
// === Helpers robustos para alumnos ===
function alumnoId(a){
  return a?.id ?? a?.uid ?? a?._id ?? String(a?.dni ?? a?.email ?? Math.random());
}
function alumnoLabel(a){
  const ap = a?.apellido ?? a?.lastName ?? a?.apellidos ?? "";
  const no = a?.nombre   ?? a?.firstName ?? a?.name ?? a?.displayName ?? "";
  const label = (ap && no) ? `${ap}, ${no}` : (ap || no);
  return label || a?.alias || a?.nick || a?.email || alumnoId(a);
}

// Lee el PIN desde Perfil (3 dígitos). Intenta por club y luego global.
function getPerfilPIN(perfil, clubId) {
  const pin =
    perfil?.clubs?.[clubId]?.pin ??
    perfil?.clubs?.[clubId]?.pinSeguridad ??
    perfil?.pin ??
    perfil?.pinSeguridad ??
    null;
  return pin != null ? String(pin).trim() : null;
}


// Botón habilitado/inhabilitado
function canButton(enabled){
  return enabled
    ? 'bg-[#34745B] text-white hover:opacity-90'
    : 'bg-slate-200 text-slate-500 cursor-not-allowed';
}

// ¿Están todos los partidos de grupos cargados?
function groupsAllMatchesDone(t) {
  const fx = t.fixture || {};
  const gids = Object.keys(fx);
  if (!gids.length) return false;
  for (const gid of gids) {
    for (const ronda of (fx[gid] || [])) {
      for (const m of (ronda || [])) {
        if (!m?.done) return false;
      }
    }
  }
  return true;
}

// ¿Cuántos faltan?
function countPendingGroupMatches(t) {
  let pending = 0;
  Object.values(t.fixture || {}).forEach(rounds =>
    (rounds || []).forEach(rs =>
      (rs || []).forEach(m => { if (!m?.done) pending++; })
    )
  );
  return pending;
}


// ¿Ya hay resultados en KO?
function hasKOResults(cuadro) {
  if (!cuadro) return false;
  return Object.values(cuadro).some(rounds => rounds.some(m => !!m?.done));
}

// === Liga / Solo grupos ===
function isLeagueMode(t){
  const f = t?.formato;
  return f === 'grupos' || f === 'liga' || f === 'solo_grupos' || f === 'league';
}

// Campeón/Subcampeón en LIGA (un grupo). Si hay varios grupos sin KO,
// devuelve ganador por cada grupo.
function leagueWinnersInfo(torneo){
  if (!isLeagueMode(torneo)) return null;
  if (!groupsAllMatchesDone(torneo)) return { done:false };

  const fx = torneo.fixture || {};
  const gids = Object.keys(fx).filter(gid => Array.isArray(fx[gid]) && fx[gid].length);

  if (gids.length <= 1) {
    // Liga de un solo grupo: top1 y top2
    const ids = computeQualifiers(torneo, 2) || [];
    const [champion, runnerUp] = ids.filter(Boolean);
    if (!champion) return { done:false };
    return { done:true, type:'single', champion, runnerUp: runnerUp || null };
  }

  // Varios grupos sin KO: ganador por cada grupo
  const byGroup = {};
  for (const gid of gids) {
    const temp = deepClone(torneo);
    temp.fixture = { [gid]: fx[gid] };
    temp.grupos  = (torneo.grupos || []).filter(g => g.id === gid);
    const top = computeQualifiers(temp, 1) || [];
    byGroup[gid] = top[0] || null;
  }
  return { done:true, type:'multi', byGroup };
}

// ===== Helper: arma el texto de reglas/formato a partir del torneo =====
function buildReglamentoTexto(t) {
  const modalidad = t?.modalidad === 'dobles' ? 'Dobles' : 'Singles';

  const fmtFecha = (v) => {
    if (!v) return '';
    const d = new Date(v);
    if (isNaN(d)) return '';
    const dd = String(d.getDate()).padStart(2, '0');
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const yyyy = d.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  };
  const fIni = fmtFecha(t?.fechaInicio);
  const fFin = fmtFecha(t?.fechaFin);
  const fechasLinea = fIni && fFin
    ? `Se juega del ${fIni} al ${fFin}.`
    : fIni ? `Se juega desde el ${fIni}.`
    : fFin ? `Se juega hasta el ${fFin}.` : '';

  const setsLabel = (k) =>
    k === 'bo1' ? 'al mejor de 1 set' :
    k === 'bo5' ? 'al mejor de 5 sets' :
    k === 'match_tb10' ? 'match tiebreak a 10' :
    'al mejor de 3 sets';

  const tbLabel = (k) =>
    k === 'tb10' ? 'tiebreak a 10' :
    k === 'tb7'  ? 'tiebreak a 7'  :
    'sin tiebreak';

  const r = normalizeReglas?.(t?.reglas) || (t?.reglas || {});
  const puntos = r?.grupos?.puntos || { win: 3, draw: 1, loss: 0 };

  const partes = [];
  partes.push(`Modalidad: ${modalidad}.`);
  if (fechasLinea) partes.push(fechasLinea);

  if (t?.formato === 'grupos' || t?.formato === 'grupos_y_eliminacion') {
    const gruposCount = t?.gruposCount ?? null;
    const idaVuelta = !!t?.idaVuelta;
    const setsFmt = setsLabel(r?.sets?.formato);
    const tbFmt   = tbLabel(r?.sets?.tb);
    partes.push(
      `Fase de grupos: ${gruposCount ?? '?'} grupo(s)` +
      `${idaVuelta ? ', ida y vuelta' : ''}. ` +
      `Puntaje: victoria ${puntos.win}, empate ${puntos.draw}, derrota ${puntos.loss}. ` +
      `Partidos ${setsFmt} con ${tbFmt}.`
    );
  }

  if (t?.formato === 'eliminacion' || t?.formato === 'grupos_y_eliminacion') {
    const clasif = t?.formato === 'grupos_y_eliminacion'
      ? `Clasifican ${parseInt(t?.topK ?? 2, 10)} por grupo. `
      : '';
    const koSets = setsLabel(r?.ko?.sets);
    const koTB   = tbLabel(r?.ko?.tb);
    partes.push(`Eliminación directa: ${clasif}Partidos ${koSets} con ${koTB}.`);
  }

  return partes.join(' ');
}

// ===== Panel reutilizable: muestra/copia/guarda el resumen =====
function ResumenReglasBox({ torneo, disabled, onGuardar }) {
  const texto = React.useMemo(() => buildReglamentoTexto(torneo), [torneo]);

  return (
    <div className="border rounded-xl p-3 mt-4">
      <div className="flex items-center justify-between mb-2">
        <div className="font-semibold text-slate-800">Resumen de formato y reglas</div>
        <div className="flex gap-2">
          <button
            type="button"
            className="px-3 py-1.5 rounded-xl border"
            onClick={() => navigator.clipboard?.writeText(texto)}
          >
            Copiar
          </button>
          <button
            type="button"
            className="px-3 py-1.5 rounded-xl bg-[#34745B] text-white disabled:opacity-50"
            onClick={() => onGuardar?.(texto)}
            disabled={disabled}
          >
            Guardar en torneo
          </button>
        </div>
      </div>

      <textarea
        readOnly
        className="w-full border rounded-xl p-2 min-h-[120px]"
        value={texto}
      />

      {!!torneo?.reglamentoTexto && (
        <div className="text-xs text-slate-500 mt-2">
          Guardado: {String(torneo.reglamentoTexto).slice(0, 140)}
          {String(torneo.reglamentoTexto).length > 140 ? '…' : ''}
        </div>
      )}
    </div>
  );
}


// ===== Tabla de posiciones (Standings) =====
function idKey(e){ return (typeof e === 'string') ? e : (e && e.id) ? e.id : String(e); }

function computeStandings(torneo) {
  const out = {};
  const reglas = normalizeReglas(torneo.reglas);
  const P  = (reglas?.grupos?.puntos) || { win: 3, draw: 1, loss: 0 };
  const WO = { ptsWin: P.win, ptsLoss: P.loss, gf: 0, gc: 0, ...(reglas?.grupos?.wo || {}) };
  const BYE = { cuenta: false, ptsWin: P.win, gf: 0, gc: 0, ...(reglas?.grupos?.bye || {}) };

  // === Helpers ===
  const idDe = (eid) => idKey(eid);
  const isBYE = (side) => !!(side && (side.BYE || side.id === 'BYE' || side === 'BYE'));

  const getWO = (m) => {
    // ganador por WO
    if (m?.result?.wo === 'a' || m?.wo === 'a' || m?.woWinner === 'a') return { winner: 'a', loser: 'b' };
    if (m?.result?.wo === 'b' || m?.wo === 'b' || m?.woWinner === 'b') return { winner: 'b', loser: 'a' };
    // perdedor explícito
    const np = m?.result?.noPresento ?? m?.noPresento;
    if (np === 'a') return { winner: 'b', loser: 'a' };
    if (np === 'b') return { winner: 'a', loser: 'b' };
    return null;
  };

  const sumSets = (sets) => {
    let ga = 0, gb = 0;
    (sets || []).forEach(s => {
      ga += Number(s?.a || 0);
      gb += Number(s?.b || 0);
    });
    return [ga, gb];
  };

  const parseScores = (m) => {
    if (m?.result?.sets && Array.isArray(m.result.sets)) return sumSets(m.result.sets);
    const sA = Number(m?.scoreA ?? m?.result?.scoreA ?? NaN);
    const sB = Number(m?.scoreB ?? m?.result?.scoreB ?? NaN);
    if (Number.isFinite(sA) && Number.isFinite(sB)) return [sA, sB];
    return [0, 0];
  };

  const inferWinner = (m, ga, gb) => {
    let w = m?.result?.winner ?? m?.winner ?? m?.ganador ?? m?.resultado?.winner ?? null;
    if (w === 'A') w = 'a';
    if (w === 'B') w = 'b';
    if (typeof w === 'number') w = (w === 1 ? 'a' : (w === 2 ? 'b' : null));
    if (w === 'empate') w = 'draw';
    if (!w) {
      if (Number.isFinite(ga) && Number.isFinite(gb)) {
        if (ga > gb) w = 'a';
        else if (gb > ga) w = 'b';
        else w = 'draw';
      }
    }
    return w; // 'a' | 'b' | 'draw' | null
  };

  const partidoJugado = (m) => {
    if (!m) return false;
    if (getWO(m)) return true; // WO cuenta como jugado
    if (m.done || m?.result?.done) return true;
    if (m?.result?.winner != null || m?.winner != null || m?.ganador != null) return true;
    const sA = Number(m?.scoreA ?? m?.result?.scoreA ?? NaN);
    const sB = Number(m?.scoreB ?? m?.result?.scoreB ?? NaN);
    return Number.isFinite(sA) && Number.isFinite(sB);
  };

  // === Inicializa por grupo con entradas ===
  (torneo.grupos || []).forEach(g => {
    const map = {};
    (g.entradas || []).forEach(eid => {
      const k = idDe(eid);
      map[k] = { eid, pj: 0, pg: 0, pe: 0, pp: 0, gf: 0, gc: 0, gd: 0, pts: 0 };
    });
    out[g.id] = map;
  });

  // === Recorrer fixture por grupo ===
  Object.entries(torneo.fixture || {}).forEach(([gid, rondas]) => {
    const map = out[gid];
    if (!map) return;

    const matches = Array.isArray(rondas?.[0]) ? rondas.flat() : (rondas || []);

    matches.forEach(m => {
      if (!m || !partidoJugado(m)) return;

      const aK = idDe(m.a), bK = idDe(m.b);
      const aIsBye = isBYE(m.a), bIsBye = isBYE(m.b);

      // --- Caso BYE estructural ---
      if (aIsBye || bIsBye) {
        // si no querés que cuente, salimos
        if (!BYE.cuenta) return;

        // si sí cuenta, gana el no-BYE (si existe en el mapa)
        const winKey = aIsBye ? bK : aK;
        const loseKey = aIsBye ? aK : bK;
        if (!map[winKey]) return;

        map[winKey].pj++; map[winKey].pg++;
        map[winKey].pts += BYE.ptsWin;
        map[winKey].gf  += BYE.gf; map[winKey].gc  += BYE.gc;

        if (map[loseKey]) {
          map[loseKey].pj++; map[loseKey].pp++;
          // por default, no sumamos puntos al que tiene BYE
          map[loseKey].gf += BYE.gc; map[loseKey].gc += BYE.gf;
        }
        return;
      }

      // --- Caso WO (no presentación) ---
      const wo = getWO(m);
      if (wo) {
        const wKey = wo.winner === 'a' ? aK : bK;
        const lKey = wo.loser  === 'a' ? aK : bK;
        if (!map[wKey] || !map[lKey]) return;

        map[wKey].pj++; map[lKey].pj++;
        map[wKey].pg++; map[lKey].pp++;

        map[wKey].pts += WO.ptsWin;
        map[lKey].pts += (WO.ptsLoss ?? 0);

        map[wKey].gf += WO.gf; map[wKey].gc += WO.gc;
        map[lKey].gf += WO.gc; map[lKey].gc += WO.gf;
        return;
      }

      // --- Partido normal ---
      if (!map[aK] || !map[bK]) return;

      map[aK].pj++; map[bK].pj++;

      const [ga, gb] = parseScores(m);
      map[aK].gf += ga; map[aK].gc += gb;
      map[bK].gf += gb; map[bK].gc += ga;

      const w = inferWinner(m, ga, gb);
      if (w === 'a') {
        map[aK].pg++; map[bK].pp++;
        map[aK].pts += P.win; map[bK].pts += P.loss;
      } else if (w === 'b') {
        map[bK].pg++; map[aK].pp++;
        map[bK].pts += P.win; map[aK].pts += P.loss;
      } else {
        map[aK].pe++; map[bK].pe++;
        map[aK].pts += P.draw; map[bK].pts += P.draw;
      }
    });
  });

  // === Cerrar arrays y ordenar ===
  const final = {};
  Object.entries(out).forEach(([gid, map]) => {
    const rows = Object.values(map).map(r => ({ ...r, gd: (r.gf - r.gc) }));
    rows.sort((A, B) =>
      (B.pts - A.pts) ||
      (B.gd  - A.gd)  ||
      (B.gf  - A.gf)  ||
      (B.pg  - A.pg)
    );
    final[gid] = rows;
  });

  return final;
}


function StandingsTable({ rows, getLabel }){
  if (!rows || !rows.length) return <div className="text-sm text-slate-500">Aún sin posiciones.</div>;
  return (
    <div className="overflow-auto">
      <table className="min-w-[680px] w-full text-sm">
        <thead className="text-xs text-slate-500">
          <tr>
            <th className="text-left py-1 pr-2">#</th>
            <th className="text-left py-1">Jugador / Pareja</th>
            <th className="text-right py-1">PJ</th>
            <th className="text-right py-1">PG</th>
            <th className="text-right py-1">PE</th>
            <th className="text-right py-1">PP</th>
            <th className="text-right py-1">PF</th>
            <th className="text-right py-1">PC</th>
            <th className="text-right py-1">+/-</th>
            <th className="text-right py-1">PF/PJ</th>
            <th className="text-right py-1">Pts</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r, i) => {
            const ppg = r.pj ? (r.gf / r.pj) : 0;
            return (
              <tr key={idKey(r.eid)} className="border-t">
                <td className="py-1 pr-2">{i+1}</td>
                <td className="py-1">{getLabel ? getLabel(r.eid) : String(idKey(r.eid))}</td>
                <td className="py-1 text-right">{r.pj||0}</td>
                <td className="py-1 text-right">{r.pg||0}</td>
                <td className="py-1 text-right">{r.pe||0}</td>
                <td className="py-1 text-right">{r.pp||0}</td>
                <td className="py-1 text-right">{r.gf||0}</td>
                <td className="py-1 text-right">{r.gc||0}</td>
                <td className="py-1 text-right">{(r.gf - r.gc)||0}</td>
                <td className="py-1 text-right">{ppg.toFixed(1)}</td>
                <td className="py-1 text-right font-semibold">{r.pts||0}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}


    
    function Pagos({ pagos, alumnos, perfil, onPayMensual, clases, onEditarPago, onDeletePago }) {
  const [vista, setVista] = useState(perfil.metodoCobro === 'mensual' ? 'mensual' : 'historial');

  useEffect(() => {
    setVista(perfil.metodoCobro === 'mensual' ? 'mensual' : 'historial');
  }, [perfil.metodoCobro]);

  // Botón de pestaña uniforme
  const TabBtn = ({ id, children }) => (
    <button
      onClick={() => setVista(id)}
      className={`w-full text-center px-3 py-1.5 text-sm rounded-lg transition
        ${vista === id ? 'bg-white shadow' : 'bg-transparent hover:bg-white/60'}`}
    >
      {children}
    </button>
  );

  return (
    <div className="grid gap-4">
      <div className="grid grid-cols-4 gap-1 bg-slate-100 p-1 rounded-xl">
        <TabBtn id="historial">Historial de Pagos</TabBtn>
        <TabBtn id="porAlumno">Historial por alumno</TabBtn>
        <TabBtn id="mensual">Control Clases Mensuales</TabBtn>
        <TabBtn id="deudas">Control de Deudas</TabBtn>
      </div>

      {vista === 'historial' && (
        <HistorialPagos
          pagos={pagos}
          alumnos={alumnos}
          clases={clases}
          onEditarPago={onEditarPago}
          onDeletePago={onDeletePago}
          perfil={perfil}
        />
      )}

      {vista === 'porAlumno' && (
        <HistorialPorAlumno pagos={pagos} alumnos={alumnos} />
      )}

      {vista === 'mensual' && (
        <ControlMensual pagos={pagos} alumnos={alumnos} perfil={perfil} onPay={onPayMensual} />
      )}

      {vista === 'deudas' && (
        <ControlDeudas pagos={pagos} alumnos={alumnos} clases={clases} perfil={perfil} />
      )}
    </div>
  );
}


function HistorialPagos({
  pagos, alumnos, clases,
  onEditarPago, onDeletePago,
  perfil,               // ← NUEVO (puede venir del padre)
  nombreLugar: nombreLugarProp // ← NUEVO (opcional)
}) {
          const [periodo, setPeriodo] = useState("mes");
          const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
          const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
          const [metodo, setMetodo] = useState("Todos");
          const [currentPage, setCurrentPage] = useState(1);
          const [menuComprobante, setMenuComprobante] = useState(null);
          
          const ITEMS_PER_PAGE = 10;
          const alumnoMap = useMemo(() => new Map(alumnos.map(a => [a.id, getNombreCompleto(a)])), [alumnos]);

          const lugarActual = nombreLugarProp
    ?? perfil?.lugarTrabajoNombre
    ?? perfil?.lugar
    ?? perfil?.sede
    ?? "-";

          const pagosConDatos = useMemo(() => {
  return pagos.map(pago => {
    const nombreAlumno = alumnoMap.get(pago.alumnoId) || 'Alumno no encontrado';
    const concepto = pago.concepto || `Pago de ${nombreAlumno}`;
    return { ...pago, nombreAlumno, concepto }; // ← corregido
  });
}, [pagos, alumnoMap]);
          
          const pagosFiltrados = useMemo(() => {
            const ahora = new Date();
            return pagosConDatos.filter(p => {
                const fechaPago = new Date(p.fecha + "T00:00:00");
                if (periodo === 'dia') return formatDate(fechaPago) === formatDate(ahora);
                if (periodo === 'semana') return getWeekStartDate(fechaPago).getTime() === getWeekStartDate(ahora).getTime();
                if (periodo === 'año') return fechaPago.getFullYear() === selectedYear;
                if (periodo === 'mes') {
                  // Corregimos la condición para que solo filtre por método si no es "Todos"
                  if (metodo !== 'Todos' && p.metodo !== metodo) return false;
                  return fechaPago.getMonth() === selectedMonth && fechaPago.getFullYear() === selectedYear;
                }
                if (metodo !== 'Todos' && p.metodo !== metodo) return false;
                return true;
              }).sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
          }, [pagosConDatos, periodo, selectedMonth, selectedYear, metodo]);
          
          const totales = useMemo(() => {
            return pagosFiltrados.reduce((acc, p) => {
              if (p.metodo !== 'Pendiente') {
                const monto = parseFloat(p.monto || 0) || 0;
                acc.total += monto;
                if (p.metodo === 'Efectivo') acc.efectivo += monto;
                if (p.metodo === 'Transferencia') acc.transferencia += monto;
              }
              return acc;
            }, { total: 0, efectivo: 0, transferencia: 0 });
          }, [pagosFiltrados]);

          const totalPages = Math.ceil(pagosFiltrados.length / ITEMS_PER_PAGE);
          const paginatedPagos = useMemo(() => {
            const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
            return pagosFiltrados.slice(startIndex, startIndex + ITEMS_PER_PAGE);
          }, [pagosFiltrados, currentPage]);

          useEffect(() => {
            setCurrentPage(1);
          }, [periodo, selectedMonth, selectedYear, metodo]);

          const availableYears = useMemo(() => {
            const years = new Set(pagos.map(p => new Date(p.fecha).getFullYear()));
            if (!years.has(new Date().getFullYear())) {
                years.add(new Date().getFullYear());
            }
            return Array.from(years).sort((a, b) => b - a);
          }, [pagos]);

          const FilterButton = ({ onClick, isActive, children }) => (
            <button onClick={onClick} className={`px-3 py-1 rounded-md transition-colors text-sm ${isActive ? 'bg-white shadow text-slate-800 font-semibold' : 'text-slate-500 hover:text-slate-800'}`}>
                {children}
            </button>
          );

          return (
            <Card title={<span className="text-[#34745B]">Historial de Pagos</span>}>
                <div className="p-3 border rounded-xl bg-slate-50 mb-4 space-y-3">
                    <div className="flex flex-wrap items-center gap-4">
                        <div className="bg-slate-200 p-1 rounded-lg inline-flex items-center">
                            <FilterButton onClick={() => { setPeriodo('dia'); setSelectedYear(new Date().getFullYear()); }} isActive={periodo === 'dia'}>Hoy</FilterButton>
                            <FilterButton onClick={() => { setPeriodo('semana'); setSelectedYear(new Date().getFullYear()); }} isActive={periodo === 'semana'}>Semana</FilterButton>
                        </div>
                        <div className="bg-slate-200 p-1 rounded-lg flex-1 flex-wrap inline-flex items-center">
                             {MESES_NOMBRES.map((mes, index) => (
                                <FilterButton key={mes} onClick={() => { setPeriodo('mes'); setSelectedMonth(index); }} isActive={periodo === 'mes' && selectedMonth === index}>{mes}</FilterButton>
                            ))}
                        </div>
                        <div className="bg-slate-200 p-1 rounded-lg inline-flex items-center">
                           <select 
                             value={selectedYear} 
                             onChange={(e) => { setPeriodo('mes'); setSelectedYear(parseInt(e.target.value)); }}
                             className="bg-white px-2 py-1 rounded-md text-sm font-semibold shadow"
                           >
                            {availableYears.map(year => <option key={year} value={year}>{year}</option>)}
                           </select>
                        </div>
                    </div>
                     <div className="bg-slate-200 p-1 rounded-lg inline-flex items-center flex-wrap">
                        <FilterButton onClick={() => setMetodo('Todos')} isActive={metodo === 'Todos'}>Todos</FilterButton>
                        <FilterButton onClick={() => setMetodo('Efectivo')} isActive={metodo === 'Efectivo'}>Efectivo</FilterButton>
                        <FilterButton onClick={() => setMetodo('Transferencia')} isActive={metodo === 'Transferencia'}>Transferencia</FilterButton>
                        <FilterButton onClick={() => setMetodo('Pendiente')} isActive={metodo === 'Pendiente'}>Pendiente</FilterButton>
                    </div>
                </div>

                <div className="grid md:grid-cols-3 gap-4 mb-4">
  <div className="bg-green-50 border border-green-200 p-4 rounded-xl">
    <p className="text-sm text-green-800">Total Ingresado</p>
    <p className="text-2xl font-bold text-[#34745B]">{formatCurrency(totales.total)}</p>
  </div>
  <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl">
    <p className="text-sm text-slate-600">Total en Efectivo</p>
    <p className="text-2xl font-bold text-slate-800">{formatCurrency(totales.efectivo)}</p>
  </div>
  <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl">
    <p className="text-sm text-slate-600">Total por Transferencia</p>
    <p className="text-2xl font-bold text-slate-800">{formatCurrency(totales.transferencia)}</p>
  </div>
</div>
                
<div className="overflow-x-auto">
  <table className="w-full table-fixed text-sm">
    <thead>
      <tr className="text-left text-slate-600">
        <th className="p-2 w-1/12">Fecha</th>
        <th className="p-2 w-2/12">Alumno</th>
        <th className="p-2 w-4/12">Concepto</th>
        <th className="p-2 w-1/12">Monto</th>
        <th className="p-2 w-1/12">Método</th>
        <th className="p-2 w-3/12 text-right">Acciones</th>
      </tr>
    </thead>
    <tbody>
      {paginatedPagos.length === 0 && (
        <tr>
          <td colSpan={6} className="text-center py-6 text-slate-400">No hay pagos que coincidan con los filtros</td>
        </tr>
      )}
      {paginatedPagos.map(p => (
        <tr key={p.id} className="border-t">
          <td className="p-2">{p.fecha}</td>
          <td className="p-2 font-semibold">{p.nombreAlumno}</td>
          <td className="p-2">{p.concepto}</td>
          <td className="p-2">{formatCurrency(p.monto)}</td>
          <td className="p-2">
            <span className={`px-2 py-0.5 rounded-full text-xs ${p.metodo === 'Pendiente' ? 'bg-orange-100 text-orange-800' : p.metodo === 'Mixto' ? 'bg-purple-100 text-purple-800' : 'bg-green-100 text-green-800'}`}>
              {p.metodo}
            </span>
          </td>
          <td className="p-2 text-right">

  <div className="inline-flex gap-2 items-center">
    {/* Editar */}
    <button
      onClick={() => onEditarPago(p)}
      className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50"
      title="Editar pago"
    >
      ✏️ Editar
    </button>

    {/* Eliminar */}
    <button
      onClick={() => onDeletePago(p.id)}
      className="px-2 py-1 text-xs rounded-lg border text-red-600 hover:bg-red-50"
      title="Eliminar pago"
    >
      🗑️ Eliminar
    </button>

    {/* Comprobante: menú de acciones */}
    {p.claseId && p.metodo !== 'Pendiente' && (
      <div className="relative inline-block text-left">
        <button
          type="button"
          className="px-2 py-1 text-xs rounded-lg border hover:bg-emerald-50 text-emerald-700"
          title="Opciones de comprobante"
          onClick={() => setMenuComprobante(menuComprobante === p.id ? null : p.id)}
        >
          📄 Comprobante ▾
        </button>

        {menuComprobante === p.id && (
          <div className="absolute right-0 z-10 mt-1 w-48 rounded-md border bg-white shadow-lg">
            {/* Descargar PDF */}
            <button
              type="button"
              className="block w-full text-left px-3 py-2 text-sm hover:bg-slate-50"
              onClick={async () => {
                const clase  = (clases || []).find(c => c.id === p.claseId);
                const alumno = (alumnos || []).find(a => a.id === p.alumnoId);
                if (!clase)  { alert("No se encontró la clase asociada a este pago."); return; }
                if (!alumno) { alert("No se encontró el alumno asociado a este pago."); return; }
                if (typeof window.generarComprobanteClase !== 'function') {
                  alert("No se encontró la función para generar comprobantes.");
                  return;
                }
                // descarga directa
                await window.generarComprobanteClase({
                  pago: p,
                  clase,
                  alumno,
                  perfil,
                  lugar: (perfil?.lugarTrabajoNombre || perfil?.lugar || perfil?.sede || "-"),
                  // sin returnBlob -> guarda el archivo
                });
                setMenuComprobante(null);
              }}
            >
              Descargar PDF
            </button>

            {/* Enviar por WhatsApp */}
<button
  type="button"
  className="block w-full text-left px-3 py-2 text-sm hover:bg-slate-50"
  onClick={async () => {
    try {
      const clase  = (clases || []).find(c => c.id === p.claseId);
      const alumno = (alumnos || []).find(a => a.id === p.alumnoId);
      if (!clase)  { alert("No se encontró la clase asociada a este pago."); return; }
      if (!alumno) { alert("No se encontró el alumno asociado a este pago."); return; }
      if (typeof window.generarComprobanteClase !== 'function') {
        alert("No se encontró la función para generar comprobantes."); return;
      }

      // 1) Generar el comprobante como BLOB (NO descarga)
      const result = await window.generarComprobanteClase({
        pago: p,
        clase,
        alumno,
        perfil,
        lugar: (perfil?.lugarTrabajoNombre || perfil?.lugar || perfil?.sede || "-"),
        returnBlob: true
      });
      if (!result) return;

      // 2) Teléfono del alumno (robusto) + normalización a wa.me
      const telRaw = getTelefonoAlumno(alumno);            // <- helper global
      const phone  = normalizarTelefonoParaWhatsApp(telRaw); // <- helper global
      if (!phone) {
        const alu = `${alumno?.apellidos || alumno?.apellido || ""} ${alumno?.nombres || alumno?.nombre || ""}`.trim();
        alert(`El alumno ${alu || "(sin nombre)"} no tiene un teléfono válido para WhatsApp.`);
        return;
      }

      // 3) Enviar por WhatsApp (sin descargar en fallback de escritorio)
      const nombreAlu = `${alumno?.apellidos || alumno?.apellido || ""} ${alumno?.nombres || alumno?.nombre || ""}`.trim() || "Alumno/a";
      await sharePdfViaWhatsApp({
        blob: result.blob,
        filename: result.filename,
        text: `Hola ${nombreAlu}, te envío tu comprobante de pago.`,
        phone,
        autoDownloadInFallback: false
      });

      setMenuComprobante(null);
    } catch (e) {
      console.error("Error al enviar por WhatsApp:", e);
      alert("No se pudo preparar el envío por WhatsApp.");
    }
  }}
>
  Enviar por WhatsApp
</button>
          </div>
        )}
      </div>
    )}
  </div>
</td>

                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>

                {totalPages > 1 && (
                  <div className="mt-4 flex justify-center items-center gap-2">
                    <button onClick={() => setCurrentPage(p => Math.max(p - 1, 1))} disabled={currentPage === 1} className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50">Anterior</button>
                    <span className="text-sm text-slate-600">Página {currentPage} de {totalPages}</span>
                    <button onClick={() => setCurrentPage(p => Math.min(p + 1, totalPages))} disabled={currentPage === totalPages} className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50">Siguiente</button>
                  </div>
                )}
            </Card>
          );
        }
    
    function ControlMensual({ pagos, alumnos, perfil, onPay }) {
        const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
        const alumnosMensuales = useMemo(() => alumnos.filter(a => a.plan === 'mensual' && a.estado === 'activo'), [alumnos]);
        
        const statusMensual = useMemo(() => {
            const anioActual = new Date().getFullYear();
            const pagosDelMes = pagos.filter(p => {
                const fechaPago = new Date(p.fecha);
                return p.concepto?.startsWith("Cuota Mensual") && fechaPago.getMonth() === selectedMonth && fechaPago.getFullYear() === anioActual;
            });

            return alumnosMensuales.map(alumno => {
                const cuota = parseFloat(perfil.preciosMensuales[alumno.frecuencia] || 0);
                const pagosAlumno = pagosDelMes.filter(p => p.alumnoId === alumno.id);
                const totalPagado = pagosAlumno.reduce((acc, p) => acc + parseFloat(p.monto || 0), 0);
                
                let estado = 'Pendiente';
                if (totalPagado >= cuota) {
                    estado = 'Pagado';
                } else if (totalPagado > 0) {
                    estado = 'Parcial';
                }

                return { ...alumno, cuota, totalPagado, estado };
            });
        }, [alumnosMensuales, pagos, selectedMonth, perfil.preciosMensuales]);

        const getStatusColor = (status) => {
            if (status === 'Pagado') return 'bg-green-100 text-green-800';
            if (status === 'Parcial') return 'bg-yellow-100 text-yellow-800';
            return 'bg-red-100 text-red-800';
        };
        const FilterButton = ({ onClick, isActive, children }) => (
            <button onClick={onClick} className={`px-3 py-1 rounded-md transition-colors text-sm ${isActive ? 'bg-white shadow text-slate-800 font-semibold' : 'text-slate-500 hover:text-slate-800'}`}>
                {children}
            </button>
        );
        return (
            <Card title="Control de Cuotas Mensuales">
                {/* --- Bloque de Filtros Rediseñado --- */}
                <div className="p-3 border rounded-xl bg-slate-50 mb-4">
                    <div className="bg-slate-200 p-1 rounded-lg flex-1 flex-wrap inline-flex items-center w-full">
                         {MESES_NOMBRES.map((mes, index) => (
                            <FilterButton key={mes} onClick={() => setSelectedMonth(index)} isActive={selectedMonth === index}>{mes}</FilterButton>
                        ))}
                    </div>
                </div>

                <div className="overflow-x-auto"><table className="min-w-full text-sm"><thead><tr className="text-left text-slate-600"><th className="p-2">Alumno</th><th className="p-2">Plan</th><th className="p-2">Monto Cuota</th><th className="p-2">Monto Pagado</th><th className="p-2">Estado</th><th className="p-2 text-right">Acciones</th></tr></thead><tbody>
                    {statusMensual.length === 0 && (<tr><td colSpan={6} className="text-center py-6 text-slate-400">No hay alumnos con plan mensual</td></tr>)}
                    {statusMensual.map(a => (
                        <tr key={a.id} className="border-t">
                            <td className="p-2">{`${a.apellido || ''} ${a.nombre || ''}`.trim()}</td>
                            <td className="p-2">{FRECUENCIAS_MENSUALES.find(f => f.value === a.frecuencia)?.label}</td>
                            <td className="p-2">{formatCurrency(a.cuota)}</td>
                            <td className="p-2">{formatCurrency(a.totalPagado)}</td>
                            <td className="p-2"><span className={`px-2 py-0.5 rounded-full text-xs ${getStatusColor(a.estado)}`}>{a.estado}</span></td>
                            <td className="p-2 text-right">
                                {a.estado !== 'Pagado' && <button onClick={() => onPay(a, selectedMonth)} className="px-2 py-1 text-xs rounded-lg border bg-emerald-500 text-white">Registrar Pago</button>}
                            </td>
                        </tr>
                    ))}
                </tbody></table></div>
            </Card>
        );
    }
    
    function ControlDeudas({ pagos, alumnos, clases, perfil }) {
        const getNombreCompleto = (a) => a ? `${a.apellido || ''} ${a.nombre || ''}`.trim() : '??';
        
        const deudas = useMemo(() => {
            const deudores = [];
            const hoy = new Date();
            const mesActual = hoy.getMonth();
            const anioActual = hoy.getFullYear();

            const alumnosMensuales = alumnos.filter(a => a.plan === 'mensual' && a.estado === 'activo');
            const pagosMensuales = pagos.filter(p => p.concepto?.startsWith("Cuota Mensual"));

            alumnosMensuales.forEach(alumno => {
                const cuota = parseFloat(perfil.preciosMensuales[alumno.frecuencia] || 0);
                const pagosDelMes = pagosMensuales.filter(p => {
                    const fechaPago = new Date(p.fecha);
                    return p.alumnoId === alumno.id && fechaPago.getMonth() === mesActual && fechaPago.getFullYear() === anioActual;
                });
                const totalPagado = pagosDelMes.reduce((acc, p) => acc + parseFloat(p.monto || 0), 0);
                const deuda = cuota - totalPagado;
                if (deuda > 0) {
                    deudores.push({ id: alumno.id, nombre: getNombreCompleto(alumno), tipo: 'Cuota Mensual', monto: deuda });
                }
            });

            const pagosPorClaseMap = new Map();
            pagos.filter(p => p.claseId).forEach(p => {
                if(!pagosPorClaseMap.has(p.claseId)) pagosPorClaseMap.set(p.claseId, 0);
                pagosPorClaseMap.set(p.claseId, pagosPorClaseMap.get(p.claseId) + parseFloat(p.monto || 0));
            });
            const clasesRealizadas = clases.filter(c => c.estado === 'Realizada' && new Date(c.fecha) <= hoy);
            
            clasesRealizadas.forEach(clase => {
                const totalPagado = pagosPorClaseMap.get(clase.id) || 0;
                const precioClase = parseFloat(clase.precio || 0);

                if (totalPagado < precioClase) {
                    clase.alumnoIds.forEach(alumnoId => {
                        const alumno = alumnos.find(a => a.id === alumnoId);
                        if (alumno && alumno.plan === 'porClase') {
                            // Este cálculo asume que la deuda se reparte equitativamente.
                            const deudaClase = precioClase - totalPagado;
                            const monto = deudaClase / clase.alumnoIds.length;
                            deudores.push({ id: `${clase.id}-${alumno.id}`, nombre: getNombreCompleto(alumno), tipo: `Clase ${clase.fecha}`, monto });
                        }
                    });
                }
            });
            
            const deudasAgrupadas = deudores.reduce((acc, deuda) => {
                const alumnoId = alumnos.find(a => getNombreCompleto(a) === deuda.nombre)?.id || deuda.nombre;
                if(!acc[alumnoId]) acc[alumnoId] = { nombre: deuda.nombre, total: 0, detalles: [] };
                acc[alumnoId].total += deuda.monto;
                acc[alumnoId].detalles.push({ tipo: deuda.tipo, monto: deuda.monto });
                return acc;
            }, {});
            
            return Object.values(deudasAgrupadas).sort((a,b) => b.total - a.total);

        }, [pagos, alumnos, clases, perfil]);
        
        return (
            <Card title="Control de Deudas Pendientes (Mes Actual)">
                 <div className="overflow-x-auto"><table className="min-w-full text-sm"><thead><tr className="text-left text-slate-600"><th className="p-2">Alumno</th><th className="p-2">Detalle de Deuda</th><th className="p-2 text-right">Total Adeudado</th></tr></thead><tbody>
                    {deudas.length === 0 && (<tr><td colSpan={3} className="text-center py-6 text-slate-400">No hay deudas pendientes registradas para el mes actual.</td></tr>)}
                    {deudas.map(deuda => (
                        <tr key={deuda.nombre} className="border-t">
                            <td className="p-2 font-semibold">{deuda.nombre}</td>
                            <td className="p-2">
                                <ul className="list-disc list-inside">
                                {deuda.detalles.map((d, i) => (
                                    <li key={i}>{d.tipo}: <span className="font-medium">{formatCurrency(d.monto)}</span></li>
                                ))}
                                </ul>
                            </td>
                            <td className="p-2 font-semibold text-red-600 text-right">{formatCurrency(deuda.total)}</td>
                        </tr>
                    ))}
                </tbody></table></div>
            </Card>
        );
    }


function HistorialPorAlumno({ pagos = [], alumnos = [] }) {
  const [fechaDesde, setFechaDesde] = React.useState("");
  const [fechaHasta, setFechaHasta] = React.useState("");
  const [metodo, setMetodo] = React.useState("Todos");
  const [q, setQ] = React.useState("");
  const [expandedId, setExpandedId] = React.useState(null);

  // === Nuevos estados para paginación ===
  const [currentPage, setCurrentPage] = React.useState(1);
  const ITEMS_PER_PAGE = 10; // Puedes ajustar este valor si lo deseas

  const alumnoMap = React.useMemo(() => new Map(alumnos.map(a => [a.id, a])), [alumnos]);

  const normNum = (v) => {
    if (v == null) return 0;
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  const formatMoney = (n) => new Intl.NumberFormat("es-AR", { style: "currency", currency: "ARS", maximumFractionDigits: 0 }).format(normNum(n));
  const getName = (a) => (a ? getNombreCompleto(a) : "");

  const pagosFiltrados = React.useMemo(() => {
    return pagos.filter(p => {
      if (fechaDesde && String(p.fecha) < fechaDesde) return false;
      if (fechaHasta && String(p.fecha) > fechaHasta) return false;
      if (metodo !== "Todos" && (p.metodo || "") !== metodo) return false;
      if (q) {
        const nombre = getName(alumnoMap.get(p.alumnoId)) || "";
        if (!nombre.toLowerCase().includes(q.toLowerCase())) return false;
      }
      return true;
    });
  }, [pagos, fechaDesde, fechaHasta, metodo, q, alumnoMap]);

  const filas = React.useMemo(() => {
    const acc = new Map();
    for (const p of pagosFiltrados) {
      const id = p.alumnoId || "_sin_";
      const alumno = alumnoMap.get(p.alumnoId);
      const nombre = alumno ? getName(alumno) : (p.nombreAlumno || "—");
      const cur = acc.get(id) || { alumnoId: id, nombre, efectivo: 0, transferencia: 0, mensual: 0, pendiente: 0, total: 0, items: [] };

      const m = String(p.metodo || "");
      const monto = normNum(p.monto);

      if (m === "Efectivo") {
        cur.efectivo += monto;
      } else if (m === "Transferencia") {
        cur.transferencia += monto;
      } else if (m === "Mensual") {
        cur.mensual += monto;
      } else if (m === "Mixto" && p.detalleMixto) {
        cur.efectivo += normNum(p.detalleMixto.efectivo);
        cur.transferencia += normNum(p.detalleMixto.transferencia);
      } else if (m === "Pendiente") {
        cur.pendiente += monto;
      } else {
        cur.total += monto;
      }

      cur.total = cur.efectivo + cur.transferencia + cur.mensual;
      cur.items.push(p);
      acc.set(id, cur);
    }
    return Array.from(acc.values()).sort((a, b) => b.total - a.total);
  }, [pagosFiltrados, alumnoMap]);

  // === Lógica de paginación ===
  const totalPages = Math.ceil(filas.length / ITEMS_PER_PAGE);
  const paginatedFilas = React.useMemo(() => {
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    return filas.slice(startIndex, startIndex + ITEMS_PER_PAGE);
  }, [filas, currentPage]);

  React.useEffect(() => {
    setCurrentPage(1);
  }, [q, fechaDesde, fechaHasta, metodo]);

  return (
    <div className="space-y-3">
      <div className="grid gap-2 md:grid-cols-4">
        <div>
          <label className="block text-xs text-slate-500">Alumno</label>
          <input value={q} onChange={e => setQ(e.target.value)} placeholder="Buscar por nombre…" className="w-full border rounded-lg px-3 py-2" />
        </div>
        <div>
          <label className="block text-xs text-slate-500">Desde</label>
          <input type="date" value={fechaDesde} onChange={e => setFechaDesde(e.target.value)} className="w-full border rounded-lg px-3 py-2" />
        </div>
        <div>
          <label className="block text-xs text-slate-500">Hasta</label>
          <input type="date" value={fechaHasta} onChange={e => setFechaHasta(e.target.value)} className="w-full border rounded-lg px-3 py-2" />
        </div>
        <div>
          <label className="block text-xs text-slate-500">Método</label>
          <select value={metodo} onChange={e => setMetodo(e.target.value)} className="w-full border rounded-lg px-3 py-2">
            <option>Todos</option>
            <option>Efectivo</option>
            <option>Transferencia</option>
            <option>Mensual</option>
            <option>Pendiente</option>
          </select>
        </div>
      </div>

      <div className="overflow-x-auto rounded-xl border border-slate-200">
        <table className="min-w-full text-sm">
          <thead className="bg-slate-50">
            <tr>
              <th className="text-left p-2">Alumno</th>
              <th className="text-right p-2">Efectivo</th>
              <th className="text-right p-2">Transferencia</th>
              <th className="text-right p-2">Mensual</th>
              <th className="text-right p-2">Total</th>
              <th className="p-2"></th>
            </tr>
          </thead>
          <tbody>
            {paginatedFilas.length === 0 ? (
              <tr><td className="p-3 text-slate-400" colSpan={6}>Sin movimientos en el período.</td></tr>
            ) : paginatedFilas.map(row => (
              <React.Fragment key={row.alumnoId}>
                <tr className="border-t">
                  <td className="p-2">{row.nombre}</td>
                  <td className="p-2 text-right">{formatMoney(row.efectivo)}</td>
                  <td className="p-2 text-right">{formatMoney(row.transferencia)}</td>
                  <td className="p-2 text-right">{formatMoney(row.mensual)}</td>
                  <td className="p-2 text-right font-semibold">{formatMoney(row.total)}</td>
                  <td className="p-2 text-right">
                    <button onClick={() => setExpandedId(expandedId === row.alumnoId ? null : row.alumnoId)} className="text-xs px-2 py-1 rounded-md border hover:bg-slate-50">
                      {expandedId === row.alumnoId ? "Ocultar" : "Ver detalle"}
                    </button>
                  </td>
                </tr>
                {expandedId === row.alumnoId && (
                  <tr className="bg-white">
                    <td colSpan={6} className="p-0">
                      <div className="overflow-x-auto">
                        <table className="min-w-full text-xs">
                          <thead className="bg-slate-50">
                            <tr>
                              <th className="text-left p-2">Fecha</th>
                              <th className="text-left p-2">Concepto</th>
                              <th className="text-left p-2">Método</th>
                              <th className="text-right p-2">Monto</th>
                            </tr>
                          </thead>
                          <tbody>
                            {row.items.slice().sort((a, b) => String(b.fecha).localeCompare(String(a.fecha))).map((p, i) => (
                              <tr key={i} className="border-t">
                                <td className="p-2">{p.fecha}</td>
                                <td className="p-2">{p.concepto || "Pago Clase"}</td>
                                <td className="p-2">{p.metodo}</td>
                                <td className="p-2 text-right">{formatMoney(p.monto)}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </td>
                  </tr>
                )}
              </React.Fragment>
            ))}
          </tbody>
        </table>
      </div>

      {totalPages > 1 && (
        <div className="mt-4 flex justify-center items-center gap-2">
          <button
            onClick={() => setCurrentPage(p => Math.max(p - 1, 1))}
            disabled={currentPage === 1}
            className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
          >
            Anterior
          </button>
          <span className="text-sm text-slate-600">
            Página {currentPage} de {totalPages}
          </span>
          <button
            onClick={() => setCurrentPage(p => Math.min(p + 1, totalPages))}
            disabled={currentPage === totalPages}
            className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
          >
            Siguiente
          </button>
        </div>
      )}
    </div>
  );
}


function Gastos({ gastos, onCreate, onUpdate, onDelete }) {
  const [showForm, setShowForm] = useState(false);
  const [editing, setEditing] = useState(null);
  const emptyForm = { fecha: formatDate(new Date()), concepto: "", monto: "", categoria: "Varios" };
  const [form, setForm] = useState(emptyForm);
  const [periodo, setPeriodo] = useState("mes");
  const [currentPage, setCurrentPage] = useState(1);
  const ITEMS_PER_PAGE = 10;

  // ✅ FIX: sin JSX adentro
  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  const gastosFiltrados = useMemo(() => {
    const ahora = new Date();
    const hoy = formatDate(ahora);
    const semanaInicio = formatDate(getWeekStartDate(ahora));
    const mesInicio = formatDate(new Date(ahora.getFullYear(), ahora.getMonth(), 1));
    const anioInicio = formatDate(new Date(ahora.getFullYear(), 0, 1));

    return gastos
      .filter(g => {
        if (periodo === 'dia' && g.fecha !== hoy) return false;
        if (periodo === 'semana' && g.fecha < semanaInicio) return false;
        if (periodo === 'mes' && g.fecha < mesInicio) return false;
        if (periodo === 'año' && g.fecha < anioInicio) return false;
        return true;
      })
      .sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
  }, [gastos, periodo]);

  const totalGastos = useMemo(
    () => gastosFiltrados.reduce((acc, g) => acc + (parseFloat(g.monto || 0) || 0), 0),
    [gastosFiltrados]
  );

  const totalPages = Math.ceil(gastosFiltrados.length / ITEMS_PER_PAGE);
  const paginatedGastos = useMemo(() => {
    const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
    return gastosFiltrados.slice(startIndex, startIndex + ITEMS_PER_PAGE);
  }, [gastosFiltrados, currentPage]);

  useEffect(() => {
    setCurrentPage(1);
  }, [periodo]);

  function openNew() { setEditing(null); setForm(emptyForm); setShowForm(true); }
  function openEdit(g) { setEditing(g); setForm(g); setShowForm(true); }
  function cancel() { setShowForm(false); setEditing(null); setForm(emptyForm); }
  function submit(e) {
    e.preventDefault();
    if (!form.concepto.trim() || !form.monto) return alert("Completá concepto y monto");
    if (editing) { onUpdate({ ...form, id: editing.id }); } else { onCreate(form); }
    cancel();
  }

  const PeriodoButton = ({ value, current, setter, children }) => (
    <button
      onClick={() => setter(value)}
      className={`px-3 py-1.5 text-sm rounded-lg ${
        current === value
          ? 'bg-[#34745B] text-white hover:bg-green-800'
          : 'bg-white border text-slate-700 hover:bg-slate-50'
      }`}
    >
      {children}
    </button>
  );

  return (
    <div className="grid gap-4">
      <Card
        title={<span className="text-[#34745B]">{editing ? "Editar gasto" : "Nuevo gasto"}</span>}
        right={!showForm && (
          <button
            onClick={openNew}
            className="bg-[#34745B] hover:bg-green-800 text-white text-sm px-3 py-1.5 rounded-xl"
          >
            + Nuevo
          </button>
        )}
      >
        {showForm ? (
          <form onSubmit={submit} className="grid md:grid-cols-6 gap-3">
            <div className="md:col-span-3">
              <label className="text-sm text-slate-600">Fecha</label>
              <input
                type="date"
                name="fecha"
                value={form.fecha}
                onChange={handleChange}
                className="w-full border rounded-lg px-3 py-2"
                required
              />
            </div>

            <div className="md:col-span-3">
              <label className="text-sm text-slate-600">Concepto</label>
              <input
                type="text"
                name="concepto"
                value={form.concepto}
                onChange={handleChange}
                className="w-full border rounded-lg px-3 py-2"
                placeholder="Ej: Alquiler de cancha"
                required
              />
            </div>

            <div className="md:col-span-3">
              <label className="text-sm text-slate-600">Monto</label>
              <input
                type="number"
                name="monto"
                value={form.monto}
                onChange={handleChange}
                className="w-full border rounded-lg px-3 py-2"
                placeholder="Ej: 1500"
                required
              />
            </div>

            <div className="md:col-span-3">
              <label className="text-sm text-slate-600">Categoría</label>
              <select
                name="categoria"
                value={form.categoria}
                onChange={handleChange}
                className="w-full border rounded-lg px-3 py-2"
              >
                {CATEGORIAS_GASTOS.map(c => <option key={c}>{c}</option>)}
              </select>
            </div>

            <div className="md:col-span-6 flex gap-2 justify-end">
              <button type="button" onClick={cancel} className="px-3 py-2 rounded-lg border">
                Cancelar
              </button>
              <button type="submit" className="px-3 py-2 rounded-lg bg-[#34745B] hover:bg-green-800 text-white">
                Guardar
              </button>
            </div>
          </form>
        ) : (
          <p className="text-sm text-slate-500">
            Hacé clic en <b>+ Nuevo</b> para registrar un gasto.
          </p>
        )}
      </Card>

      <Card title={<span className="text-[#34745B]">Control de Gastos</span>}>
        <div className="flex flex-wrap items-center gap-2 mb-4">
          <PeriodoButton value="dia" current={periodo} setter={setPeriodo}>Hoy</PeriodoButton>
          <PeriodoButton value="semana" current={periodo} setter={setPeriodo}>Semana</PeriodoButton>
          <PeriodoButton value="mes" current={periodo} setter={setPeriodo}>Mes</PeriodoButton>
          <PeriodoButton value="año" current={periodo} setter={setPeriodo}>Año</PeriodoButton>
        </div>

        <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl mb-4">
          <p className="text-sm text-slate-600">Total de Gastos</p>
          <p className="text-2xl font-bold text-slate-800">{formatCurrency(totalGastos)}</p>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="text-left text-slate-600">
                <th className="p-2">Fecha</th>
                <th className="p-2">Concepto</th>
                <th className="p-2">Monto</th>
                <th className="p-2">Categoría</th>
                <th className="p-2 text-right">Acciones</th>
              </tr>
            </thead>
            <tbody>
              {paginatedGastos.length === 0 && (
                <tr>
                  <td colSpan={5} className="text-center py-6 text-slate-400">
                    No hay gastos en este período
                  </td>
                </tr>
              )}
              {paginatedGastos.map(g => (
                <tr key={g.id} className="border-t">
                  <td className="p-2">{g.fecha}</td>
                  <td className="p-2">{g.concepto}</td>
                  <td className="p-2">${g.monto}</td>
                  <td className="p-2">{g.categoria}</td>
                  <td className="p-2 text-right">
                    <div className="inline-flex gap-2">
                      <button onClick={() => openEdit(g)} className="px-2 py-1 text-xs rounded-lg border hover:bg-slate-50">✏️ Editar</button>
                      <button type="button" onClick={() => onDelete(g.id)} className="px-2 py-1 text-xs rounded-lg border text-red-600 hover:bg-red-50">🗑️ Eliminar</button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {totalPages > 1 && (
          <div className="mt-4 flex justify-center items-center gap-2">
            <button
              onClick={() => setCurrentPage(p => Math.max(p - 1, 1))}
              disabled={currentPage === 1}
              className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
            >
              Anterior
            </button>
            <span className="text-sm text-slate-600">
              Página {currentPage} de {totalPages}
            </span>
            <button
              onClick={() => setCurrentPage(p => Math.min(p + 1, totalPages))}
              disabled={currentPage === totalPages}
              className="px-3 py-1 text-sm border rounded-lg disabled:opacity-50"
            >
              Siguiente
            </button>
          </div>
        )}
      </Card>
    </div>
  );
}

    
    function GraficoBarras({ data }) {
      const maxValue = useMemo(() => Math.max(...data.map(d => d.value), 1), [data]);
      return (
        <div className="bg-slate-50 rounded-xl p-4 h-64 flex justify-around items-end gap-4">
          {data.map(item => (
            <div key={item.label} className="flex-1 flex flex-col items-center gap-2">
              <div className="text-sm font-semibold text-slate-700">{formatCurrency(item.value)}</div>
              <div 
  className={`w-full rounded-t-lg ${item.color}`} 
  style={{ height: `${(item.value / maxValue) * 80}%` }} 
  title={`${item.label}: ${formatCurrency(item.value)}`}
></div>
              <div className="text-xs font-medium text-slate-600">{item.label}</div>
            </div>
          ))}
        </div>
      );
    }
    
function Reportes({ pagos, gastos, alumnos, clases, clubActivoId, clubes, perfil }) {
      const [periodo, setPeriodo] = useState("dia"); // Inicia por defecto en "Hoy"
      const [mesSeleccionado, setMesSeleccionado] = useState(formatDate(new Date()).slice(0, 7));
      const [fechaSeleccionada, setFechaSeleccionada] = useState(formatDate(new Date()));

      const filterByPeriod = useMemo(() => {
        return (item) => {
            const ahora = new Date();
            const itemDate = new Date(`${item.fecha}T00:00:00`);
            
            if (periodo === 'dia') return formatDate(itemDate) === formatDate(ahora);
            if (periodo === 'customDay') return formatDate(itemDate) === fechaSeleccionada;
            if (periodo === 'semana') return getWeekStartDate(itemDate).getTime() === getWeekStartDate(ahora).getTime();
            if (periodo === 'customMonth' && mesSeleccionado) {
                const [year, month] = mesSeleccionado.split('-');
                return itemDate.getFullYear() === parseInt(year) && (itemDate.getMonth() + 1) === parseInt(month);
            }
            if(periodo === 'mes') {
                return itemDate.getMonth() === ahora.getMonth() && itemDate.getFullYear() === ahora.getFullYear();
            }
            return false;
        };
      }, [periodo, mesSeleccionado, fechaSeleccionada]);

      const [pagosFiltrados, gastosFiltrados, clasesFiltradas] = useMemo(() => {
        const pagosF = pagos.filter(p => p.metodo !== 'Pendiente').filter(filterByPeriod);
        const gastosF = gastos.filter(filterByPeriod);
        const clasesF = clases.filter(c => c.estado === 'Realizada').filter(filterByPeriod);
        return [pagosF, gastosF, clasesF];
      }, [pagos, gastos, clases, filterByPeriod]);
      
      const totales = useMemo(() => {
        const totalIngresos = pagosFiltrados.reduce((acc, p) => acc + (parseFloat(p.monto) || 0), 0);
        const totalGastos = gastosFiltrados.reduce((acc, g) => acc + (parseFloat(g.monto) || 0), 0);
        return { ingresos: totalIngresos, gastos: totalGastos, balance: totalIngresos - totalGastos };
      }, [pagosFiltrados, gastosFiltrados]);
      
      const distribucionIngresos = useMemo(() => {
        const clubActivo = clubActivoId ? clubes.find(c => c.id === clubActivoId) : null;
        const porcentajeProfesor = clubActivo ? (clubActivo.reparto.coach || 0) / 100 : 1;
        const porcentajeClub = clubActivo ? (clubActivo.reparto.club || 0) / 100 : 0;
        const ingresosDeClases = pagosFiltrados
            .filter(p => p.claseId)
            .reduce((acc, p) => acc + (parseFloat(p.monto) || 0), 0);
        return {
            nombreLugar: clubActivo ? clubActivo.nombre : "Independiente",
            repartoTexto: clubActivo ? `${clubActivo.reparto.coach}% / ${clubActivo.reparto.club}%` : "100% Profesor",
            gananciaProfesor: ingresosDeClases * porcentajeProfesor,
            gananciaClub: ingresosDeClases * porcentajeClub,
            hayReparto: !!clubActivo
        };
      }, [pagosFiltrados, clubActivoId, clubes]);

const resumenClasesMes = useMemo(() => {
  const conteoPorTipo = clasesFiltradas.reduce((acc, clase) => {
    const tipoCanonico = normalizarTipoClase(clase.tipo || 'Clase 1 persona');
    const precio = parseFloat(clase.precio || 0);
    if (!acc[tipoCanonico]) {
      acc[tipoCanonico] = { cantidad: 0, valorTotal: 0 };
    }
    acc[tipoCanonico].cantidad += 1;
    acc[tipoCanonico].valorTotal += precio;
    return acc;
  }, {});

  return {
    totalClases: clasesFiltradas.length,
    valorTotalGeneral: clasesFiltradas.reduce((acc, c) => acc + parseFloat(c.precio || 0), 0),
    detalle: Object.entries(conteoPorTipo).sort((a, b) => b[1].cantidad - a[1].cantidad)
  };
}, [clasesFiltradas]);

      const PeriodoButton = ({ value, children }) => (
        <button 
            onClick={() => setPeriodo(value)} 
            className={`px-3 py-1.5 text-sm rounded-lg ${periodo === value ? 'bg-[#34745B] text-white hover:bg-green-800' : 'bg-white border text-slate-700 hover:bg-slate-50'}`}
        >
            {children}
        </button>
      );

      const handleExportToPDF = () => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    const nombreProfesor = `${perfil.nombre || ''} ${perfil.apellido || ''}`.trim();
    const nombreLugar = distribucionIngresos.nombreLugar;
    let periodoTexto = "";

    // Correction 1: Dynamically determine the report period text.
    if (periodo === 'dia') {
        periodoTexto = `el día de hoy (${formatDate(new Date(), 'dd/mm')})`;
    } else if (periodo === 'customDay') {
        periodoTexto = `el día ${formatDate(new Date(fechaSeleccionada + 'T00:00:00'), 'dd/mm')}`;
    } else if (periodo === 'semana') {
        periodoTexto = `la semana actual`;
    } else if (periodo === 'mes') {
        const currentMonthName = MESES_NOMBRES[new Date().getMonth()];
        const currentYear = new Date().getFullYear();
        periodoTexto = `el mes de ${currentMonthName} de ${currentYear}`;
    } else if (periodo === 'customMonth' && mesSeleccionado) {
        const [year, month] = mesSeleccionado.split('-');
        const selectedMonthName = MESES_NOMBRES[parseInt(month) - 1];
        periodoTexto = `el mes de ${selectedMonthName} de ${year}`;
    }

    let finalY = 20;
    doc.setFontSize(18);
    doc.text("Reporte de Actividad", 14, finalY);
    finalY += 10;
    doc.setFontSize(11);
    doc.text(`Profesor/a: ${nombreProfesor}`, 14, finalY);
    finalY += 6;
    doc.text(`Lugar de Trabajo: ${nombreLugar}`, 14, finalY);
    finalY += 6;
    doc.text(`Período del Reporte: ${periodoTexto}`, 14, finalY);
    finalY += 10;
    doc.setFontSize(14);
    doc.text("Resumen de Clases Realizadas", 14, finalY);
    finalY += 8;
    doc.setFontSize(11);
    doc.text(`Total de Clases: ${resumenClasesMes.totalClases}`, 14, finalY);
    doc.text(`Valor Bruto Generado: ${formatCurrency(resumenClasesMes.valorTotalGeneral)}`, 100, finalY);
    finalY += 6;
    const tableHead = [['Tipo de Clase', 'Cantidad', 'Valor Generado']];
    
    // Correction 2: Sort the class types alphabetically before mapping.
    const tableBody = resumenClasesMes.detalle
    .sort(([tipoA], [tipoB]) => (TIPOS_CLASE_NOMBRES[tipoA] || tipoA).localeCompare(TIPOS_CLASE_NOMBRES[tipoB] || tipoB))
    .map(([tipo, data]) => [
        TIPOS_CLASE_NOMBRES[tipo] || tipo,
        data.cantidad,
        `${formatCurrency(data.valorTotal)}`
    ]);

    doc.autoTable({ head: tableHead, body: tableBody, startY: finalY, theme: 'grid' });
    finalY = doc.autoTable.previous.finalY + 12;
    doc.setFontSize(14);
    doc.text("Distribución de Ingresos", 14, finalY);
    finalY += 8;
    doc.setFontSize(11);
    doc.text(`(Reparto: ${distribucionIngresos.repartoTexto})`, 14, finalY);
    finalY += 8;
    doc.text(`Ganancia Neta Profesor: ${formatCurrency(distribucionIngresos.gananciaProfesor)}`, 14, finalY);
    finalY += 8;
    doc.text(`Ganancia Club: ${formatCurrency(distribucionIngresos.gananciaClub)}`, 14, finalY);
    doc.save(`Reporte_${nombreLugar.replace(/ /g, '_')}_${periodo === 'customDay' ? fechaSeleccionada : mesSeleccionado}.pdf`);
};
      
      return (
        <div className="grid gap-6">
          <Card title={<span className="text-[#34745B]">Reportes Financieros y Operativos</span>}>
            <div className="flex flex-wrap items-center gap-x-4 gap-y-2 mb-4">
              <div className="flex items-center gap-2">
                <PeriodoButton value="dia">Hoy</PeriodoButton>
                <PeriodoButton value="semana">Esta Semana</PeriodoButton>
                <PeriodoButton value="mes">Este Mes</PeriodoButton>
              </div>
              <div className="flex items-center gap-2">
                <label htmlFor="fecha-reporte" className="text-sm text-slate-600">Ver día:</label>
                <input
                    type="date"
                    id="fecha-reporte"
                    value={fechaSeleccionada}
                    onChange={(e) => {
                        setFechaSeleccionada(e.target.value);
                        setPeriodo('customDay');
                    }}
                    className="border rounded-lg px-3 py-1.5 text-sm"
                />
              </div>
              <div className="flex items-center gap-2">
                <label htmlFor="mes-reporte" className="text-sm text-slate-600">Ver mes:</label>
                <input
                    type="month"
                    id="mes-reporte"
                    value={mesSeleccionado}
                    onChange={(e) => {
                        setMesSeleccionado(e.target.value);
                        setPeriodo('customMonth');
                    }}
                    className="border rounded-lg px-3 py-1.5 text-sm"
                />
              </div>
              <div className="flex-grow text-right">
                <button 
                  onClick={handleExportToPDF} 
                  className="px-4 py-2 text-sm rounded-lg bg-white border border-[#34745B] text-[#34745B] hover:bg-green-50 font-semibold"
                >
                  Descargar PDF
                </button>
              </div>
            </div>
            
            <div className="p-4 border rounded-xl bg-slate-50">
                <h3 className="text-lg font-semibold text-[#4A4A4A] mb-3">Resumen Financiero General</h3>
                <div className="grid md:grid-cols-3 gap-4">
                  <div className="bg-green-50 border border-green-200 p-4 rounded-xl"><p className="text-sm text-green-800">Total Ingresos</p><p className="text-2xl font-bold text-[#34745B]">{formatCurrency(totales.ingresos)}</p></div>
                  <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl"><p className="text-sm text-slate-600">Total Gastos</p><p className="text-2xl font-bold text-slate-800">{formatCurrency(totales.gastos)}</p></div>
                  <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl"><p className="text-sm text-slate-600">Balance Neto</p><p className={`text-2xl font-bold ${totales.balance >= 0 ? 'text-slate-800' : 'text-red-900'}`}>{formatCurrency(totales.balance)}</p></div>
                </div>
            </div>

            <div className="p-4 border rounded-xl bg-slate-50 mt-4">
                <div className="mb-3">
                    <h3 className="text-lg font-semibold text-[#4A4A4A]">Distribución de Ingresos por Clases</h3>
                    <p className="text-sm text-slate-500">Resultados para: <span className="font-bold">{distribucionIngresos.nombreLugar}</span> (Reparto: {distribucionIngresos.repartoTexto})</p>
                </div>
                <div className="grid md:grid-cols-2 gap-4">
                  <div className="bg-green-50 border border-green-200 p-4 rounded-xl"><p className="text-sm text-green-800">Ganancia Neta Profesor</p><p className="text-2xl font-bold text-[#34745B]">{formatCurrency(distribucionIngresos.gananciaProfesor)}</p></div>
                  <div className="bg-slate-100 border border-slate-200 p-4 rounded-xl"><p className="text-sm text-slate-600">Ganancia Club</p><p className="text-2xl font-bold text-slate-800">{formatCurrency(distribucionIngresos.gananciaClub)}</p></div>
                </div>
                {!distribucionIngresos.hayReparto && <p className="text-xs text-slate-400 mt-2">En modo independiente, todos los ingresos de clases se consideran ganancia del profesor.</p>}
            </div>

            <div className="p-4 border rounded-xl bg-slate-50 mt-4">
                <h3 className="text-lg font-semibold text-[#4A4A4A]">Resumen de Clases Realizadas</h3>
                <p className="text-sm text-slate-500">Resultados para el período seleccionado</p>
                {resumenClasesMes.totalClases > 0 ? (
                    <div className="mt-3">
                        <div className="flex items-center justify-between border-b pb-2 mb-2">
                            <div>
                                <p className="text-slate-600">Total de Clases</p>
                                <p className="text-3xl font-bold text-[#34745B]">{resumenClasesMes.totalClases}</p>
                            </div>
                            <div className="text-right">
                                <p className="text-slate-600">Valor Generado por Clases</p>
                                <p className="text-3xl font-bold text-[#34745B]">{formatCurrency(resumenClasesMes.valorTotalGeneral)}</p>
                            </div>
                        </div>
                        <ul className="text-sm text-slate-700 mt-2 space-y-2">
                            {resumenClasesMes.detalle.map(([tipo, data]) => (
                                <li key={tipo} className="flex justify-between items-center bg-white p-2 rounded-md">
                                    <span>
                                        <strong>{data.cantidad}</strong> {data.cantidad > 1 ? 'clases' : 'clase'} de <strong>{labelSinClase(tipo)}</strong>
                                    </span>
                                    <span className="font-semibold text-slate-800">
                                        {formatCurrency(data.valorTotal)}
                                    </span>
                                </li>
                            ))}
                        </ul>
                    </div>
                ) : (
                    <p className="text-sm text-slate-500 mt-4">No se encontraron clases realizadas en este período.</p>
                )}
            </div>
          </Card>
        </div>
      );
    }
    // Pega esta nueva función en tu archivo

function GestionClubes({ user }) {
  const [clubes, setClubes] = useState([]);
  const [activoId, setActivoId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [form, setForm] = useState({
    nombre: "",
    modalidadPrincipal: "por_clase",
    ubicaciones: [],
    reparto: { coach: 60, club: 40 },
    preciosClase: { individual: 0, dupla: 0, trio: 0, cuarteto: 0, escuelita: 0 },
    preciosMensuales: { "1xSemana": 0, "2xSemana": 0, "3xSemana": 0, "libre": 0 },
    horarioLaboral: { bloques: [] }
  });

  const clubsCollection = useMemo(() => {
    if (!user) return null;
    return db.collection('users').doc(user.uid).collection('clubs');
  }, [user]);

  // Cargar clubes + seleccionar primero
  useEffect(() => {
    if (!clubsCollection) return;
    setLoading(true);
    const unsubscribe = clubsCollection.onSnapshot(snapshot => {
      const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setClubes(data);
      if (!activoId && data.length) setActivoId(data[0].id);
      setLoading(false);
    });
    return () => unsubscribe();
  }, [clubsCollection]);

  // Cargar datos del club activo al form
  useEffect(() => {
    if (!activoId || !clubsCollection) return;
    const unsub = clubsCollection.doc(activoId).onSnapshot(doc => {
      const d = doc.data() || {};
      setForm({
        nombre: d.nombre || "",
        modalidadPrincipal: d.modalidadPrincipal || "por_clase",
        ubicaciones: d.ubicaciones || [],
        reparto: d.reparto || { coach: 60, club: 40 },
        preciosClase: { individual: 0, dupla: 0, trio: 0, cuarteto: 0, escuelita: 0, ...(d.preciosClase||{}) },
        preciosMensuales: { "1xSemana": 0, "2xSemana": 0, "3xSemana": 0, "libre": 0, ...(d.preciosMensuales||{}) },
        horarioLaboral: d.horarioLaboral || { bloques: [] },
      });
    });
    return () => unsub();
  }, [activoId, clubsCollection]);

  async function crearClub() {
  // ⬇️ Agregado: refrescar usuario y exigir email verificado
  const u = auth.currentUser;
if (!u) return;
await u.reload();
const t = await u.getIdTokenResult();
if (!t.claims.email_verified) { alert("Verificá tu email para continuar"); return; }
await u.getIdToken(true);

  if (!clubsCollection) return;
  const base = {
    nombre: "Nuevo Club",
    modalidadPrincipal: "por_clase",
    ubicaciones: [],
    reparto: { coach: 60, club: 40 },
    preciosClase: { individual: 0, dupla: 0, trio: 0, cuarteto: 0, escuelita: 0 },
    preciosMensuales: { "1xSemana": 0, "2xSemana": 0, "3xSemana": 0, "libre": 0 },
    horarioLaboral: { bloques: [] },
    createdAt: new Date().toISOString()
  };
  const ref = await clubsCollection.add(base);
  setActivoId(ref.id);
}

  async function eliminarClub(id) {
    if (!clubsCollection || !id) return;
    if (!confirm("¿Eliminar este club? Esta acción no se puede deshacer.")) return;
    await clubsCollection.doc(id).delete();
    if (activoId === id) {
      const rest = clubes.filter(c => c.id !== id);
      setActivoId(rest[0]?.id || null);
    }
  }

  async function guardarClub() {
  // ⬇️ Agregado: refrescar usuario y exigir email verificado
  const u = auth.currentUser;
if (!u) return;
await u.reload();
const t = await u.getIdTokenResult();
if (!t.claims.email_verified) { alert("Verificá tu email para continuar"); return; }
await u.getIdToken(true);
  if (!clubsCollection || !activoId) {
    alert("No hay club activo");
    return;
  }
  await clubsCollection
    .doc(activoId)
    .set({ ...form, updatedAt: new Date().toISOString() }, { merge: true });
// Después de guardar el doc del club:
const baseRef = clubsCollection.doc(activoId);

// Sincronizá los precios al Perfil del Club
await baseRef.collection('perfil').doc('main').set({
  preciosClase: form.preciosClase || {},
  preciosMensuales: form.preciosMensuales || {},
  updatedAt: new Date().toISOString(),
}, { merge: true });

  alert("Configuración del club guardada");
}

  // UI helpers
  const dias = ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"];
  const setField = (k, v) => setForm(f => ({ ...f, [k]: v }));
  function addUbicacion() { setField('ubicaciones', [...(form.ubicaciones||[]), ""]); }
  function updUbicacion(i, val) { const u=[...(form.ubicaciones||[])]; u[i]=val; setField('ubicaciones', u); }
  function delUbicacion(i) { const u=[...(form.ubicaciones||[])]; u.splice(i,1); setField('ubicaciones', u); }
  function addBloque() { setField('horarioLaboral', { bloques: [ ...(form.horarioLaboral?.bloques||[]), { dia:"Lunes", desde:"08:00", hasta:"12:00" } ]}); }
  function updBloque(i, patch) { const b=[...(form.horarioLaboral?.bloques||[])]; b[i]={...b[i], ...patch}; setField('horarioLaboral', { bloques: b }); }
  function delBloque(i) { const b=[...(form.horarioLaboral?.bloques||[])]; b.splice(i,1); setField('horarioLaboral', { bloques: b }); }

  if (loading) return <div className="text-sm opacity-70">Cargando clubes…</div>;

  return (
    <div className="space-y-6">
      {/* Selector + Acciones */}
      <div className="flex flex-wrap items-center gap-2">
        <select className="border rounded-xl px-3 py-2" value={activoId || ""} onChange={e=>setActivoId(e.target.value)}>
          {clubes.map(c => <option key={c.id} value={c.id}>{c.nombre}</option>)}
        </select>
        <button className="px-3 py-2 rounded-xl border" onClick={crearClub}>Nuevo club</button>
        {activoId && <button className="px-3 py-2 rounded-xl border text-red-600" onClick={()=>eliminarClub(activoId)}>Eliminar</button>}
        <div className="grow" />
        <button className="px-3 py-2 rounded-xl bg-black text-white" onClick={guardarClub}>Guardar cambios</button>
      </div>

      {/* --- NUEVA ESTRUCTURA HORIZONTAL --- */}
      <div className="grid md:grid-cols-2 gap-6">
        {/* Columna Izquierda de Configuración */}
        <div className="space-y-4 p-4 border rounded-2xl bg-white">
          <h3 className="font-semibold">Configuración General</h3>
          <label className="block text-sm">Nombre del Club</label>
          <input className="w-full border rounded-xl px-3 py-2" value={form.nombre} onChange={e=>setField('nombre', e.target.value)} />
          <label className="block text-sm mt-3">Modalidad de Cobro Principal</label>
          <select className="w-full border rounded-xl px-3 py-2" value={form.modalidadPrincipal} onChange={e=>setField('modalidadPrincipal', e.target.value)}>
            <option value="por_clase">Por Clase</option>
            <option value="mensual">Mensual</option>
          </select>
          <div className="grid grid-cols-2 gap-3 mt-3 items-end">
            <div>
              <label className="block text-sm">Reparto % (Coach)</label>
              <input type="number" className="w-full border rounded-xl px-3 py-2" value={form.reparto.coach} onChange={e=>setField('reparto', { coach:Number(e.target.value)||0, club: Number(form.reparto.club||0) })} />
            </div>
            <div>
              <label className="block text-sm">Reparto % (Club)</label>
              <input type="number" className="w-full border rounded-xl px-3 py-2" value={form.reparto.club} onChange={e=>setField('reparto', { coach:Number(form.reparto.coach||0), club: Number(e.target.value)||0 })} />
            </div>
            <div className="col-span-2 text-xs opacity-70">Debe sumar 100%. Actual: {(Number(form.reparto.coach||0)+Number(form.reparto.club||0))}%</div>
          </div>
          <div className="mt-3">
            <label className="block text-sm">Canchas / Ubicaciones</label>
            <div className="space-y-2">
              {(form.ubicaciones||[]).map((u,i)=>(<div key={i} className="flex gap-2"><input className="flex-1 border rounded-xl px-3 py-2" value={u} onChange={e=>updUbicacion(i, e.target.value)} /><button className="px-3 py-2 rounded-xl border" onClick={()=>delUbicacion(i)}>Quitar</button></div>))}
            </div>
            <button className="mt-2 px-3 py-2 rounded-xl border" onClick={addUbicacion}>Agregar ubicación</button>
          </div>
        </div>

        {/* Columna Derecha de Horarios */}
        <div className="space-y-4 p-4 border rounded-2xl bg-white">
          <h3 className="font-semibold">Horario Laboral (por club)</h3>
          <div className="space-y-2 max-h-80 overflow-y-auto pr-2">
            {(form.horarioLaboral?.bloques||[]).map((b,i)=>(
              <div key={i} className="grid grid-cols-4 gap-2 items-center">
                <select className="border rounded-xl px-3 py-2" value={b.dia} onChange={e=>updBloque(i,{dia:e.target.value})}>{dias.map(d=><option key={d} value={d}>{d}</option>)}</select>
                <input type="time" className="border rounded-xl px-3 py-2" value={b.desde} onChange={e=>updBloque(i,{desde:e.target.value})}/>
                <input type="time" className="border rounded-xl px-3 py-2" value={b.hasta} onChange={e=>updBloque(i,{hasta:e.target.value})}/>
                <button className="px-3 py-2 rounded-xl border" onClick={()=>delBloque(i)}>Quitar</button>
              </div>
            ))}
          </div>
          <button className="px-3 py-2 rounded-xl border" onClick={addBloque}>Agregar bloque</button>
        </div>
      </div>

      {/* --- SECCIÓN DE PRECIOS A TODO LO ANCHO --- */}
      <div className="grid md:grid-cols-2 gap-6">
        <div className="p-4 border rounded-2xl space-y-3 bg-white">
          <h3 className="font-semibold">Precios por Clase</h3>
          {["individual","dupla","trio","cuarteto","escuelita"].map(k=>(<div key={k} className="grid grid-cols-2 gap-2 items-center"><div className="text-sm capitalize">{k}</div><input type="number" className="border rounded-xl px-3 py-2" value={form.preciosClase[k] ?? 0} onChange={e=>setField('preciosClase', { ...(form.preciosClase||{}), [k]: Number(e.target.value)||0 })} /></div>))}
        </div>
        <div className="p-4 border rounded-2xl space-y-3 bg-white">
          <h3 className="font-semibold">Precios Mensuales</h3>
          {[["1xSemana","1 vez por semana"],["2xSemana","2 veces por semana"],["3xSemana","3 veces por semana"],["libre","Libre"]].map(([key,label])=>(<div key={key} className="grid grid-cols-2 gap-2 items-center"><div className="text-sm">{label}</div><input type="number" className="border rounded-xl px-3 py-2" value={form.preciosMensuales[key] ?? 0} onChange={e=>setField('preciosMensuales', { ...(form.preciosMensuales||{}), [key]: Number(e.target.value)||0 })} /></div>))}
        </div>
      </div>
    </div>
  );
}
    
function Perfil({ perfil, alumnos, clases, pagos, gastos, grupos, onUpdate, user, setToast, getCollection, perfilCrud }) {
  const fileInputRef = React.useRef(null);

  // === Estado inicial seguro (strings) ===
  const emptyPerfil = {
    moneda: 'ARS',
    preciosClase: { individual:'', dupla:'', trio:'', cuarteto:'', escuelita:'' },
    preciosMensuales: { "1xSemana":'', "2xSemana":'', "3xSemana":'', "libre":'' },
    datosBancarios: { 
        alias:'', 
        cbu:'', 
        banco:'',
        titular: '' // <--- ¡CAMBIO NECESARIO!
    },
    horarioLaboral: (initialState?.perfil?.horarioLaboral) || [],
    modoTrabajo: 'Club',
    pin: ''
};
  const [form, setForm] = useState(emptyPerfil);

  // === Resto de estados que ya tenías ===
  const [pinInput, setPinInput] = useState({ newPin: "", confirmPin: "" });
  const [plantillas, setPlantillas] = useState([]);
  const [plantillaSeleccionada, setPlantillaSeleccionada] = useState(null);
  const [mensajePersonalizado, setMensajePersonalizado] = useState("");
  const [destinatarios, setDestinatarios] = useState([]);
  const [busquedaAlumno, setBusquedaAlumno] = useState("");
  const [listaBusquedaAbierta, setListaBusquedaAbierta] = useState(false);
  const [editingPlantilla, setEditingPlantilla] = useState(null);
  const { abrirModalPago, Modal: ModalAbono } = useModalPagoAbono();

  // === Plantillas (igual que antes) ===
  useEffect(() => {
    if (!user) return;
    const plantillasCollection = db.collection('users').doc(user.uid).collection('plantillas');
    const unsubscribe = plantillasCollection.onSnapshot(snapshot => {
      const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setPlantillas(data);
    });
    return () => unsubscribe();
  }, [user]);

  // === Hidratar form desde perfil (club) → todo a string; sin undefined ===
  const hydratedRef = React.useRef(false);
  useEffect(() => {
    const S = (v) => (v == null ? '' : String(v));
    const p = perfil || {};
    const pc = p.preciosClase || p.precios || {}; // admitir legacy "precios"
    if (!hydratedRef.current) {
      setForm(prev => ({
        ...prev,
        moneda: p.moneda ?? 'ARS',
        datosBancarios: { ...(prev.datosBancarios||{}), ...(p.datosBancarios||{}) },
        horarioLaboral: p.horarioLaboral || prev.horarioLaboral,
        modoTrabajo: 'Club',
        pin: p.pin ?? '',
        preciosClase: {
          individual: S(pc.individual),
          dupla:      S(pc.dupla ?? pc.duo),
          trio:       S(pc.trio),
          cuarteto:   S(pc.cuarteto),
          escuelita:  S(pc.escuelita),
        },
        preciosMensuales: {
          "1xSemana": S(p.preciosMensuales?.["1xSemana"]),
          "2xSemana": S(p.preciosMensuales?.["2xSemana"]),
          "3xSemana": S(p.preciosMensuales?.["3xSemana"]),
          "libre":    S(p.preciosMensuales?.["libre"]),
        },
      }));
      hydratedRef.current = true;
    }
  }, [perfil]);

  // === Handlers genéricos ===
  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value ?? '' }));
  };
  const handleDatosBancariosChange = (e) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, datosBancarios: { ...prev.datosBancarios, [name]: value ?? '' } }));
  };
  const handleHorarioChange = (index, campo, valor) => {
    setForm(prev => {
      const nuevo = Array.isArray(prev.horarioLaboral) ? [...prev.horarioLaboral] : [];
      nuevo[index] = { ...(nuevo[index]||{}), [campo]: valor ?? '' };
      return { ...prev, horarioLaboral: nuevo };
    });
  };

  // === Precios (ahora en preciosClase / preciosMensuales) ===
  const handlePrecioClaseChange = (e) => {
    const { name, value } = e.target; // name: individual | dupla | trio | cuarteto | escuelita
    setForm(prev => ({ ...prev, preciosClase: { ...prev.preciosClase, [name]: value ?? '' } }));
  };
  const handlePrecioMensualChange = (e) => {
    const { name, value } = e.target; // name: 1xSemana | 2xSemana | 3xSemana | libre
    setForm(prev => ({ ...prev, preciosMensuales: { ...prev.preciosMensuales, [name]: value ?? '' } }));
  };

  // === PIN (igual que antes) ===
  const handleSetPin = () => {
    if (pinInput.newPin.length !== 3 || !/^\d{3}$/.test(pinInput.newPin)) {
      alert("El PIN debe ser exactamente de 3 números.");
      return;
    }
    if (pinInput.newPin !== pinInput.confirmPin) {
      alert("Los PINs no coinciden. Por favor, vuelve a intentarlo.");
      return;
    }
    setForm(prev => ({ ...prev, pin: pinInput.newPin }));
    setToast?.("PIN actualizado. No olvides guardar los cambios.");
    setPinInput({ newPin: "", confirmPin: "" });
  };
  const handlePinInputChange = (e) => {
    const { name, value } = e.target;
    if (/^\d*$/.test(value) && value.length <= 3) {
      setPinInput(prev => ({ ...prev, [name]: value }));
    }
  };

  // === Export / Import / Wipe (tal cual los tenías) ===
  const sanitizeDataForJSON = (data) => {
    const replacer = (key, value) => (value === undefined ? null : value);
    return JSON.parse(JSON.stringify(data, replacer));
  };
  const handleExportData = () => { /* ... igual que tu versión ... */ };
  const handleImportData = async (event) => { /* ... igual que tu versión ... */ };
  const handleWipeData = async () => { /* ... igual que tu versión ... */ };

  // === WhatsApp / Plantillas (tal cual) ===
  const alumnosFiltrados = useMemo(() => {
    if (!busquedaAlumno) return [];
    return (alumnos || []).filter(a => a.estado === 'activo' && getNombreCompleto(a).toLowerCase().includes(busquedaAlumno.toLowerCase()));
  }, [busquedaAlumno, alumnos]);
  const handleAgregarDestinatario = (alumno) => { /* ... */ };
  const handleQuitarDestinatario  = (alumnoId) => { /* ... */ };
  const handleSendMessage         = (destinatario) => { /* ... */ };
  const handleSavePlantilla       = (plantillaData) => { /* ... */ };
  const handleDeletePlantilla     = () => { /* ... */ };

  // === Guardar Perfil en /clubs/{clubId}/perfil/main (vía perfilCrud.update) ===
  async function guardarPerfil() {
    try {
      const u = auth.currentUser;
      if (!u) return;
      await u.reload();
      const tok = await u.getIdTokenResult();
      if (!tok.claims.email_verified) { setToast?.("Verificá tu email para continuar"); return; }
      await u.getIdToken(true);

      const payload = {
        moneda: form.moneda || 'ARS',
        datosBancarios: form.datosBancarios || {},
        horarioLaboral: form.horarioLaboral || [],
        pin: form.pin || null,
        preciosClase: {
          individual: Number(form.preciosClase?.individual) || 0,
          duo:        Number(form.preciosClase?.dupla) || 0,
          trio:       Number(form.preciosClase?.trio) || 0,
          cuarteto:   Number(form.preciosClase?.cuarteto) || 0,
          escuelita:  Number(form.preciosClase?.escuelita) || 0,
        },
        preciosMensuales: {
          "1xSemana": Number(form.preciosMensuales?.["1xSemana"]) || 0,
          "2xSemana": Number(form.preciosMensuales?.["2xSemana"]) || 0,
          "3xSemana": Number(form.preciosMensuales?.["3xSemana"]) || 0,
          "libre":    Number(form.preciosMensuales?.["libre"])    || 0,
        },
        updatedAt: new Date().toISOString(),
      };

      if (perfilCrud && typeof perfilCrud.update === 'function') {
        await perfilCrud.update(payload);  // <- tu CRUD debe escribir en .../clubs/{clubId}/perfil/main
      } else {
        // Fallback directo si hiciera falta:
        // const baseRef = db.collection('users').doc(u.uid).collection('clubs').doc(clubActivoId);
        // await baseRef.collection('perfil').doc('main').set(payload, { merge:true });
      }
      setToast?.("Perfil guardado");
    } catch (e) {
      console.error("Error guardando perfil:", e);
      setToast?.("Error al guardar el perfil");
    }
  }

  // === Submit del formulario: ahora usa guardarPerfil ===
  const handleSubmit = async (e) => {
    e.preventDefault();
    await guardarPerfil();
  };
      const handlePasswordReset = () => {
        if(user && user.email) {
            auth.sendPasswordResetEmail(user.email)
                .then(() => setToast("Email para restablecer contraseña enviado."))
                .catch((error) => setToast(`Error: ${error.message}`));
        }
      };

return (
  <>
    <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-6 items-start">
      <Card title={<span className="text-[#34745B]">Perfil y Configuración</span>}>
          <h4 className="text-md font-semibold text-slate-700 mb-2">Datos Personales</h4>
          <div className="grid gap-3">
            <div><label className="text-sm text-slate-600">Nombre del Profesor</label><input name="nombre" value={form.nombre} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" /></div>
            <div><label className="text-sm text-slate-600">Apellido</label><input name="apellido" value={form.apellido} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" /></div>
            <div><label className="text-sm text-slate-600">Teléfono</label><input name="telefono" value={form.telefono} onChange={handleChange} className="w-full border rounded-lg px-3 py-2" /></div>
          </div>
          <div className="mt-6 border-t pt-6">
            <h4 className="text-md font-semibold text-slate-700 mb-2">Configuración General</h4>
            <div>
              <label className="text-sm text-slate-600">Modo de Trabajo Principal</label>
              <select name="modoTrabajo" value={form.modoTrabajo || 'Club'} onChange={handleChange} className="w-full mt-1 border rounded-lg px-3 py-2">
                <option value="Club">Solo Clubes</option>
              </select>
            </div>
          </div>
          <div className="mt-6 border-t pt-6">
              <h4 className="text-md font-semibold text-slate-700 mb-2">Cuenta</h4>
              <div className="grid gap-3">
                <div>
                  <label className="text-sm text-slate-600">Email de la cuenta</label>
                  <p className="w-full bg-slate-100 rounded-lg px-3 py-2 text-slate-700">{user?.email}</p>
                </div>
                <div><button type="button" onClick={handlePasswordReset} className="w-full px-4 py-2 rounded-lg border text-sm bg-slate-100 hover:bg-slate-200">Restablecer Contraseña</button></div>
              </div>
          </div>
      </Card>
      
      <Card title={<span className="text-[#34745B]">Datos Bancarios para Transferencias</span>}>
          <div className="grid gap-4">
              {['alias', 'cbu', 'banco', 'titular'].map(field => (
                  <div key={field}>
                      <label className="text-sm font-medium text-slate-600 capitalize">{field}</label>
                      <div className="flex gap-2 mt-1">
                          <input type="text" name={field} value={(form.datosBancarios || {})[field]} onChange={handleDatosBancariosChange} className="w-full border rounded-lg px-3 py-2" />
                          <button type="button" onClick={() => handleCopyToClipboard((form.datosBancarios || {})[field])} className="px-3 py-2 rounded-lg border text-sm hover:bg-slate-100">Copiar</button>
                      </div>
                  </div>
              ))}
          </div>
      </Card>

      <div className="md:col-span-2">
        <Card title={<span className="text-[#34745B]">Centro de Comunicaciones</span>}>
            <div className="grid gap-4">
                <div>
                    <label className="text-sm font-medium text-slate-600">1. Elige una plantilla o escribe un mensaje</label>
                    <div className="flex gap-2 mt-1">
                        <select className="w-full border rounded-lg px-3 py-2" value={plantillaSeleccionada ? plantillaSeleccionada.id : ""} onChange={(e) => { const p = plantillas.find(p => p.id === e.target.value); setPlantillaSeleccionada(p || null); setMensajePersonalizado(p ? p.texto : ""); }}>
                            <option value="">Seleccionar plantilla...</option>
                            {plantillas.map(p => (<option key={p.id} value={p.id}>{p.titulo}</option>))}
                        </select>
                        <button type="button" onClick={() => setEditingPlantilla({})} className="px-3 py-2 text-sm rounded-lg bg-[#34745B] hover:bg-green-800 text-white whitespace-nowrap">+ Nueva</button>
                        <button type="button" onClick={() => plantillaSeleccionada && setEditingPlantilla(plantillaSeleccionada)} disabled={!plantillaSeleccionada} className="px-3 py-2 text-sm rounded-lg border disabled:opacity-50">Editar</button>
                        <button type="button" onClick={handleDeletePlantilla} disabled={!plantillaSeleccionada} className="px-3 py-2 text-sm rounded-lg border text-red-600 disabled:opacity-50">Eliminar</button>
                    </div>
                    <textarea value={mensajePersonalizado} onChange={(e) => setMensajePersonalizado(e.target.value)} className="w-full mt-2 border rounded-lg px-3 py-2" rows={5} placeholder="O escribe un mensaje personalizado aquí... Usa {nombre_alumno} para personalizar." />
                </div>
                <div className="relative">
                    <label className="text-sm font-medium text-slate-600">2. Selecciona los destinatarios</label>
                    <input type="text" value={busquedaAlumno} onChange={(e) => { setBusquedaAlumno(e.target.value); setListaBusquedaAbierta(true); }} onBlur={() => setTimeout(() => setListaBusquedaAbierta(false), 200)} placeholder="Escribe para buscar alumnos..." className="w-full mt-1 border rounded-lg px-3 py-2" />
                    {listaBusquedaAbierta && busquedaAlumno && (
                        <ul className="absolute z-10 w-full bg-white border rounded-lg mt-1 max-h-48 overflow-y-auto shadow-lg">
                            {alumnosFiltrados.length > 0 ? alumnosFiltrados.map(a => (<li key={a.id} onMouseDown={() => handleAgregarDestinatario(a)} className="px-3 py-2 hover:bg-slate-100 cursor-pointer">{getNombreCompleto(a)}</li>)) : <li className="px-3 py-2 text-slate-500">No se encontraron alumnos.</li>}
                        </ul>
                    )}
                    <div className="mt-2">
                        <p className="text-xs font-semibold text-slate-500">Destinatarios ({destinatarios.length}):</p>
                        {destinatarios.length > 0 && (<div className="flex flex-wrap gap-2 mt-1 p-2 border rounded-lg bg-slate-50">{destinatarios.map(d => (<span key={d.id} className="flex items-center gap-2 bg-sky-100 text-sky-800 text-sm rounded-full px-2 py-1">{getNombreCompleto(d)}<button type="button" onClick={() => handleQuitarDestinatario(d.id)} className="w-4 h-4 rounded-full bg-sky-200 text-sky-800 flex items-center justify-center font-bold text-xs">x</button></span>))}</div>)}
                    </div>
                </div>
                <div>
                    <label className="text-sm font-medium text-slate-600">3. Envía los mensajes</label>
                    <div className="mt-2 p-3 border rounded-lg bg-slate-50 space-y-2 max-h-48 overflow-y-auto">{destinatarios.length > 0 ? (destinatarios.map(destinatario => (<button key={destinatario.id} type="button" onClick={() => handleSendMessage(destinatario)} className="w-full flex justify-between items-center text-left px-3 py-2 text-sm rounded-lg bg-green-600 text-white hover:bg-green-700 transition-colors"><span>Enviar a: <strong>{getNombreCompleto(destinatario)}</strong></span><span role="img" aria-label="send">💬</span></button>))) : (<p className="text-xs text-slate-400">Selecciona al menos un destinatario para ver los botones de envío.</p>)}</div>
                </div>
            </div>
            <PlantillaModal isOpen={editingPlantilla !== null} plantilla={editingPlantilla?.id ? editingPlantilla : null} onCancel={() => setEditingPlantilla(null)} onSave={handleSavePlantilla} />
        </Card>
      </div>
      
      <div className="md:col-span-2">
        <Card title={<span className="text-[#34745B]">Mis Clubes</span>}>
            <GestionClubes user={user} />
        </Card>
      </div>

      <div className="md:col-span-2">
        <Card title={<span className="text-[#34745B]">Gestión de Datos</span>}>
             <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <button type="button" onClick={handleExportData} className="w-full px-4 py-2 rounded-lg border bg-[#34745B] hover:bg-green-800 text-white font-semibold">Exportar Datos (Backup)</button>
                <button type="button" onClick={() => fileInputRef.current.click()} className="w-full px-4 py-2 rounded-lg border bg-slate-600 hover:bg-slate-700 text-white font-semibold">Importar Datos</button>
                <input type="file" ref={fileInputRef} className="hidden" accept=".json" onChange={handleImportData} />
            </div>
            <p className="text-xs text-slate-500 mt-3"><strong>Atención:</strong> La importación de datos reemplazará toda la información existente en el modo de trabajo que tengas seleccionado.</p>
        </Card>
      </div>
      
      <div className="md:col-span-2">
        <Card title={<span className="text-[#34745B]">Seguridad y PIN</span>}>
            <div className="space-y-4">
                <div>
                    <label className="text-sm text-slate-600 block mb-1">
                        {form.pin ? "Cambiar PIN de seguridad (3 dígitos)" : "Crear PIN de seguridad (3 dígitos)"}
                    </label>
                    <p className="text-xs text-slate-500 mb-2">
                        Este PIN se solicitará para acciones críticas.
                    </p>
                    <div className="grid grid-cols-2 gap-3">
                        <input type="password" name="newPin" value={pinInput.newPin} onChange={handlePinInputChange} placeholder="Nuevo PIN" maxLength="3" className="w-full border rounded-lg px-3 py-2 text-center" />
                        <input type="password" name="confirmPin" value={pinInput.confirmPin} onChange={handlePinInputChange} placeholder="Confirmar PIN" maxLength="3" className="w-full border rounded-lg px-3 py-2 text-center" />
                    </div>
                </div>
                <button type="button" onClick={handleSetPin} className="w-full px-4 py-2 rounded-lg bg-slate-600 hover:bg-slate-700 text-white font-semibold">
                    {form.pin ? "Actualizar PIN" : "Establecer PIN"}
                </button>
            </div>
        </Card>
      </div>

      <div className="md:col-span-2">
        <div className="p-4 border-2 border-red-300 bg-red-50 rounded-2xl">
            <h3 className="text-base font-semibold text-red-800">Zona de Peligro</h3>
            <p className="text-sm text-red-700 mt-2 mb-3">
                La siguiente acción es permanente y no se puede deshacer.
            </p>
            <button type="button" onClick={handleWipeData} className="w-full px-4 py-2 rounded-lg bg-red-600 hover:bg-red-700 text-white font-semibold">
                Borrar Todos los Datos de este Modo de Trabajo
            </button>
        </div>
      </div>

      <div className="md:col-span-2 flex justify-end">
         <button type="submit" className="px-6 py-3 rounded-xl bg-[#34745B] hover:bg-green-800 text-white font-semibold">Guardar Todos los Cambios</button>
      </div>
    </form>

    {/* 👇 Montado una sola vez, fuera del <form> */}
    <ModalAbono />
  </>
);

    }
    // Reemplaza tu PagoGrupalModal completo con este código
function PagoGrupalModal({ isOpen, clase, alumnos, onCancel, onSave, focusAlumnoId }) {
  const [pagos, setPagos] = useState({});
  const alumnosDeClase = clase ? (clase.alumnoIds || []).map(id => (alumnos || []).find(a => a.id === id)).filter(Boolean) : [];
  
  // Si nos pasan un focusAlumnoId, solo mostramos a ese alumno. Si no, a todos.
  const visibles = focusAlumnoId ? alumnosDeClase.filter(a => a.id === focusAlumnoId) : alumnosDeClase;

  useEffect(() => {
    if (clase) {
      const precioPorAlumno = (clase.alumnoIds?.length || 1) > 0 ? (parseFloat(clase.precio || 0) / (clase.alumnoIds?.length || 1)) : 0;
      const initialState = {};
      alumnosDeClase.forEach(alumno => {
        initialState[alumno.id] = {
          monto: alumno.plan === 'mensual' ? '0' : formatCurrency(precioPorAlumno, { withSymbol: false }), // LÍNEA MODIFICADA
          metodo: alumno.plan === 'mensual' ? "Mensual" : 'Efectivo',
          mixtoEfectivo: "",
          mixtoTransferencia: ""
        };
      });
      setPagos(initialState);
    }
  }, [clase, alumnos]);

  if (!isOpen || !clase) return null;

  const handlePaymentChange = (alumnoId, field, value) => {
    setPagos(prev => ({ ...prev, [alumnoId]: { ...prev[alumnoId], [field]: value } }));
  };
  
  const handleMixtoChange = (alumnoId, efectivo, transferencia) => {
      const ef = parseFloat(efectivo) || 0;
      const tx = parseFloat(transferencia) || 0;
      setPagos(prev => ({
  ...prev,
  [alumnoId]: {
    ...prev[alumnoId],
    mixtoEfectivo: efectivo,
    mixtoTransferencia: transferencia,
    monto: formatCurrency(ef + tx), // Aplica la función formatCurrency
  }
}));
  }

  const handleSave = () => {
    const pagosAGuardar = Object.entries(pagos).map(([alumnoId, data]) => {
      // Solo incluimos en el guardado a los alumnos que estamos viendo
      if (visibles.some(a => a.id === alumnoId)) {
        const registro = { alumnoId, ...data };
        if (data.metodo === "Mixto") {
          registro.monto = formatCurrency(parseFloat(data.mixtoEfectivo || 0) + parseFloat(data.mixtoTransferencia || 0));
        }
        return registro;
      }
      return null;
    }).filter(Boolean); // Limpiamos los nulos
    onSave(pagosAGuardar);
  };

  // Título dinámico para mayor claridad
  const modalTitle = focusAlumnoId ? `Pagar Clase Específica` : `Registrar Pagos de Clase`;

  return (
    <Modal isOpen={isOpen} title={modalTitle} onCancel={onCancel} onConfirm={handleSave} confirmText="Guardar Pagos">
      <div className="grid gap-4">
        <p className="text-sm text-center border-b pb-2">Clase de {clase.tipo} del {clase.fecha} a las {clase.hora}. Precio total: ${formatCurrency(clase.precio)}</p>
        <div className="space-y-4 max-h-64 overflow-y-auto pr-2">
          {visibles.map(alumno => (
            <div key={alumno.id} className="p-3 border rounded-lg bg-slate-50">
              <p className="font-semibold">{getNombreCompleto(alumno)}</p>
              {alumno.plan === 'mensual' ? (
                <p className="text-sm text-emerald-700 mt-2">✅ Cubierto por Plan Mensual</p>
              ) : (
                <div className="grid grid-cols-2 gap-3 mt-2">
                  <div>
                    <label className="text-xs text-slate-600">Monto</label>
                    <input type="number" value={pagos[alumno.id]?.monto || ''} onChange={(e) => handlePaymentChange(alumno.id, 'monto', e.target.value)} disabled={pagos[alumno.id]?.metodo === 'Mixto'} className="w-full border rounded-lg px-2 py-1 disabled:bg-slate-200" />
                  </div>
                  <div>
                    <label className="text-xs text-slate-600">Método</label>
                    <select value={pagos[alumno.id]?.metodo || 'Pendiente'} onChange={(e) => handlePaymentChange(alumno.id, 'metodo', e.target.value)} className="w-full border rounded-lg px-2 py-1">
                      {METODOS_PAGO.filter(m => m !== 'Mensual').map(m => <option key={m}>{m}</option>)}
                    </select>
                  </div>
                  {/* AQUÍ ESTÁ LA LÓGICA CORREGIDA PARA EL PAGO MIXTO */}
                  {pagos[alumno.id]?.metodo === 'Mixto' && (
                    <div className="col-span-2 grid grid-cols-2 gap-2 mt-2 pt-2 border-t">
                       <div>
                         <label className="text-xs text-slate-600">Efectivo</label>
                         <input type="number" value={pagos[alumno.id]?.mixtoEfectivo || ""} onChange={(e) => handleMixtoChange(alumno.id, e.target.value, pagos[alumno.id]?.mixtoTransferencia)} className="w-full rounded-lg px-2 py-1 border" />
                       </div>
                       <div>
                         <label className="text-xs text-slate-600">Transferencia</label>
                         <input type="number" value={pagos[alumno.id]?.mixtoTransferencia || ""} onChange={(e) => handleMixtoChange(alumno.id, pagos[alumno.id]?.mixtoEfectivo, e.target.value)} className="w-full rounded-lg px-2 py-1 border" />
                       </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      </div>
    </Modal>
  );
}
// Pega esta nueva función en tu archivo
function RegistroPagoMensualModal({ isOpen, alumno, perfil, onCancel, onSave }) {
  const [form, setForm] = useState({
    monto: "",
    metodo: "Transferencia",
    mes: new Date().getMonth(),
    fechaPago: formatDate(new Date())
  });

  useEffect(() => {
    // Cuando se abre el modal, calcula el monto sugerido del plan del alumno
    if (alumno && perfil.preciosMensuales) {
      const montoPredefinido = perfil.preciosMensuales[alumno.frecuencia] || "";
      setForm(prev => ({ ...prev, monto: montoPredefinido }));
    }
  }, [isOpen, alumno, perfil]);

  if (!isOpen || !alumno) return null;

  const handleSave = () => {
    if (!form.monto || parseFloat(form.monto) <= 0) {
      alert("Por favor, ingresa un monto válido.");
      return;
    }
    onSave(form);
  };

  return (
    <Modal isOpen={isOpen} title={`Registrar Abono: ${getNombreCompleto(alumno)}`} onCancel={onCancel} onConfirm={handleSave} confirmText="Guardar Pago">
      <div className="grid gap-4">
        <div>
          <label className="text-sm text-slate-600">Mes Correspondiente</label>
          <select 
            value={form.mes} 
            onChange={(e) => setForm({...form, mes: parseInt(e.target.value)})}
            className="w-full border rounded-lg px-3 py-2 mt-1"
          >
            {MESES_NOMBRES.map((nombre, index) => <option key={index} value={index}>{nombre}</option>)}
          </select>
        </div>
        <div>
          <label className="text-sm text-slate-600">Monto Pagado</label>
          <input 
            type="number" 
            value={form.monto} 
            onChange={(e) => setForm({...form, monto: e.target.value})} 
            className="w-full border rounded-lg px-3 py-2 mt-1" 
            placeholder="0.00" 
          />
        </div>
        <div>
          <label className="text-sm text-slate-600">Método de Pago</label>
          <select 
            value={form.metodo} 
            onChange={(e) => setForm({...form, metodo: e.target.value})}
            className="w-full border rounded-lg px-3 py-2 mt-1"
          >
            {METODOS_PAGO.filter(m => m !== 'Pendiente').map(m => <option key={m}>{m}</option>)}
          </select>
        </div>
        <div>
          <label className="text-sm text-slate-600">Fecha de Pago</label>
          <input 
            type="date" 
            value={form.fechaPago} 
            onChange={(e) => setForm({...form, fechaPago: e.target.value})} 
            className="w-full border rounded-lg px-3 py-2 mt-1" 
          />
        </div>
      </div>
    </Modal>
  );
}
    function PagoMensualModal({ isOpen, alumno, mes, onCancel, onSave }) {
      const [form, setForm] = useState({ monto: "", metodo: "Efectivo" });
      useEffect(() => {
        if (alumno) {
          const restante = alumno.cuota - alumno.totalPagado;
          setForm({ monto: restante > 0 ? formatCurrency(restante) : "", metodo: "Efectivo" });
        }
      }, [alumno]);
      if (!isOpen || !alumno) return null;
      const handleSave = () => { onSave({ ...form, monto: form.monto || "0" }); };
      return (
        <Modal isOpen={isOpen} title={`Pago Cuota: ${alumno.nombre}`} onCancel={onCancel} onConfirm={handleSave} confirmText="Guardar Pago">
          <div className="grid gap-4">
            <p>Cuota de {MESES_NOMBRES[mes]} por {formatCurrency(alumno.cuota)}. Pagado: {formatCurrency(alumno.totalPagado)}.</p>
            <div><label className="text-sm text-slate-600">Monto a Pagar</label><input type="number" value={form.monto} onChange={(e) => setForm({...form, monto: e.target.value})} className="w-full border rounded-lg px-3 py-2" placeholder="0.00" /></div>
            <div><label className="text-sm text-slate-600">Método de Pago</label><select value={form.metodo} onChange={(e) => setForm({...form, metodo: e.target.value})} className="w-full border rounded-lg px-3 py-2">{METODOS_PAGO.filter(m => m !== 'Pendiente').map(m => <option key={m}>{m}</option>)}</select></div>
          </div>
        </Modal>
      );
    }
    // Pega este nuevo componente en tu archivo
function EditarPagoModal({ isOpen, pago, onCancel, onSave }) {
  const [form, setForm] = useState(null);

  useEffect(() => {
    // Cuando se abre el modal, inicializamos el form con todos los campos necesarios
    if (pago) {
      setForm({
        ...pago,
        concepto: pago.concepto || "Pago General",
        mixtoEfectivo: pago.detalleMixto?.efectivo?.toString() || "",
        mixtoTransferencia: pago.detalleMixto?.transferencia?.toString() || ""
      });
    }
  }, [pago]);

  if (!isOpen || !form) return null;

  const handleChange = (e) => {
    setForm(prev => ({ ...prev, [e.target.name]: e.target.value }));
  };
  
  const handleMixtoChange = (efectivo, transferencia) => {
      const ef = parseFloat(efectivo) || 0;
      const tx = parseFloat(transferencia) || 0;
      setForm(prev => ({
  ...prev,
  mixtoEfectivo: efectivo,
  mixtoTransferencia: transferencia,
  monto: formatCurrency(ef + tx, { withSymbol: false }),
}));
  }

  return (
    <Modal isOpen={isOpen} title={`Editar Pago`} onCancel={onCancel} onConfirm={() => onSave(form)} confirmText="Guardar Cambios">
      <div className="grid gap-4">
        <div>
          <label className="text-sm text-slate-600">Concepto</label>
          <input type="text" name="concepto" value={form.concepto} onChange={handleChange} className="w-full border rounded-lg px-3 py-2 mt-1" />
        </div>
        <div>
          <label className="text-sm text-slate-600">Monto Pagado</label>
          <input type="number" name="monto" value={form.monto} onChange={handleChange} disabled={form.metodo === 'Mixto'} className="w-full border rounded-lg px-3 py-2 mt-1 disabled:bg-slate-100" />
        </div>
        <div>
          <label className="text-sm text-slate-600">Método de Pago</label>
          <select name="metodo" value={form.metodo} onChange={handleChange} className="w-full border rounded-lg px-3 py-2 mt-1">
            {METODOS_PAGO.filter(m => m !== 'Pendiente' && m !== 'Mensual').map(m => <option key={m}>{m}</option>)}
          </select>
        </div>
        
        {/* Lógica corregida para el pago mixto */}
        {form.metodo === 'Mixto' && (
          <div className="p-3 border rounded-lg grid grid-cols-2 gap-3 bg-slate-50">
            <div>
              <label className="text-xs text-slate-600">Efectivo</label>
              <input type="number" value={form.mixtoEfectivo} onChange={(e) => handleMixtoChange(e.target.value, form.mixtoTransferencia)} className="w-full border rounded-lg px-2 py-1 mt-1" />
            </div>
            <div>
              <label className="text-xs text-slate-600">Transferencia</label>
              <input type="number" value={form.mixtoTransferencia} onChange={(e) => handleMixtoChange(form.mixtoEfectivo, e.target.value)} className="w-full border rounded-lg px-2 py-1 mt-1" />
            </div>
          </div>
        )}

        <div>
          <label className="text-sm text-slate-600">Fecha de Pago</label>
          <input type="date" name="fecha" value={form.fecha} onChange={handleChange} className="w-full border rounded-lg px-3 py-2 mt-1" />
        </div>
      </div>
    </Modal>
  );
}
function PlantillaModal({ isOpen, plantilla, onCancel, onSave }) {
  const [form, setForm] = useState({ titulo: '', texto: '' });

  useEffect(() => {
    // Si pasamos una plantilla, es para editar. Si no, es para crear una nueva.
    if (plantilla) {
      setForm(plantilla);
    } else {
      setForm({ titulo: '', texto: '' });
    }
  }, [plantilla]);

  if (!isOpen) return null;

  const handleChange = (e) => {
    setForm(prev => ({ ...prev, [e.target.name]: e.target.value }));
  };

  return (
    <Modal isOpen={isOpen} title={form.id ? "Editar Plantilla" : "Nueva Plantilla"} onCancel={onCancel} onConfirm={() => onSave(form)} confirmText="Guardar">
      <div className="grid gap-4">
        <div>
          <label className="text-sm text-slate-600">Título de la Plantilla</label>
          <input type="text" name="titulo" value={form.titulo} onChange={handleChange} className="w-full border rounded-lg px-3 py-2 mt-1" placeholder="Ej: Recordatorio de Clase" />
        </div>
        <div>
          <label className="text-sm text-slate-600">Texto del Mensaje</label>
          <textarea name="texto" value={form.texto} onChange={handleChange} className="w-full border rounded-lg px-3 py-2 mt-1" rows={6} placeholder="Escribe tu mensaje aquí. Usa {nombre_alumno} para personalizarlo."></textarea>
        </div>
      </div>
    </Modal>
  );
}

// === Iconos SVG (estilos neutros, heredan color actual) ===
const InfoIconCalendar = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <rect x="3" y="4" width="18" height="18" rx="3" strokeWidth="1.5"/>
    <path d="M16 2v4M8 2v4M3 10h18" strokeWidth="1.5"/>
  </svg>
);
const InfoIconMoney = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <rect x="3" y="6" width="18" height="12" rx="2" strokeWidth="1.5"/>
    <path d="M7 12h.01M17 12h.01M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" strokeWidth="1.5"/>
  </svg>
);
const InfoIconChart = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <path d="M3 3v18h18" strokeWidth="1.5"/>
    <path d="M7 15v3M12 11v7M17 7v11" strokeWidth="1.5"/>
  </svg>
);
const InfoIconShield = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <path d="M12 3l7 3v6c0 5-3.5 8-7 9-3.5-1-7-4-7-9V6l7-3Z" strokeWidth="1.5"/>
    <path d="M9.5 12.5l2 2 3-3" strokeWidth="1.5"/>
  </svg>
);
const InfoIconMessage = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <path d="M21 12a8 8 0 1 1-3-6.3L21 6l-.7 3.2c.5.9.7 1.9.7 2.8Z" strokeWidth="1.5"/>
    <path d="M9 10h6M9 13h4" strokeWidth="1.5"/>
  </svg>
);
const InfoIconRadio = (p) => (
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...p}>
    <circle cx="12" cy="12" r="3" strokeWidth="1.5"/>
    <path d="M2 12a10 10 0 0 1 20 0M5 12a7 7 0 0 1 14 0" strokeWidth="1.5"/>
  </svg>
);

function InfoModal({ type, onClose }) {
  React.useEffect(() => {
    const onKey = (e) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [onClose]);

  const copy = {
    auth: {
      title: "Auth segura con Firebase",
      body: (
        <>
          <p className="text-sm text-slate-600">
            Usamos <strong>Firebase Authentication</strong> para validar tus credenciales en forma segura.
            Tus contraseñas <strong>no</strong> se guardan en servidores propios de Coachex-Pro.
          </p>
        </>
      ),
      cta: null,
    },
    support: {
      title: "Soporte por WhatsApp",
      body: (
        <>
          <p className="text-sm text-slate-600">
            ¿Necesitás ayuda? Escribinos por WhatsApp. Atendemos de <strong>Lun a Vie, 9 a 18 hs</strong>.
          </p>
        </>
      ),
      cta: (
        <a
          href="https://wa.me/5493810000000" // ← reemplazá por tu número
          target="_blank" rel="noopener"
          className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700"
        >
          Abrir WhatsApp
        </a>
      ),
    },
    status: {
      title: "Estado del sistema",
      body: (
        <>
          <p className="text-sm text-slate-600">
            Revisá en tiempo real si la plataforma está funcionando correctamente y el historial de mantenimientos.
          </p>
        </>
      ),
      cta: (
        <a
          href="/status"
          className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700"
        >
          Ver estado
        </a>
      ),
    },
  }[type] || {};

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      role="dialog" aria-modal="true"
      onClick={onClose}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div
        className="relative mx-4 max-w-md w-full rounded-2xl bg-white p-6 shadow-lg"
        onClick={(e) => e.stopPropagation()}
      >
        <button
          onClick={onClose}
          aria-label="Cerrar"
          className="absolute right-3 top-3 rounded-full p-1 text-slate-500 hover:bg-slate-100"
          title="Cerrar"
        >
          ✕
        </button>

        <h3 className="text-lg font-semibold text-slate-900 mb-2">{copy.title}</h3>
        <div className="mb-4">{copy.body}</div>

        <div className="flex items-center justify-end gap-2">
          {copy.cta}
          <button
            onClick={onClose}
            className="rounded-lg border border-slate-300 px-3 py-2 text-slate-700 hover:bg-slate-50"
          >
            Cerrar
          </button>
        </div>
      </div>
    </div>
  );
}

function NewsModal(props) {
  var open = props.open;
  var onClose = props.onClose;
  var lang = props.lang === "en" ? "en" : "es"; // default a "es"

  var _React = React;
  var useState = _React.useState, useEffect = _React.useEffect;

  var _useState = useState([]), novedades = _useState[0], setNovedades = _useState[1];
  var _useState2 = useState(true), loading = _useState2[0], setLoading = _useState2[1];

  useEffect(function () {
    if (!open) return;

    setLoading(true);
    // Usa concatenación en lugar de template string
    var url = "novedades." + lang + ".json"; // asegurate que esté junto a tu index.html
    fetch(url)
      .then(function (res) { return res.json(); })
      .then(function (data) { setNovedades(Array.isArray(data) ? data : []); })
      .catch(function (err) {
        console.error("Error cargando novedades:", err);
        setNovedades([]);
      })
      .finally(function () {
        setLoading(false);
      });
  }, [open, lang]);

  if (!open) return null;

  var t = (lang === "es") ? {
    title: "Novedades",
    loading: "Cargando novedades...",
    empty: "No hay novedades disponibles por ahora.",
    close: "Cerrar"
  } : {
    title: "News",
    loading: "Loading updates...",
    empty: "No updates available yet.",
    close: "Close"
  };

  function stop(e) { e.stopPropagation(); }

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      role="dialog" aria-modal="true" aria-labelledby="news-title"
      onClick={onClose}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div
        className="relative bg-white w-full max-w-2xl mx-4 rounded-2xl shadow-xl"
        onClick={stop}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b">
          <h3 id="news-title" className="text-lg font-semibold text-slate-900">
            {t.title}
          </h3>
          <button
            onClick={onClose}
            className="rounded-full p-2 text-slate-600 hover:bg-slate-100"
            aria-label={t.close}
            title={t.close}
          >
            ✕
          </button>
        </div>

        {/* Contenido */}
        <div className="px-6 py-5 max-h-[70vh] overflow-y-auto space-y-6 text-slate-700">
          {loading && <p className="text-sm text-slate-500">{t.loading}</p>}
          {!loading && novedades.length === 0 && (
            <p className="text-sm text-slate-500">{t.empty}</p>
          )}
          {novedades.map(function (item, idx) {
            return (
              <div key={idx} className="border-l-4 border-emerald-500 pl-4">
                <p className="text-xs text-slate-500">{item.fecha}</p>
                <h4 className="font-semibold text-slate-900">{item.titulo}</h4>
                <p className="text-sm">{item.desc}</p>
              </div>
            );
          })}
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t flex items-center justify-end">
          <button
            onClick={onClose}
            className="rounded-lg border border-slate-300 px-3 py-2 text-slate-700 hover:bg-slate-50"
          >
            {t.close}
          </button>
        </div>
      </div>
    </div>
  );
}


function HelpModal({ open, onClose, lang = "es" }) {
  const [search, setSearch] = React.useState("");

  React.useEffect(() => {
    const onKey = (e) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [onClose]);

  if (!open) return null;

  // Diccionario base
  const dict = {
    es: {
      title: "Ayuda (FAQ)",
      placeholder: "Buscar: contraseña, horarios, precios…",
      noResults: (s) => `No encontramos resultados para “${s}”. Probá con otra palabra.`,
      cta: "¿Seguís con dudas? Escribinos y te ayudamos.",
      ctaBtn: "Abrir WhatsApp",
      close: "Cerrar",
      faqs: [
        {
          q: "¿Cómo creo mi cuenta?",
          a: "En la pantalla de inicio elegí “Crear cuenta”, ingresá tu email y una contraseña (mínimo 6 caracteres) y presioná Registrarse.",
          tags: ["cuenta", "registro", "email"],
        },
        {
          q: "Olvidé mi contraseña",
          a: "Desde Iniciar sesión tocá “Olvidé mi contraseña”. Ingresá tu email y te enviamos un link para restablecerla.",
          tags: ["contraseña", "reset", "email"],
        },
        {
          q: "¿Puedo cobrar por clase y por abono?",
          a: "Sí. Configurá precios por clase y mensuales en Onboarding > Precios. Luego elegís por alumno cómo facturar.",
          tags: ["precios", "cobros", "clase", "mensual"],
        },
        {
          q: "¿Cómo agrego mis horarios?",
          a: "En Onboarding > Horario Laboral sumá bloques por día y definí Desde/Hasta. El botón “+ Agregar bloque” te permite crear más tramos.",
          tags: ["horarios", "agenda", "onboarding"],
        },
        {
          q: "¿Puedo enviar comprobantes por WhatsApp?",
          a: "Sí. Desde el detalle del cobro generás el comprobante y lo compartís por WhatsApp con un clic.",
          tags: ["comprobantes", "whatsapp", "cobros"],
        },
        {
          q: "¿Cómo contacto soporte?",
          a: "Escribinos por WhatsApp (Lun–Vie 9 a 18 hs) y te ayudamos paso a paso.",
          tags: ["soporte", "contacto", "ayuda"],
        },
      ],
    },
    en: {
      title: "Help (FAQ)",
      placeholder: "Search: password, schedule, pricing…",
      noResults: (s) => `No results found for “${s}”. Try another keyword.`,
      cta: "Still have questions? Contact us and we’ll help you.",
      ctaBtn: "Open WhatsApp",
      close: "Close",
      faqs: [
        {
          q: "How do I create my account?",
          a: "On the home screen, choose “Create Account”, enter your email and a password (minimum 6 characters), then click Register.",
          tags: ["account", "register", "email"],
        },
        {
          q: "I forgot my password",
          a: "From Sign In, click “Forgot password?”. Enter your email and we’ll send you a reset link.",
          tags: ["password", "reset", "email"],
        },
        {
          q: "Can I charge per class and with subscription?",
          a: "Yes. Configure per-class and monthly pricing in Onboarding > Pricing. Then choose per student how to bill.",
          tags: ["pricing", "payments", "class", "monthly"],
        },
        {
          q: "How do I add my schedule?",
          a: "In Onboarding > Work Schedule, add blocks per day and set From/To. The “+ Add block” button lets you create more ranges.",
          tags: ["schedule", "agenda", "onboarding"],
        },
        {
          q: "Can I send receipts via WhatsApp?",
          a: "Yes. From the payment detail, generate the receipt and share it via WhatsApp with one click.",
          tags: ["receipts", "whatsapp", "payments"],
        },
        {
          q: "How do I contact support?",
          a: "Message us on WhatsApp (Mon–Fri 9am–6pm) and we’ll guide you step by step.",
          tags: ["support", "contact", "help"],
        },
      ],
    },
  };

  const t = dict[lang] || dict.es;

  // Búsqueda
  const normalized = (s) => (s || "").toLowerCase();
  const filtered = t.faqs.filter(({ q, a, tags }) => {
    if (!search) return true;
    const term = normalized(search);
    return (
      normalized(q).includes(term) ||
      normalized(a).includes(term) ||
      (tags || []).some((tg) => normalized(tg).includes(term))
    );
  });

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      role="dialog"
      aria-modal="true"
      aria-labelledby="help-title"
      onClick={onClose}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div
        className="relative bg-white w-full max-w-3xl mx-4 rounded-2xl shadow-xl"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b">
          <h3 id="help-title" className="text-lg font-semibold text-slate-900">
            {t.title}
          </h3>
          <button
            onClick={onClose}
            className="rounded-full p-2 text-slate-600 hover:bg-slate-100"
            aria-label={t.close}
            title={t.close}
          >
            ✕
          </button>
        </div>

        {/* Buscador */}
        <div className="px-6 pt-4">
          <div className="relative">
            <input
              type="text"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              placeholder={t.placeholder}
              className="w-full rounded-xl border border-slate-300 px-3 py-2 pr-10 focus:outline-none focus:ring-2 focus:ring-emerald-600"
              aria-label={t.placeholder}
            />
            <span className="absolute right-3 top-1/2 -translate-y-1/2 text-slate-400">🔎</span>
          </div>
        </div>

        {/* Lista de preguntas */}
        <div className="px-6 py-4 max-h-[60vh] overflow-y-auto">
          {filtered.length === 0 ? (
            <p className="text-sm text-slate-500">{t.noResults(search)}</p>
          ) : (
            <div className="space-y-3">
              {filtered.map((item, idx) => (
                <details key={idx} className="group rounded-xl border border-slate-200 p-4 bg-white">
                  <summary className="cursor-pointer font-medium text-slate-800 flex items-center justify-between">
                    {item.q}
                    <span className="text-slate-400 group-open:rotate-180 transition">⌄</span>
                  </summary>
                  <p className="mt-2 text-sm text-slate-600">{item.a}</p>
                </details>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t flex items-center justify-between gap-3">
          <p className="text-xs text-slate-500">{t.cta}</p>
          <a
            href="https://wa.me/5493810000000" // tu número
            target="_blank" rel="noopener"
            className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-white hover:bg-emerald-700"
          >
            {t.ctaBtn}
          </a>
        </div>
      </div>
    </div>
  );
}



function PrivacyModal({ open, onClose, lang = "es" }) {
  if (!open) return null;

  // Diccionario ES/EN
  const t = (lang === "en") ? {
    title: "Privacy Policy",
    close: "Close",
    updatedLabel: "Last updated",
    s1Title: "1. Introduction",
    s1Body: <>At <strong>Coachex-Pro</strong> we value your privacy. This policy explains what data we collect and how we use it.</>,
    s2Title: "2. Data collected",
    s2Items: [
      "Registration data: email and password.",
      "Management data: students, classes, payments, club settings.",
      "Technical metadata: basic usage info (date/time of access).",
    ],
    s3Title: "3. Use of information",
    s3Body: "Data is used solely to provide and improve the service. We never sell data to third parties.",
    s4Title: "4. Storage",
    s4Body: <>Your information is stored on <strong>Google Firebase</strong> servers, following international security standards.</>,
    s5Title: "5. User rights",
    s5Body: "You can request deletion of your account and data by contacting our support email.",
    dateLocale: "en-US",
  } : {
    title: "Política de Privacidad",
    close: "Cerrar",
    updatedLabel: "Última actualización",
    s1Title: "1. Introducción",
    s1Body: <>En <strong>Coachex-Pro</strong> valoramos tu privacidad. Esta política explica qué datos recopilamos y cómo los usamos.</>,
    s2Title: "2. Datos recopilados",
    s2Items: [
      "Datos de registro: email y contraseña.",
      "Datos de gestión: alumnos, clases, pagos, configuraciones de club.",
      "Metadatos técnicos: información básica de uso (fecha/hora de acceso).",
    ],
    s3Title: "3. Uso de la información",
    s3Body: "Los datos se utilizan exclusivamente para brindar y mejorar el servicio. Nunca se venden a terceros.",
    s4Title: "4. Almacenamiento",
    s4Body: <>Tu información se guarda en servidores de <strong>Google Firebase</strong>, con estándares de seguridad internacionales.</>,
    s5Title: "5. Derechos del usuario",
    s5Body: "Podés solicitar la eliminación de tu cuenta y datos escribiendo a nuestro correo de soporte.",
    dateLocale: "es-AR",
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      role="dialog"
      aria-modal="true"
      aria-labelledby="privacy-title"
      onClick={onClose}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div
        className="relative bg-white w-full max-w-3xl mx-4 rounded-2xl shadow-xl"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b">
          <h3 id="privacy-title" className="text-lg font-semibold text-slate-900">
            {t.title}
          </h3>
          <button
            onClick={onClose}
            className="rounded-full p-2 text-slate-600 hover:bg-slate-100"
            aria-label={t.close}
            title={t.close}
          >
            ✕
          </button>
        </div>

        {/* Contenido con scroll */}
        <div className="px-6 py-5 max-h-[70vh] overflow-y-auto space-y-6 text-slate-700">
          <section>
            <h4 className="font-semibold text-slate-900 mb-1">{t.s1Title}</h4>
            <p>{t.s1Body}</p>
          </section>

          <section>
            <h4 className="font-semibold text-slate-900 mb-1">{t.s2Title}</h4>
            <ul className="list-disc list-inside space-y-1">
              {t.s2Items.map((li, i) => <li key={i}>{li}</li>)}
            </ul>
          </section>

          <section>
            <h4 className="font-semibold text-slate-900 mb-1">{t.s3Title}</h4>
            <p>{t.s3Body}</p>
          </section>

          <section>
            <h4 className="font-semibold text-slate-900 mb-1">{t.s4Title}</h4>
            <p>{t.s4Body}</p>
          </section>

          <section>
            <h4 className="font-semibold text-slate-900 mb-1">{t.s5Title}</h4>
            <p>{t.s5Body}</p>
          </section>

          <p className="text-xs text-slate-500">
            {t.updatedLabel}: {new Date().toLocaleDateString(t.dateLocale, { year:'numeric', month:'long' })}
          </p>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t flex items-center justify-end gap-2">
          <button
            onClick={onClose}
            className="rounded-lg border border-slate-300 px-3 py-2 text-slate-700 hover:bg-slate-50"
          >
            {t.close}
          </button>
        </div>
      </div>
    </div>
  );
}


function TermsModal({ open, onClose, lang = "es" }) {
  if (!open) return null;

  // Diccionario ES/EN
  const t = (lang === "en") ? {
    title: "Terms of Use",
    close: "Close",
    updatedLabel: "Last updated",
    dateLocale: "en-US",
    sections: [
      {
        h: "1. Introduction",
        p: <>Welcome to <strong>Coachex-Pro</strong>, a platform for tennis/padel coaches and clubs. By using the app, you agree to these terms.</>
      },
      {
        h: "2. Permitted Use",
        p: "The app is for professional purposes only. Illegal, fraudulent, or abusive use is prohibited."
      },
      {
        h: "3. Accounts and Security",
        p: "You are responsible for maintaining the confidentiality of your credentials and for any activity under your account."
      },
      {
        h: "4. Intellectual Property",
        p: <>Software, design, and brand belong to Coachex-Pro. The data you upload remains yours, and you keep all rights over it.</>
      },
      {
        h: "5. Payments and Fees",
        p: "Some features may be subject to paid plans. Prices and billing cycles will be communicated before any charge."
      },
      {
        h: "6. Data and Privacy",
        p: <>We store information on <strong>Google Firebase</strong>. We do not sell data to third parties. See the Privacy Policy for more details.</>
      },
      {
        h: "7. Service Availability",
        p: "The service is provided “as is”. We strive for high availability but do not guarantee uninterrupted access."
      },
      {
        h: "8. Changes to the Service/Terms",
        p: "We may update features and these terms. We will notify you of relevant changes within the app."
      },
      {
        h: "9. Contact",
        p: "Questions or requests: soporte@coachex.pro"
      }
    ]
  } : {
    title: "Términos de Uso",
    close: "Cerrar",
    updatedLabel: "Última actualización",
    dateLocale: "es-AR",
    sections: [
      {
        h: "1. Introducción",
        p: <>Bienvenido a <strong>Coachex-Pro</strong>, una plataforma para profesores y clubes de tenis/pádel. Al usar la app aceptás estos términos.</>
      },
      {
        h: "2. Uso permitido",
        p: "La app es para fines profesionales. No se permite uso ilegal, fraudulento ni abusivo."
      },
      {
        h: "3. Cuenta y seguridad",
        p: "Sos responsable por mantener segura tu contraseña y por las actividades realizadas con tu cuenta."
      },
      {
        h: "4. Propiedad intelectual",
        p: <>El software, diseño y marca pertenecen a Coachex-Pro. Los datos que cargues siguen siendo tuyos y conservás todos los derechos sobre ellos.</>
      },
      {
        h: "5. Pagos y planes",
        p: "Algunas funciones pueden requerir planes pagos. Precios y ciclos de facturación se informarán antes de cualquier cobro."
      },
      {
        h: "6. Datos y privacidad",
        p: <>Almacenamos información en <strong>Google Firebase</strong>. No vendemos datos a terceros. Consultá la Política de Privacidad para más detalle.</>
      },
      {
        h: "7. Disponibilidad del servicio",
        p: "El servicio se brinda “tal cual”. Buscamos alta disponibilidad pero no garantizamos acceso ininterrumpido."
      },
      {
        h: "8. Cambios en el servicio/términos",
        p: "Podemos actualizar funcionalidades y estos términos. Avisaremos cambios relevantes dentro de la app."
      },
      {
        h: "9. Contacto",
        p: "Consultas o solicitudes: soporte@coachex.pro"
      }
    ]
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      role="dialog"
      aria-modal="true"
      aria-labelledby="terms-title"
      onClick={onClose}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div
        className="relative bg-white w-full max-w-3xl mx-4 rounded-2xl shadow-xl"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b">
          <h3 id="terms-title" className="text-lg font-semibold text-slate-900">
            {t.title}
          </h3>
          <button
            onClick={onClose}
            className="rounded-full p-2 text-slate-600 hover:bg-slate-100"
            aria-label={t.close}
            title={t.close}
          >
            ✕
          </button>
        </div>

        {/* Contenido con scroll */}
        <div className="px-6 py-5 max-h-[70vh] overflow-y-auto space-y-6 text-slate-700">
          {t.sections.map((sec, i) => (
            <section key={i}>
              <h4 className="font-semibold text-slate-900 mb-1">{sec.h}</h4>
              <p>{sec.p}</p>
            </section>
          ))}
          <p className="text-xs text-slate-500">
            {t.updatedLabel}: {new Date().toLocaleDateString(t.dateLocale, { year:'numeric', month:'long' })}
          </p>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 border-t flex items-center justify-end gap-2">
          <button
            onClick={onClose}
            className="rounded-lg border border-slate-300 px-3 py-2 text-slate-700 hover:bg-slate-50"
          >
            {t.close}
          </button>
        </div>
      </div>
    </div>
  );
}



// === Diccionario de traducciones ===
const texts = {
  es: {
    login: "Iniciar Sesión",
    register: "Crear Cuenta",
    reset: "Restablecer Contraseña",
    email: "Email",
    password: "Contraseña",
    forgot: "¿Olvidaste tu contraseña?",
    noAccount: "¿No tenés cuenta? Registrate",
    haveAccount: "¿Ya tenés cuenta? Ingresá",
    send: "Enviar correo",
    welcome: "Bienvenido a Coachex-Pro",
    terms: "Términos",
    privacy: "Privacidad",
    help: "Ayuda",
    news: "Novedades"
  },
  en: {
    login: "Sign In",
    register: "Create Account",
    reset: "Reset Password",
    email: "Email",
    password: "Password",
    forgot: "Forgot your password?",
    noAccount: "Don’t have an account? Sign up",
    haveAccount: "Already have an account? Sign in",
    send: "Send email",
    welcome: "Welcome to Coachex-Pro",
    terms: "Terms",
    privacy: "Privacy",
    help: "Help",
    news: "News"
  }
};

function MiniSpinner({ className = "h-4 w-4" }) {
  return (
    <svg className={`animate-spin ${className}`} viewBox="0 0 24 24" aria-hidden="true">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none"/>
      <path className="opacity-90" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"/>
    </svg>
  );
}

function getAuthErrorInfo(code, lang = "es") {
  const L = (lang === "en")
    ? {
        generic: "There was a problem signing in.",
        userNotFound: "We couldn't find that email. Do you want to create an account?",
        wrongPassword: "Incorrect password. You can try resetting it.",
        invalidEmail: "Please enter a valid email address.",
        tooMany: "Too many attempts. Please wait a moment and try again.",
        weakPassword: "Password must be at least 6 characters.",
      }
    : {
        generic: "Hubo un problema al iniciar sesión.",
        userNotFound: "No encontramos ese email. ¿Querés crear una cuenta?",
        wrongPassword: "Contraseña incorrecta. Podés intentar restablecerla.",
        invalidEmail: "Ingresá un email válido.",
        tooMany: "Demasiados intentos. Esperá un momento y volvé a intentar.",
        weakPassword: "La contraseña debe tener al menos 6 caracteres.",
      };

  switch (code) {
    case "auth/user-not-found":     return { msg: L.userNotFound, tip: "user-not-found" };
    case "auth/wrong-password":     return { msg: L.wrongPassword, tip: "wrong-password" };
    case "auth/invalid-email":      return { msg: L.invalidEmail, tip: "invalid-email" };
    case "auth/too-many-requests":  return { msg: L.tooMany, tip: "too-many-requests" };
    case "auth/weak-password":      return { msg: L.weakPassword, tip: "weak-password" };
    default:                        return { msg: L.generic, tip: "generic" };
  }
}
    
function LoginScreen() {
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');
  const [error, setError] = React.useState('');
  const [message, setMessage] = React.useState('');
  const [view, setView] = React.useState('login');
  const [loading, setLoading] = React.useState(false);
  const [showPwd, setShowPwd] = React.useState(false);

  // Idioma
  const [lang, setLang] = React.useState("es");


  // ⬇️ ESTADOS DE MODALES (AÑADIDOS)
  const [termsOpen, setTermsOpen]     = React.useState(false);
  const [privacyOpen, setPrivacyOpen] = React.useState(false);
  const [helpOpen, setHelpOpen]       = React.useState(false);
  const [newsOpen, setNewsOpen]       = React.useState(false);
  const [errorCode, setErrorCode] = React.useState(""); // auth/error code (ej: "auth/user-not-found")
  const [capsOn, setCapsOn] = React.useState(false);


  const mountedRef = React.useRef(true);
  React.useEffect(() => () => { mountedRef.current = false; }, []);

  // ⬇️ acciones de auth
  const handleAuthAction = async (e) => {
    e.preventDefault();
    mountedRef.current && setLoading(true);
    mountedRef.current && setError('');
    mountedRef.current && setMessage('');
    try {
      if (view === 'register') {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await db.collection('users').doc(userCredential.user.uid)
          .collection('profile').doc('main').set(initialState.perfil);
      } else {
        await auth.signInWithEmailAndPassword(email, password);
      }
    } catch (err) {
  const info = getAuthErrorInfo(err?.code, lang);
  setError(info.msg);
  setErrorCode(err?.code || "");
} finally {
      setLoading(false);
    }
  };

  const handlePasswordReset = async (e) => {
    e.preventDefault();
    mountedRef.current && setLoading(true);
    mountedRef.current && setError('');
    mountedRef.current && setMessage('');
    try {
      await auth.sendPasswordResetEmail(email);
      mountedRef.current && setMessage(
        lang === "es" 
          ? "Se envió un correo para restablecer tu contraseña." 
          : "A password reset email has been sent."
      );
    } catch (err) {
  const info = getAuthErrorInfo(err?.code, lang);
  setError(info.msg);
  setErrorCode(err?.code || "");
} finally {
      setLoading(false);
    }
  };

return (
  <main className="min-h-screen bg-gradient-to-b from-emerald-50/40 to-white">
    <div className="mx-auto w-full max-w-[680px] px-4 pt-10 sm:pt-14 pb-8">

      {/* Header compacto */}
      <div className="flex flex-col items-center gap-2 mb-6">
        <img
          src="logo_favicon.png"
          alt="Coachex-Pro"
          className="h-12 w-12 rounded-full ring-2 ring-emerald-200 shadow-sm"
        />
        <h1 className="text-xl sm:text-2xl font-semibold text-slate-800 tracking-tight">
          {texts[lang].welcome}
        </h1>
      </div>

      {/* Card compacta */}
      <div className="rounded-xl border border-slate-200 bg-white shadow-md p-5 sm:p-6">
        {/* LOGIN */}
        {view === 'login' && (
          <div>
            <h2 className="text-xl sm:text-2xl font-semibold text-center text-slate-800">
              {texts[lang].login}
            </h2>
            <div className="h-px bg-slate-100 my-3" />

            <form onSubmit={handleAuthAction} className="space-y-3">
              <div>
                <label className="text-sm font-medium text-slate-600">
                  {texts[lang].email}
                </label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full mt-1 h-11 text-[15px] border rounded-lg px-3 py-2
                             focus:outline-none focus:ring-2 focus:ring-emerald-600"
                  disabled={loading}
                  required
                />
              </div>

              <div>
                <label className="text-sm font-medium text-slate-600">
                  {texts[lang].password}
                </label>
                <div className="relative">
                  <input
  type={showPwd ? 'text' : 'password'}
  value={password}
  onChange={(e) => setPassword(e.target.value)}
  onKeyUp={(e) => setCapsOn(e.getModifierState && e.getModifierState('CapsLock'))}
  className="w-full mt-1 h-11 text-[15px] border rounded-lg px-3 pr-10 focus:outline-none focus:ring-2 focus:ring-emerald-600"
  disabled={loading}
  required
/>
                  <button
                    type="button"
                    onClick={() => setShowPwd((s) => !s)}
                    className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-500 hover:text-slate-700 text-sm"
                    aria-label={showPwd ? 'Ocultar contraseña' : 'Mostrar contraseña'}
                  >
                    {showPwd ? '🙈' : '👁️'}
                  </button>
                </div>
                {capsOn && (
                  <p className="mt-1 text-xs text-amber-600">
                    {lang === "es" ? "Bloq Mayús activado" : "Caps Lock is on"}
                  </p>
                )}
              </div>

              {/* Error mejorado */}
              {error && (
                <div
                  role="alert" aria-live="assertive"
                  className="rounded-lg bg-red-50 border border-red-200 px-3 py-2 text-sm text-red-700"
                >
                  <p>{error}</p>
                  <div className="mt-2 flex flex-wrap items-center gap-x-3 gap-y-1">
                    {errorCode === "auth/user-not-found" && (
                      <button type="button" onClick={() => setView('register')}
                        className="inline-flex items-center gap-1 text-red-700 underline underline-offset-2 hover:text-red-800">
                        {lang === "es" ? "Crear cuenta" : "Create account"}
                      </button>
                    )}
                    {errorCode === "auth/wrong-password" && (
                      <button type="button" onClick={() => setView('reset')}
                        className="inline-flex items-center gap-1 text-red-700 underline underline-offset-2 hover:text-red-800">
                        {lang === "es" ? "Restablecer contraseña" : "Reset password"}
                      </button>
                    )}
                  </div>
                </div>
              )}

              <button
                type="submit"
                disabled={loading}
                className="w-full h-11 rounded-lg bg-[#34745B] hover:bg-[#2E6D56]
                           text-white font-semibold shadow-sm transition
                           disabled:opacity-50 disabled:cursor-not-allowed"
                aria-busy={loading ? "true" : "false"}
              >
                {loading ? (
                  <span className="inline-flex items-center gap-2">
                    <MiniSpinner className="h-4 w-4" />
                    {lang === "es" ? "Ingresando..." : "Signing in..."}
                  </span>
                ) : (
                  texts[lang].login
                )}
              </button>
            </form>

            <div className="text-center mt-3">
              <button
                onClick={() => setView('reset')}
                className="text-sm text-[#34745B] hover:text-[#2E6D56] font-medium underline underline-offset-2"
              >
                {texts[lang].forgot}
              </button>
            </div>
            <div className="text-center mt-1">
              <button
                onClick={() => setView('register')}
                className="text-sm text-slate-600 hover:underline"
              >
                {texts[lang].noAccount}
              </button>
            </div>
          </div>
        )}

        {/* REGISTER */}
        {view === 'register' && (
          <div>
            <h2 className="text-xl sm:text-2xl font-semibold text-center text-slate-800">
              {texts[lang].register}
            </h2>
            <div className="h-px bg-slate-100 my-3" />
            <form onSubmit={handleAuthAction} className="space-y-3">
              <div>
                <label className="text-sm font-medium text-slate-600">
                  {texts[lang].email}
                </label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full mt-1 h-11 text-[15px] border rounded-lg px-3 py-2
                             focus:outline-none focus:ring-2 focus:ring-emerald-600"
                  disabled={loading}
                  required
                />
              </div>
              <div>
                <label className="text-sm font-medium text-slate-600">
                  {texts[lang].password}
                </label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full mt-1 h-11 text-[15px] border rounded-lg px-3 py-2
                             focus:outline-none focus:ring-2 focus:ring-emerald-600"
                  disabled={loading}
                  required
                />
                {/* Indicador simple de fuerza (opcional, si lo agregaste) */}
                {/* ... */}
              </div>

              {error && (
                <div role="alert" aria-live="assertive"
                  className="rounded-lg bg-red-50 border border-red-200 px-3 py-2 text-sm text-red-700">
                  <p>{error}</p>
                </div>
              )}

              <button
                type="submit"
                disabled={loading}
                className="w-full h-11 rounded-lg bg-slate-800 hover:bg-slate-900
                           text-white font-semibold shadow-sm transition
                           disabled:opacity-60 disabled:cursor-not-allowed"
              >
                {loading ? (
                  <span className="inline-flex items-center gap-2">
                    <MiniSpinner className="h-4 w-4" />
                    {lang === "es" ? "Creando cuenta..." : "Creating account..."}
                  </span>
                ) : (
                  texts[lang].register
                )}
              </button>
            </form>

            <div className="text-center mt-3">
              <button onClick={() => setView('login')}
                className="text-sm text-slate-600 hover:underline">
                {texts[lang].haveAccount}
              </button>
            </div>
          </div>
        )}

        {/* RESET */}
        {view === 'reset' && (
          <div>
            <h2 className="text-xl sm:text-2xl font-semibold text-center text-slate-800">
              {texts[lang].reset}
            </h2>
            <div className="h-px bg-slate-100 my-3" />
            <form onSubmit={handlePasswordReset} className="space-y-3">
              <div>
                <label className="text-sm font-medium text-slate-600">
                  {texts[lang].email}
                </label>
                <input
                  type="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full mt-1 h-11 text-[15px] border rounded-lg px-3 py-2
                             focus:outline-none focus:ring-2 focus:ring-emerald-600"
                  disabled={loading}
                  required
                />
              </div>

              {error && (
                <div role="alert" aria-live="assertive"
                  className="rounded-lg bg-red-50 border border-red-200 px-3 py-2 text-sm text-red-700">
                  <p>{error}</p>
                </div>
              )}
              {message && (
                <p className="text-sm text-green-600">{message}</p>
              )}

              <button
                type="submit"
                disabled={loading}
                className="w-full h-11 rounded-lg bg-slate-900 hover:bg-slate-700
                           text-white font-semibold shadow-sm transition
                           disabled:opacity-60 disabled:cursor-not-allowed"
              >
                {loading ? (
                  <span className="inline-flex items-center gap-2">
                    <MiniSpinner className="h-4 w-4" />
                    {lang === "es" ? "Enviando..." : "Sending..."}
                  </span>
                ) : (
                  texts[lang].send
                )}
              </button>
            </form>

            <div className="text-center mt-3">
              <button onClick={() => setView('login')}
                className="text-sm text-slate-600 hover:underline">
                {texts[lang].login}
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Footer (igual que lo tenés) */}
      <footer className="px-4 sm:px-6 pb-8 mt-10">
  <div className="max-w-6xl mx-auto flex flex-col sm:flex-row items-center justify-between gap-3 text-sm text-slate-500">
    <div className="flex items-center gap-3">
      <button type="button" onClick={() => setTermsOpen(true)}   className="hover:underline">{texts[lang].terms}</button>
      <span className="opacity-50">•</span>
      <button type="button" onClick={() => setPrivacyOpen(true)} className="hover:underline">{texts[lang].privacy}</button>
      <span className="opacity-50">•</span>
      <button type="button" onClick={() => setHelpOpen(true)}    className="hover:underline">{texts[lang].help}</button>
      <span className="opacity-50">•</span>
      <button type="button" onClick={() => setNewsOpen(true)}    className="hover:underline">{texts[lang].news}</button>
    </div>

    <div className="flex items-center gap-3">
      <span>v1.0.0</span>
      <span className="opacity-50">•</span>
      <span>© {new Date().getFullYear()} Coachex-Pro</span>
      <select value={lang} onChange={(e)=>setLang(e.target.value)} className="ml-2 rounded-md border px-2 py-1">
        <option value="es">ES</option><option value="en">EN</option>
      </select>
    </div>
  </div>
</footer>

      {/* Modales (igual) */}
      {termsOpen   && <TermsModal   lang={lang} open={termsOpen}   onClose={() => setTermsOpen(false)} />}
      {privacyOpen && <PrivacyModal lang={lang} open={privacyOpen} onClose={() => setPrivacyOpen(false)} />}
      {helpOpen    && <HelpModal    lang={lang} open={helpOpen}    onClose={() => setHelpOpen(false)} />}
      {newsOpen    && <NewsModal    lang={lang} open={newsOpen}    onClose={() => setNewsOpen(false)} />}

      {/* Overlay de carga global (si lo agregaste) */}
      {loading && (
        <div className="fixed inset-0 z-[60] grid place-items-center bg-white/60 backdrop-blur-sm">
          <div className="flex flex-col items-center gap-3 text-slate-700">
            <MiniSpinner className="h-6 w-6" />
            <p className="text-sm">
              {lang === "es" ? "Procesando..." : "Processing..."}
            </p>
          </div>
        </div>
      )} 

    </div> 
  </main>  
);          
}           


// === Wrapper visual reutilizable ===
function BienvenidaCoachex({ children }) {
  return (
    <main className="min-h-[calc(100vh-80px)] relative overflow-hidden bg-gradient-to-b from-gray-50 via-white to-white">
      {/* Ornamentos suaves */}
      <div className="pointer-events-none absolute -top-24 -left-24 h-72 w-72 rounded-full bg-emerald-100/50 blur-3xl" />
      <div className="pointer-events-none absolute -bottom-24 -right-24 h-72 w-72 rounded-full bg-emerald-50/70 blur-3xl" />

      <div className="max-w-5xl mx-auto px-4 sm:px-6 py-10 sm:py-12">
        {children}
      </div>
    </main>
  );
}

// === REEMPLAZAR tu componente por este ===
function OnboardingClubSetup({ user, setHasClubs, onLogout }) {
  // Mostrar días completos pero manejar código corto internamente
  const DIAS = [
    { label: "Lunes",     code: "Lu" },
    { label: "Martes",    code: "Ma" },
    { label: "Miércoles", code: "Mi" },
    { label: "Jueves",    code: "Ju" },
    { label: "Viernes",   code: "Vi" },
    { label: "Sábado",    code: "Sa" },
    { label: "Domingo",   code: "Do" },
  ];
  const getLabelByCode = (code) => DIAS.find(d => d.code === code)?.label || code;

  // ---- State
  const [nombre, setNombre] = React.useState("");
  const [modalidad, setModalidad] = React.useState("Por Clase");
  const [repProfesor, setRepProfesor] = React.useState(60); // editás este
  const repClub = Math.max(0, Math.min(100, 100 - Number(repProfesor || 0))); // se calcula solo

  const [horario, setHorario] = React.useState([
    { id: cryptoRandomId(), diaCode: "Lu", desde: "08:00", hasta: "12:00" },
  ]);

  const [preciosClase, setPreciosClase] = React.useState({ p1: 0, p2: 0, p3: 0, p4: 0, escuelita: 0 });
  const [preciosMensual, setPreciosMensual] = React.useState({ x1: 0, x2: 0, x3: 0, libre: 0 });

  // ---- Validación
  const profesorValid = Number.isFinite(Number(repProfesor)) && Number(repProfesor) >= 0 && Number(repProfesor) <= 100;
  const invalidIds = horario.filter(b => !isBlockValid(b)).map(b => b.id);
  const horariosValidos = invalidIds.length === 0;
  const canSave = user && nombre.trim().length > 0 && profesorValid && horariosValidos;

  // ---- Helpers
  function cryptoRandomId() { return Math.random().toString(36).slice(2, 10); }
  function toMinutes(hhmm) { if (!hhmm || typeof hhmm !== "string") return NaN; const [h, m] = hhmm.split(":").map(Number); return h * 60 + (m || 0); }
  function isBlockValid(b) { const d = toMinutes(b.desde); const h = toMinutes(b.hasta); return Number.isFinite(d) && Number.isFinite(h) && d < h; }

  const addBloque    = () => setHorario(h => [...h, { id: cryptoRandomId(), diaCode: "Lu", desde: "08:00", hasta: "12:00" }]);
  const removeBloque = (id) => setHorario(h => h.filter(b => b.id !== id));
  const updateBloque = (id, patch) => setHorario(h => h.map(b => b.id === id ? { ...b, ...patch } : b));

  const onChangeMoney = (objSetter) => (key) => (e) => {
    const raw = (e.target.value || "").replace(",", ".");
    const n = raw === "" ? "" : Number(raw);
    objSetter(prev => ({ ...prev, [key]: isNaN(n) ? 0 : n }));
  };

  const guardar = async () => {
    try {
      const ref = db.collection("users").doc(user.uid).collection("clubs").doc();
      const doc = {
        nombre,
        modalidadCobroPrincipal: modalidad,
        reparto: { profesor: Number(repProfesor)||0, club: repClub },
        // Guardamos tanto el code como el label para facilitar lecturas futuras
        horarioLaboral: horario.map(b => ({
          diaCode: b.diaCode,
          diaLabel: getLabelByCode(b.diaCode),
          desde: b.desde,
          hasta: b.hasta
        })),
        precios: {
          porClase: {
            "1": Number(preciosClase.p1)||0,
            "2": Number(preciosClase.p2)||0,
            "3": Number(preciosClase.p3)||0,
            "4": Number(preciosClase.p4)||0,
            escuelita: Number(preciosClase.escuelita)||0
          },
          mensuales: {
            x1: Number(preciosMensual.x1)||0,
            x2: Number(preciosMensual?.x2 ?? preciosMensual.x2)||0,
            x3: Number(preciosMensual.x3)||0,
            libre: Number(preciosMensual.libre)||0
          }
        },
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      await ref.set(doc);
      setHasClubs(true);
    } catch (err) {
      console.error("Error guardando club:", err);
      alert("No se pudo guardar. Revisá la consola para más detalles.");
    }
  };

  // ---- UI (embellecida con wrapper + layout + aside)
  return (
    <BienvenidaCoachex>
      {/* Header */}
      <div className="text-center">
        <img
          src="./logo_favicon.png"
          alt="Coachex-Pro"
          className="w-20 h-20 mx-auto rounded-full ring-2 ring-white/80 shadow-sm"
          onError={(e) => {
            e.currentTarget.onerror = null;
            e.currentTarget.src = "/img/logo_favicon.png"; // fallback por si cambia el base path
          }}
        />
        <h1 className="mt-4 text-3xl sm:text-4xl font-semibold tracking-tight text-slate-900">
          Bienvenido a Coachex-Pro
        </h1>
        <p className="mt-2 text-slate-600">
          Gestión integral para profesores de tenis y pádel.
        </p>
        <p className="text-slate-400">
          Cargá la información del Club en donde trabajás.
        </p>
      </div>

      {/* Contenido principal: Cards + Lateral */}
      <div className="mt-8 grid gap-6 md:grid-cols-3">
        {/* Columna principal con tus cards */}
        <section className="md:col-span-2 space-y-6">
          {/* Card contenedora “Setup” (opcional: agrega borde/sombra suave) */}
          <div className="bg-white/90 backdrop-blur rounded-2xl shadow-sm border border-slate-200">
            <div className="px-5 sm:px-6 py-4 border-b">
              <h2 className="text-base sm:text-lg font-semibold text-[#34745B]">
                Completar datos del Club
              </h2>
              <p className="text-xs text-slate-500">
                Esto nos ayuda a personalizar tus comprobantes y agenda.
              </p>
            </div>

            <div className="p-5 sm:p-6">
              {/* === Tus Cards existentes (sin tocar lógica) === */}
              <div className="grid md:grid-cols-2 gap-6">
                {/* Configuración General */}
                <SetupCard title="Configuración General">
                  <SetupLabel>Nombre del Club</SetupLabel>
                  <SetupInput value={nombre} onChange={e=>setNombre(e.target.value)} placeholder="Ej: Club..." />

                  <SetupLabel className="mt-4">Modalidad de Cobro Principal</SetupLabel>
                  <SetupSelect value={modalidad} onChange={e=>setModalidad(e.target.value)}>
                    <option>Por Clase</option>
                    <option>Mensual</option>
                  </SetupSelect>

                  <div className="grid grid-cols-2 gap-3 mt-4 items-end">
                    <SetupPercentField
                      label="Reparto (Profesor)"
                      value={repProfesor}
                      onChange={e => {
                        const v = Math.max(0, Math.min(100, Number(e.target.value || 0)));
                        setRepProfesor(v);
                      }}
                    />
                    <SetupPercentField
                      label="Reparto (Club)"
                      value={repClub}
                      readOnly
                      tooltip="Se calcula automáticamente como 100% - Profesor"
                    />
                  </div>
                  {!profesorValid && (
                    <p className="mt-2 text-xs text-red-600">El % del profesor debe estar entre 0 y 100.</p>
                  )}
                </SetupCard>

                {/* Horario Laboral */}
                <SetupCard title="Horario Laboral">
                  <div className="space-y-3">
                    {horario.map(b => {
                      const invalid = !isBlockValid(b);
                      return (
                        <div key={b.id}>
                          <div className="flex flex-wrap items-center gap-2">
                            <SetupSelect
                              value={b.diaCode}
                              onChange={e=>updateBloque(b.id, { diaCode: e.target.value })}
                              className="w-40"
                            >
                              {DIAS.map(d => (
                                <option key={d.code} value={d.code}>{d.label}</option>
                              ))}
                            </SetupSelect>

                            <SetupTimeField
                              value={b.desde}
                              onChange={e=>updateBloque(b.id, { desde: e.target.value })}
                              invalid={invalid}
                              aria-label="Desde"
                            />
                            <span className="text-slate-400 select-none">—</span>
                            <SetupTimeField
                              value={b.hasta}
                              onChange={e=>updateBloque(b.id, { hasta: e.target.value })}
                              invalid={invalid}
                              aria-label="Hasta"
                            />

                            <button
                              className="inline-flex items-center gap-1 rounded-full border border-red-200 text-red-600 px-3 py-1.5 text-sm hover:bg-red-50"
                              onClick={()=>removeBloque(b.id)}
                            >
                              Quitar
                            </button>
                          </div>
                          {invalid && (
                            <p className="mt-1 text-xs text-red-600">
                              El horario no es válido. <span className="font-medium">“Desde”</span> debe ser menor que <span className="font-medium">“Hasta”</span>.
                            </p>
                          )}
                        </div>
                      );
                    })}
                  </div>

                  <button onClick={addBloque}
                          className="mt-3 w-full border-2 border-dashed rounded-xl py-2 text-slate-500 hover:bg-slate-50">
                    + Agregar bloque
                  </button>

                  {!horariosValidos && (
                    <p className="mt-2 text-xs text-red-600">Revisá los bloques en rojo antes de continuar.</p>
                  )}
                </SetupCard>

                {/* Precios por Clase */}
                <SetupCard title="Precios por Clase">
                  <div className="space-y-3">
                    <SetupMoneyField label="Clase para 1 persona" value={preciosClase.p1} onChange={onChangeMoney(setPreciosClase)("p1")} />
                    <SetupMoneyField label="Clase para 2 personas" value={preciosClase.p2} onChange={onChangeMoney(setPreciosClase)("p2")} />
                    <SetupMoneyField label="Clase para 3 personas" value={preciosClase.p3} onChange={onChangeMoney(setPreciosClase)("p3")} />
                    <SetupMoneyField label="Clase para 4 personas" value={preciosClase.p4} onChange={onChangeMoney(setPreciosClase)("p4")} />
                    <SetupMoneyField label="Escuelita" value={preciosClase.escuelita} onChange={onChangeMoney(setPreciosClase)("escuelita")} />
                  </div>
                </SetupCard>

                {/* Precios Mensuales */}
                <SetupCard title="Precios Mensuales">
                  <div className="space-y-3">
                    <SetupMoneyField label="1 vez por semana" value={preciosMensual.x1} onChange={onChangeMoney(setPreciosMensual)("x1")} />
                    <SetupMoneyField label="2 veces por semana" value={preciosMensual.x2} onChange={onChangeMoney(setPreciosMensual)("x2")} />
                    <SetupMoneyField label="3 veces por semana" value={preciosMensual.x3} onChange={onChangeMoney(setPreciosMensual)("x3")} />
                    <SetupMoneyField label="Libre" value={preciosMensual.libre} onChange={onChangeMoney(setPreciosMensual)("libre")} />
                  </div>
                </SetupCard>
              </div>

              {/* CTA */}
              <div className="mt-8 text-center">
                <button
                  className="inline-flex items-center justify-center rounded-xl bg-emerald-600 px-6 py-3 text-white font-semibold shadow hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={!canSave}
                  onClick={guardar}
                >
                  Guardar y Comenzar
                </button>
                {!canSave && (
                  <p className="text-xs text-slate-500 mt-2">
                    Completá el nombre del club, un % de profesor válido y corregí los horarios en rojo.
                  </p>
                )}
              </div>

              <div className="mt-4 text-center">
                <button
                  onClick={onLogout}
                  className="inline-flex items-center justify-center rounded-xl border border-slate-300 px-6 py-2 text-slate-600 hover:bg-slate-100"
                >
                  Volver al inicio de sesión
                </button>
              </div>
            </div>
          </div>
        </section>

        {/* Lateral con “beneficios” + tip */}
        <aside className="space-y-3">
  {/* Beneficio: rápido */}
  <div className="bg-white rounded-2xl border border-slate-200 p-4 shadow-sm">
    <div className="flex items-start gap-3">
      <div className="shrink-0 h-9 w-9 rounded-xl grid place-content-center bg-emerald-50">⚡</div>
      <div>
        <h3 className="font-semibold text-slate-800">Rápido de completar</h3>
        <p className="text-sm text-slate-600">
          Solo pedimos lo esencial para empezar a facturar y agendar.
        </p>
      </div>
    </div>
  </div>

  {/* Beneficio: datos seguros */}
  <div className="bg-white rounded-2xl border border-slate-200 p-4 shadow-sm">
    <div className="flex items-start gap-3">
      <div className="shrink-0 h-9 w-9 rounded-xl grid place-content-center bg-emerald-50">🔒</div>
      <div>
        <h3 className="font-semibold text-slate-800">Datos seguros</h3>
        <p className="text-sm text-slate-600">
          Tus datos se guardan en tu cuenta y solo vos podés verlos.
        </p>
      </div>
    </div>
  </div>

  {/* Beneficio: reportes automáticos */}
  <div className="bg-white rounded-2xl border border-slate-200 p-4 shadow-sm">
    <div className="flex items-start gap-3">
      <div className="shrink-0 h-9 w-9 rounded-xl grid place-content-center bg-emerald-50">📊</div>
      <div>
        <h3 className="font-semibold text-slate-800">Reportes automáticos</h3>
        <p className="text-sm text-slate-600">
          Obtené reportes mensuales y anuales listos para compartir.
        </p>
      </div>
    </div>
  </div>

  {/* Checklist inicial */}
  <div className="bg-white rounded-2xl border border-slate-200 p-4 shadow-sm">
    <h3 className="font-semibold text-slate-800 mb-2">Checklist inicial</h3>
    <ul className="text-sm text-slate-600 space-y-1 list-disc list-inside">
      <li>Cargá tu club y horarios</li>
      <li>Definí precios por clase y mensuales</li>
      <li>Agregá tus alumnos</li>
      <li>¡Listo para agendar clases!</li>
    </ul>
  </div>

  {/* Soporte rápido */}
  <div className="bg-white rounded-2xl border border-slate-200 p-4 shadow-sm">
    <div className="flex items-start gap-3">
      <div className="shrink-0 h-9 w-9 rounded-xl grid place-content-center bg-emerald-50">🤝</div>
      <div>
        <h3 className="font-semibold text-slate-800">¿Necesitás ayuda?</h3>
        <p className="text-sm text-slate-600">
          Te acompañamos a configurar tu club paso a paso.
        </p>
        <a
          href="https://wa.me/5493810000000"
          target="_blank"
          rel="noopener"
          className="inline-block mt-2 text-emerald-700 text-sm font-medium hover:underline"
          title="Abrir WhatsApp"
        >
          Abrir WhatsApp →
        </a>
      </div>
    </div>
  </div>

  {/* Tip útil */}
  <div className="bg-emerald-50/60 rounded-2xl border border-emerald-200 p-4">
    <h4 className="font-semibold text-emerald-900">Tip</h4>
    <p className="text-sm text-emerald-800">
      Agregá tus <strong>políticas de cancelación</strong> en Perfil para que
      figuren en los comprobantes y recordatorios de WhatsApp.
    </p>
  </div>

  {/* Inspiración / motivacional */}
  <div className="bg-gradient-to-r from-emerald-100 to-emerald-50 rounded-2xl p-4 border border-emerald-200">
    <p className="text-sm italic text-emerald-900">
      “Organizá tu trabajo en minutos y dedicale más tiempo a lo que amás: enseñar.”
    </p>
  </div>
</aside>
      </div>
    </BienvenidaCoachex>
  );
}
/* ---------- UI helpers (prefijo Setup para evitar conflictos) ---------- */

const SetupCard = ({ title, children }) => (
  <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-5">
    <h3 className="text-lg font-semibold text-emerald-700 mb-3">{title}</h3>
    {children}
  </div>
);

const SetupLabel = ({ children, className="" }) => (
  <label className={`block text-sm text-slate-600 mb-1 ${className}`}>{children}</label>
);

const SetupInput = (props) => (
  <input
    {...props}
    className={`w-full h-11 rounded-xl border border-slate-200 bg-white px-3 py-2 text-slate-800 shadow-inner focus:outline-none focus:ring-2 focus:ring-emerald-300 ${props.className||""}`}
  />
);

const SetupSelect = (props) => (
  <select
    {...props}
    className={`w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-slate-800 focus:outline-none focus:ring-2 focus:ring-emerald-300 ${props.className||""}`}
  />
);

const SetupPercentField = ({ label, value, onChange, readOnly=false, tooltip }) => (
  <div>
    <SetupLabel>{label}</SetupLabel>
    <div className="relative">
      <SetupInput value={value} onChange={onChange} inputMode="numeric" className="pr-12" readOnly={readOnly} title={tooltip}/>
      <span className="absolute right-3 top-1/2 -translate-y-1/2 text-slate-500">%</span>
    </div>
  </div>
);

const SetupMoneyField = ({ label, value, onChange }) => (
  <div>
    <SetupLabel>{label}</SetupLabel>
    <div className="relative">
      <span className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-500 text-sm">ARS $</span>
      <SetupInput value={value} onChange={onChange} inputMode="decimal" placeholder="0" className="pl-16" />
    </div>
  </div>
);

const SetupTimeField = ({ value, onChange, invalid=false, ...rest }) => (
  <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400 select-none">🕑</span>
    <input
      type="time"
      value={value}
      onChange={onChange}
      {...rest}
      className={[
        "w-[130px] rounded-xl border bg-white pl-8 pr-2 py-2 text-slate-800 focus:outline-none",
        invalid ? "border-red-300 focus:ring-2 focus:ring-red-300" : "border-slate-200 focus:ring-2 focus:ring-emerald-300"
      ].join(" ")}
    />
  </div>
);

    
function MainApp({ user, onLogout }) {
  // ===== Hooks arriba =====
  const [current, setCurrent] = useState("dashboard");
  const [prefillClase, setPrefillClase] = useState(null);
  const [state, setState] = useState({ alumnos: [], clases: [], pagos: [], gastos: [], perfil: {}, grupos: [] });
  const [loading, setLoading] = useState(true);
  const [toast, setToast] = useState("");
  const [deletingInfo, setDeletingInfo] = useState({ id: null, type: null, collection: null });
  const [payingClase, setPayingClase] = useState(null);
  const [navExpanded, setNavExpanded] = React.useState(false);
  const [focusAlumnoId, setFocusAlumnoId] = useState(null);
  const [claseParaAgendar, setClaseParaAgendar] = useState(null);
  const [payingCuota, setPayingCuota] = useState({ alumno: null, mes: null });
  const [claseParaEditar, setClaseParaEditar] = useState(null);
  const [nuevoAlumnoId, setNuevoAlumnoId] = useState(null);
  const [clubActivoId, setClubActivoId] = useState(null);
  const [clubes, setClubes] = useState([]);
  const [hasClubs, setHasClubs] = useState(false);
  const [registrandoAbono, setRegistrandoAbono] = useState(null);
  const [pagoParaEditar, setPagoParaEditar] = useState(null);

  // === Handlers de nivel superior (usados en el render) ===
  const openRegistrarClaseForAlumno = React.useCallback((alumnoId) => {
    setCurrent('clases');
    setNuevoAlumnoId(alumnoId ?? null);
  }, []);

  const openPagoPendiente = React.useCallback((clase, alumnoId) => {
    if (!clase) return;
    setPayingClase(clase);
    setFocusAlumnoId(alumnoId ?? null);
  }, []);

  // === Efecto: lista de clubs (con cleanup) ===
  useEffect(() => {
    if (!user) return;
    let alive = true;
    setLoading(true);

    const clubsRef = db.collection('users').doc(user.uid).collection('clubs');
    const clubsUnsubscribe = clubsRef.onSnapshot(
      (snapshot) => {
        if (!alive) return;
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        setClubes(data);
        setHasClubs(data.length > 0);
        setClubActivoId(prev => (prev ?? (data[0]?.id || null)));
        setLoading(false);
      },
      (error) => {
        if (!alive) return;
        console.error("Error fetching clubs: ", error);
        setLoading(false);
      }
    );

    return () => { alive = false; clubsUnsubscribe && clubsUnsubscribe(); };
  }, [user]);

  // === Efecto: perfil + colecciones del club (con cleanup) ===
  useEffect(() => {
    if (!user || !clubActivoId) return;
    let alive = true;

    const userRef = db.collection('users').doc(user.uid);
    const baseRef = userRef.collection('clubs').doc(clubActivoId);

    const perfilDocClub = baseRef.collection('perfil').doc('main');
    const perfilDocUser = userRef.collection('profile').doc('main');

    const unsubscribes = [];

    const profileUnsubscribe = perfilDocClub.onSnapshot(
      async (snap) => {
        if (!alive) return;
        try {
          if (snap.exists) {
            setState(prev => ({ ...prev, perfil: { ...initialState.perfil, ...snap.data() } }));
          } else {
            const uSnap = await perfilDocUser.get();
            setState(prev => ({
              ...prev,
              perfil: uSnap.exists ? { ...initialState.perfil, ...uSnap.data() } : initialState.perfil
            }));
          }
        } catch (e) {
          if (!alive) return;
          console.error('Error fetching perfil:', e);
          setState(prev => ({ ...prev, perfil: initialState.perfil }));
        }
      },
      (e) => console.error('Error listening perfil:', e)
    );
    unsubscribes.push(profileUnsubscribe);

    ['alumnos', 'clases', 'pagos', 'gastos', 'grupos'].forEach((collectionName) => {
      const unsubscribe = baseRef.collection(collectionName).onSnapshot(
        (snapshot) => {
          if (!alive) return;
          const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          setState(prev => ({ ...prev, [collectionName]: data }));
        },
        (error) => console.error(`Error fetching ${collectionName}:`, error)
      );
      unsubscribes.push(unsubscribe);
    });

    return () => { alive = false; unsubscribes.forEach(u => { try { u && u(); } catch (_) {} }); };
  }, [user, clubActivoId]);

  // === Helpers de colección ===
  const getCollection = (collectionName) => {
    if (!clubActivoId) {
      console.error("No club active. Cannot get collection.");
      return null;
    }
    return db.collection('users').doc(user.uid).collection('clubs').doc(clubActivoId).collection(collectionName);
  };

  // === CRUDs ===
  const alumnoCrud = {
    create: async (data) => {
      const collectionRef = getCollection('alumnos');
      if (!collectionRef) return;
      const docRef = await collectionRef.add(data);
      setToast("Alumno creado");
      return { ...data, id: docRef.id };
    },
    update: ({ id, ...data }) => {
      const collectionRef = getCollection('alumnos');
      if (!collectionRef) return;
      return collectionRef.doc(id).update(data).then(() => setToast("Alumno actualizado"));
    },
    delete: (id) => setDeletingInfo({ id, type: 'alumno', collection: 'alumnos' }),
  };

  const pagoCrud = {
    createPagosClase: async (pagosData = []) => {
      try {
        const collectionRef = getCollection('pagos');
        if (!collectionRef) { alert('No hay club activo.'); return; }
        if (!payingClase || !payingClase.id) { alert('Clase no definida para pago.'); return; }

        const normal = (v) => {
          if (v == null) return 0;
          const s = String(v).replace(/\./g, '').replace(',', '.');
          const n = parseFloat(s);
          return isNaN(n) ? 0 : n;
        };

        const normMethod = (s) => {
          const m = String(s || '').trim().toLowerCase();
          if (m.startsWith('efect')) return 'Efectivo';
          if (m.startsWith('transf') || m.startsWith('tx')) return 'Transferencia';
          if (m.startsWith('mensu')) return 'Mensual';
          if (m.startsWith('pend')) return 'Pendiente';
          if (m.startsWith('mixto')) return 'Mixto';
          return s || 'Efectivo';
        };

        const isZeroLike = (x) => {
          const n = Number(x);
          return !Number.isFinite(n) || n <= 0;
        };

        const expandMixto = (p) => {
          const metodo = String(p.metodo || '').trim().toLowerCase();
          if (metodo !== 'mixto') return [p];

          const ef = normal(p.mixtoEfectivo ?? p.efectivo ?? p.efectivoMonto ?? p.cash ?? p.contado);
          const tx = normal(p.mixtoTransferencia ?? p.transferencia ?? p.transf ?? p.transferenciaMonto ?? p.tx);

          const out = [];
          if (!isZeroLike(ef)) out.push({ ...p, metodo: 'Efectivo', monto: ef });
          if (!isZeroLike(tx)) out.push({ ...p, metodo: 'Transferencia', monto: tx });

          if (out.length === 0) throw new Error('Pago Mixto sin montos desglosados (Efectivo/Transferencia).');
          return out;
        };

        const items = [];
        for (const p of (pagosData || [])) {
          const metodo = normMethod(p.metodo);
          if (metodo === 'Mixto') {
            items.push(...expandMixto(p));
          } else {
            items.push({ ...p, monto: normal(p.monto), metodo });
          }
        }

        const batch = db.batch();
        for (const p of items) {
          if (p.metodo === 'Pendiente') continue;
          if (isZeroLike(p.monto)) continue;

          const docRef = collectionRef.doc();
          batch.set(docRef, {
            claseId: payingClase.id,
            alumnoId: p.alumnoId,
            fecha: payingClase.fecha,
            concepto: `Pago de clase de ${labelSinClase(payingClase.tipo)} (${payingClase.fecha})`,
            metodo: p.metodo,
            monto: Number(p.monto || 0),
          });
        }
        await batch.commit();

        // Recalcular pagada
        const pagosSnap = await collectionRef.where('claseId', '==', payingClase.id).get();
        let totalPagado = 0;
        pagosSnap.forEach(d => { totalPagado += Number(d.data().monto || 0); });

        const claseRef = getCollection('clases').doc(payingClase.id);
        const precioClase = Number(payingClase.precio || 0);
        await claseRef.set({ pagada: totalPagado >= precioClase }, { merge: true });

        setToast("Pagos registrados");
        setPayingClase(null);
        setFocusAlumnoId(null);
        setClaseParaAgendar(payingClase);
      } catch (err) {
        console.error('createPagosClase error:', err);
        alert('No se pudo guardar el/los pagos. Revisá la consola para más detalles.');
      }
    },

    createAbono: (pagoData, alumno) => {
      const collectionRef = getCollection('pagos');
      if (!collectionRef) return;
      const newPago = {
        alumnoId: alumno.id,
        fecha: pagoData.fechaPago,
        concepto: pagoData.concepto || `Abono Mensual - ${MESES_NOMBRES[pagoData.mes]}`,
        monto: pagoData.monto,
        metodo: pagoData.metodo
      };
      collectionRef.add(newPago).then(() => {
        setToast("Pago de abono registrado con éxito");
        setRegistrandoAbono(null);
      });
    },

    createMensual: (pagoData) => {
      const collectionRef = getCollection('pagos');
      if (!collectionRef) return;
      const { alumno, mes } = payingCuota;
      const fecha = new Date();
      fecha.setMonth(mes);
      const newPago = {
        alumnoId: alumno.id,
        fecha: formatDate(fecha),
        concepto: `Cuota Mensual - ${MESES_NOMBRES[mes]}`,
        ...pagoData
      };
      collectionRef.add(newPago).then(() => {
        setToast("Pago de cuota registrado");
        setPayingCuota({ alumno: null, mes: null });
      });
    },

    update: ({ id, ...data }) => {
      const collectionRef = getCollection('pagos');
      if (!collectionRef) return;

      const dataToSave = { ...data };
      if (data.metodo === 'Mixto') {
        dataToSave.detalleMixto = {
          efectivo: parseFloat(data.mixtoEfectivo) || 0,
          transferencia: parseFloat(data.mixtoTransferencia) || 0
        };
      }
      delete dataToSave.mixtoEfectivo;
      delete dataToSave.mixtoTransferencia;

      return collectionRef.doc(id).update(dataToSave).then(() => {
        setToast("Pago actualizado con éxito");
        setPagoParaEditar(null);
      });
    }
  };

  const claseCrud = {
    create: async (c) => {
      const collectionRef = getCollection('clases');
      if (!collectionRef) return;
      const claseData = { ...c };
      delete claseData.id;

      const shouldPay = claseData.estado === 'Realizada' || claseData.estado === 'Ausente';

      if (claseData.recurrente) {
        const batch = db.batch();
        const semanas = parseInt(claseData.mesesRecurrencia, 10) * 4;
        for (let i = 0; i < semanas; i++) {
          const nuevaFecha = addDays(new Date(claseData.fecha), i * 7);
          const newClase = { ...claseData, fecha: formatDate(nuevaFecha), recurrente: false };
          const docRef = collectionRef.doc();
          batch.set(docRef, newClase);
        }
        await batch.commit();
        setToast("Clases recurrentes creadas");
      } else {
        const docRef = await collectionRef.add(claseData);
        const nuevaClaseId = docRef.id;
        setToast("Clase creada");

        if (shouldPay && nuevaClaseId) {
          const claseParaPagar = { ...claseData, id: nuevaClaseId };
          setPayingClase(claseParaPagar);
        }
      }
    },
    update: ({ id, ...data }) => {
      const collectionRef = getCollection('clases');
      if (!collectionRef) return;

      const shouldPay = data.estado === 'Realizada' || data.estado === 'Ausente';

      return collectionRef.doc(id).update(data).then(() => {
        setToast("Clase actualizada");
        if (shouldPay) setPayingClase({ ...data, id });
      });
    },
    delete: (id) => setDeletingInfo({ id, type: 'clase', collection: 'clases' }),
  };

  const gastoCrud = {
    create: (g) => {
      const collectionRef = getCollection('gastos');
      if (!collectionRef) return;
      return collectionRef.add(g).then(() => setToast("Gasto creado"));
    },
    update: ({ id, ...data }) => {
      const collectionRef = getCollection('gastos');
      if (!collectionRef) return;
      return collectionRef.doc(id).update(data).then(() => setToast("Gasto actualizado"));
    },
    delete: (id) => setDeletingInfo({ id, type: 'gasto', collection: 'gastos' }),
  };

  // Reemplazá tu perfilCrud por este (o actualizá el update)
const perfilCrud = {
  update: async (p) => {
    const u = auth.currentUser;
    if (!u || !clubActivoId) return;

    // 1) Perfil del CLUB activo
    await db.collection('users').doc(u.uid)
      .collection('clubs').doc(clubActivoId)
      .collection('perfil').doc('main')
      .set(p, { merge: true });

    // 2) (Opcional) también el perfil global, para defaults
    await db.collection('users').doc(u.uid)
      .collection('profile').doc('main')
      .set(p, { merge: true });

    setToast("Perfil actualizado");
  }
};


  // === Acciones auxiliares ===
  const confirmDelete = async () => {
    const { id, type, collection } = deletingInfo;
    if (!id || !collection) return;
    const collectionRef = getCollection(collection);
    if (!collectionRef) return;
    await collectionRef.doc(id).delete();
    if (type === 'clase') {
      const pagosSnapshot = await getCollection('pagos').where('claseId', '==', id).get();
      const batch = db.batch();
      pagosSnapshot.forEach(doc => batch.delete(doc.ref));
      await batch.commit();
    }
    setToast(`${type.charAt(0).toUpperCase() + type.slice(1)} eliminado/a`);
    setDeletingInfo({ id: null, type: null, collection: null });
  };

  const handleRegisterMonthlyPayment = (alumno) => setRegistrandoAbono(alumno);

  const handleExportData = () => {
    const dataToExport = {
      alumnos: state.alumnos,
      clases: state.clases,
      pagos: state.pagos,
      gastos: state.gastos,
      perfil: state.perfil,
      grupos: state.grupos || []
    };
    const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(dataToExport, null, 2))}`;
    const link = document.createElement("a");
    link.href = jsonString;
    const date = new Date().toISOString().slice(0, 10);
    link.download = `coachex_backup_${date}.json`;
    link.click();
    setToast("Datos exportados con éxito.");
  };

  const handleImportData = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target.result);
        const confirmImport = window.confirm(
          "¡ATENCIÓN! ¿Estás seguro de que quieres importar estos datos?\n\n" +
          "TODOS TUS DATOS ACTUALES SERÁN BORRADOS Y REEMPLAZADOS.\n\n" +
          "Esta acción no se puede deshacer."
        );
        if (confirmImport) {
          setToast("Importando datos... La página se recargará al finalizar.");
          console.log("Datos a importar:", importedData);
          alert("La funcionalidad de escritura en la base de datos está pendiente. Revisa la consola para ver los datos que se importarían.");
        }
      } catch (error) {
        alert("El archivo seleccionado no es un JSON válido o está corrupto.");
        console.error("Error al parsear JSON:", error);
      } finally {
        event.target.value = null;
      }
    };
    reader.readAsText(file);
  };

  const goToEditClass = (clase) => { setClaseParaEditar(clase); setCurrent("clases"); };
  const handleDeletePago = (pagoId) => setDeletingInfo({ id: pagoId, type: 'pago', collection: 'pagos' });

  // === Render ===
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="loader"></div>
      </div>
    );
  }

  if (!hasClubs) {
    return (
      <OnboardingClubSetup
        user={user}
        setHasClubs={setHasClubs}
        onLogout={onLogout}
      />
    );
  }

  return (
    <div className="min-h-screen bg-slate-50 font-sans overflow-x-hidden">
      <SideNav
        current={current}
        setCurrent={setCurrent}
        onLogout={onLogout}
        clubes={clubes}
        clubActivoId={clubActivoId}
        expanded={navExpanded}
        onExpandChange={setNavExpanded}
      />

      <main
        className={
          "min-h-screen bg-white pb-16 md:pb-0 transition-[padding] duration-300 " +
          (navExpanded ? "md:pl-56" : "md:pl-16")
        }
      >
        <Page>
          {current === "dashboard" && (
            <Dashboard
              perfil={state.perfil}
              clases={state.clases}
              pagos={state.pagos}
              gastos={state.gastos}
              alumnos={state.alumnos}
              clubes={clubes}
              clubActivoId={clubActivoId}
              goToNewClass={(prefill) => { setPrefillClase(prefill || null); setCurrent('clases'); setTimeout(() => document.querySelector('#nueva-clase-btn')?.click(), 50); }}
              goToEditClass={goToEditClass}
            />
          )}

          {current === "alumnos" && (
            <Alumnos
              clases={state.clases}
              pagos={state.pagos}
              alumnos={state.alumnos}
              onCreate={alumnoCrud.create}
              onUpdate={alumnoCrud.update}
              onDelete={alumnoCrud.delete}
              onRegisterMonthlyPayment={handleRegisterMonthlyPayment}
              onRegistrarClase={openRegistrarClaseForAlumno}
              onPagarPendiente={openPagoPendiente}
              onEditarPago={(pago) => setPagoParaEditar(pago)}
              onDeletePago={handleDeletePago}
              user={user}
              clubActivoId={clubActivoId}
              perfil={state.perfil}
              openRegistrarClaseForAlumno={openRegistrarClaseForAlumno}
            />
          )}

          {current === "clases" && (
            <Clases
              clases={state.clases}
              alumnos={state.alumnos}
              pagos={state.pagos}
              perfil={state.perfil}
              gastos={state.gastos}               
              onCreate={claseCrud.create}
              onUpdate={claseCrud.update}
              onDelete={claseCrud.delete}
              onPay={(clase) => setPayingClase(clase)}
              user={user}
              claseParaEditar={claseParaEditar}
              setClaseParaEditar={setClaseParaEditar}
              nuevoAlumnoId={nuevoAlumnoId}
              setNuevoAlumnoId={setNuevoAlumnoId}
              prefillClase={prefillClase}
              onPrefillConsumed={() => setPrefillClase(null)}
              grupos={state.grupos}
              clubActivoId={clubActivoId}
            />
          )}

          {current === "grupos" && (
            <Grupos
              alumnos={state.alumnos}
              user={user}
              perfil={state.perfil}
              clubActivoId={clubActivoId}
            />
          )}

          {current === "pagos" && (
            <Pagos
              pagos={state.pagos}
              alumnos={state.alumnos}
              clases={state.clases}
              perfil={state.perfil}
              onPayMensual={(alumno, mes) => setPayingCuota({ alumno, mes })}
              onEditarPago={(pago) => setPagoParaEditar(pago)}
              onDeletePago={handleDeletePago}
            />
          )}

          {current === "gastos" && (
            <Gastos
              gastos={state.gastos}
              onCreate={gastoCrud.create}
              onUpdate={gastoCrud.update}
              onDelete={gastoCrud.delete}
            />
          )}

          {current === "reportes" && (
            <Reportes
              pagos={state.pagos}
              gastos={state.gastos}
              alumnos={state.alumnos}
              clases={state.clases}
              clubActivoId={clubActivoId}
              clubes={clubes}
              perfil={state.perfil}
            />
          )}

          {current === "rankings" && (
            <Rankings alumnos={state.alumnos} user={user} clubActivoId={clubActivoId} />
          )}

          {current === "torneos" && (
            <Torneos alumnos={state.alumnos} user={user} clubActivoId={clubActivoId} perfil={state.perfil} />
          )}

          {current === "perfil" && (
            <Perfil
              perfil={state.perfil}
              alumnos={state.alumnos}
              clases={state.clases}
              pagos={state.pagos}
              gastos={state.gastos}
              grupos={state.grupos}
              onUpdate={perfilCrud.update}
              user={user}
              setToast={setToast}
              getCollection={getCollection}
              perfilCrud={perfilCrud}
              openRegistrarClaseForAlumno={openRegistrarClaseForAlumno}
              onExport={handleExportData}
              onImport={handleImportData}
            />
          )}
        </Page>

        <div className="md:hidden" style={{ height: "calc(56px + env(safe-area-inset-bottom))" }} />
      </main>

      <Toast msg={toast} onClose={() => setToast("")} />

      <Modal
        isOpen={!!deletingInfo.id}
        title={`Eliminar ${deletingInfo.type}`}
        onConfirm={confirmDelete}
        onCancel={() => setDeletingInfo({ id: null, type: null, collection: null })}
      >
        ¿Estás seguro? Esta acción no se puede deshacer.
      </Modal>

      <PagoGrupalModal
        isOpen={!!payingClase}
        clase={payingClase}
        alumnos={state.alumnos}
        onCancel={() => { setPayingClase(null); setFocusAlumnoId(null); }}
        focusAlumnoId={focusAlumnoId}
        onSave={pagoCrud.createPagosClase}
      />

      <RegistroPagoMensualModal
        isOpen={!!registrandoAbono}
        alumno={registrandoAbono}
        perfil={state.perfil}
        onCancel={() => setRegistrandoAbono(null)}
        onSave={(pagoData) => pagoCrud.createAbono(pagoData, registrandoAbono)}
      />

      <PagoMensualModal
        isOpen={!!payingCuota.alumno}
        alumno={payingCuota.alumno}
        mes={payingCuota.mes}
        onCancel={() => setPayingCuota({ alumno: null, mes: null })}
        onSave={pagoCrud.createMensual}
      />

      <EditarPagoModal
        isOpen={!!pagoParaEditar}
        pago={pagoParaEditar}
        onCancel={() => setPagoParaEditar(null)}
        onSave={pagoCrud.update}
      />

      <AgendarProximaClaseModal
        isOpen={!!claseParaAgendar}
        onClose={() => setClaseParaAgendar(null)}
        onSchedule={claseCrud.create}
        claseBase={claseParaAgendar}
        alumnos={state.alumnos}
      />

      <footer className="text-center text-xs text-slate-500 py-6">
        Coachex-Pro · Gestión de Profesores
      </footer>
    </div>
  );
}


function AgendarProximaClaseModal({ isOpen, onClose, onSchedule, claseBase, alumnos }) {
  // -- Helpers --
  const parseYMDLocal = (ymd) => {
    if (!ymd) return new Date();
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(y, (m || 1) - 1, d || 1, 0, 0, 0, 0);
  };

  // TIPOS_CLASE_MAP global si existe (en tu app suele existir). Si no, parseo del texto.
  const TIPOS_CLASE_MAP_LOCAL =
    (typeof TIPOS_CLASE_MAP !== "undefined" && TIPOS_CLASE_MAP) || null;

  const requiredCountFromTipo = (tipo) => {
    if (TIPOS_CLASE_MAP_LOCAL && TIPOS_CLASE_MAP_LOCAL[tipo]) {
      return TIPOS_CLASE_MAP_LOCAL[tipo];
    }
    const m = /Clase\s+(\d+)/i.exec(tipo || "");
    return m ? Math.max(1, parseInt(m[1], 10) || 1) : 1;
  };

  const resizeAlumnoIds = (prevIds, n) => {
    const arr = Array.isArray(prevIds) ? [...prevIds] : [];
    if (arr.length < n) {
      while (arr.length < n) arr.push("");
    } else if (arr.length > n) {
      arr.length = n;
    }
    return arr;
  };

  // -- Estado inicial (respetando zona horaria local) --
  const baseDate = claseBase?.fecha ? parseYMDLocal(claseBase.fecha) : new Date();
  const nextWeekDate = addDays(baseDate, 7);
  const tipoInicial = normalizarTipoClase(claseBase?.tipo) || "Clase 1 persona";
  const reqInicial = requiredCountFromTipo(tipoInicial);

  const [form, setForm] = useState(() => ({
    fecha: formatDate(nextWeekDate),
    hora: claseBase?.hora || "",
    precio: claseBase?.precio || 0,
    tipo: tipoInicial,
    alumnoIds: resizeAlumnoIds(claseBase?.alumnoIds || [], reqInicial),
  }));

  const alumnoMap = useMemo(
    () => new Map((alumnos || []).map((a) => [a.id, a])),
    [alumnos]
  );

  useEffect(() => {
    if (claseBase) {
      const base = parseYMDLocal(claseBase.fecha);
      const next = addDays(base, 7);
      const tipo = normalizarTipoClase(claseBase.tipo) || "Clase 1 persona";
      const req = requiredCountFromTipo(tipo);
      setForm({
        fecha: formatDate(next),
        hora: claseBase.hora || "",
        precio: claseBase.precio || 0,
        tipo,
        alumnoIds: resizeAlumnoIds(claseBase.alumnoIds || [], req),
      });
    }
  }, [claseBase]);

  const handleFormChange = (e) => {
    const { name, value } = e.target;
    if (name === "tipo") {
      const canon = normalizarTipoClase(value);
      const req = requiredCountFromTipo(canon);
      setForm((prev) => ({
        ...prev,
        tipo: canon,
        alumnoIds: resizeAlumnoIds(prev.alumnoIds, req),
      }));
      return;
    }
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleAlumnoChange = (index, newId) => {
    setForm((prev) => {
      const next = [...(prev.alumnoIds || [])];
      next[index] = newId;
      return { ...prev, alumnoIds: next };
    });
  };

  const handleSchedule = () => {
    if (!form.fecha || !form.hora || (form.alumnoIds || []).length === 0) {
      alert("Por favor, completa la fecha, hora y al menos un alumno.");
      return;
    }
    onSchedule(form);
    onClose();
  };

  const getNombreCompleto = (a) =>
    a ? `${a.apellido || ""} ${a.nombre || ""}`.trim() : "Alumno eliminado";
  const alumnosActivos = (alumnos || []).filter((a) => a.estado === "activo");

  if (!isOpen || !claseBase) return null;

  return (
    <Modal
      isOpen={isOpen}
      title="Agendar próxima clase"
      onCancel={onClose}
      onConfirm={handleSchedule}
      confirmText="Agendar Clase"
      size="2xl"
    >
      <div className="space-y-4">
        <p className="text-sm text-slate-600">
          Se acaba de registrar el pago para la clase de hoy. ¿Deseas agendar la próxima?
        </p>

        <div className="grid md:grid-cols-2 gap-4 p-4 border rounded-xl bg-slate-50">
          <div>
            <label className="text-sm text-slate-600">Fecha</label>
            <input
              type="date"
              name="fecha"
              value={form.fecha}
              onChange={handleFormChange}
              className="w-full border rounded-lg px-3 py-2 mt-1"
            />
          </div>

          <div>
            <label className="text-sm text-slate-600">Hora</label>
            <input
              type="time"
              name="hora"
              value={form.hora}
              onChange={handleFormChange}
              className="w-full border rounded-lg px-3 py-2 mt-1"
            />
          </div>

          <div>
            <label className="text-sm text-slate-600">Precio</label>
            <input
              type="number"
              name="precio"
              value={form.precio}
              onChange={handleFormChange}
              className="w-full border rounded-lg px-3 py-2 mt-1"
            />
          </div>

          <div>
            <label className="text-sm text-slate-600">Tipo de Clase</label>
            <select
              name="tipo"
              value={form.tipo}
              onChange={handleFormChange}
              className="w-full border rounded-lg px-3 py-2 mt-1"
            >
              {TIPOS_CLASE.map((t) => (
                <option key={t}>{t}</option>
              ))}
            </select>
          </div>
        </div>

        <div className="p-4 border rounded-xl bg-slate-50">
          <label className="text-sm text-slate-600">Alumnos</label>
          <div className="grid gap-2 mt-1">
            {(form.alumnoIds || []).map((alumnoId, index) => (
              <div key={index}>
                <select
                  value={alumnoId}
                  onChange={(e) => handleAlumnoChange(index, e.target.value)}
                  className="w-full border rounded-lg px-3 py-2"
                >
                  <option value="">Seleccionar...</option>
                  {alumnosActivos.map((a) => (
                    <option key={a.id} value={a.id}>
                      {getNombreCompleto(a)}
                    </option>
                  ))}
                </select>
              </div>
            ))}
          </div>
        </div>
      </div>
    </Modal>
  );
}



    // ------------------------------ APP WRAPPER WITH AUTH ------------------------------
function AppGPadel() {
  const [user, setUser] = useState(null);
  const [stage, setStage] = useState('loading'); // 'loading' | 'login' | 'verify' | 'app'

  useEffect(() => {
    const unsubscribe = auth.onAuthStateChanged(async (u) => {
      try {
        if (!u) { setUser(null); setStage('login'); return; }

        await u.reload(); // refresca emailVerified

        const providerIds = (u.providerData || []).map(p => p.providerId);
        const isEmailPwd = providerIds.includes('password');

        if (isEmailPwd && !u.emailVerified) { setUser(u); setStage('verify'); return; }
        if (isEmailPwd && u.emailVerified)  { await u.getIdToken(true); } // ⬅️ token fresco

        setUser(u);
        setStage('app');
      } catch (e) {
        console.error('onAuthStateChanged error:', e);
        setUser(null);
        setStage('login');
      }
    });
    return () => unsubscribe();
  }, []);

  if (stage === 'loading') return <div className="min-h-screen flex items-center justify-center"><div className="loader"></div></div>;
  if (stage === 'login')   return <LoginScreen />;
  if (stage === 'verify')  return <VerifyEmail user={user} onLogout={() => auth.signOut()} />;
  return <MainApp user={user} onLogout={() => auth.signOut()} />;
}

function VerifyEmail({ user, onLogout }) {
  // --- INICIO DE LA CORRECCIÓN ---
  // Si por alguna razón el usuario es nulo, no renderizamos nada para evitar el error.
  if (!user) {
    return (
        <div className="min-h-screen flex items-center justify-center">
            <div className="loader"></div>
        </div>
    );
  }
  // --- FIN DE LA CORRECCIÓN ---

  const [sent, setSent] = useState(false);
  const resend = async () => { await user.sendEmailVerification(); setSent(true); };
  const recheck = async () => {
    await user.reload();
    if (user.emailVerified) { await user.getIdToken(true); window.location.reload(); }
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center gap-4 p-6">
      <h2 className="text-xl font-semibold">Verificá tu email</h2>
      <p>Te enviamos un correo a <b>{user.email}</b>.</p>
      <div className="flex gap-3">
        <button onClick={resend} className="btn">{sent ? 'Reenviado ✅' : 'Reenviar correo'}</button>
        <button onClick={recheck} className="btn">Ya verifiqué</button>
        <button onClick={onLogout} className="btn btn-outline">Cambiar de cuenta</button>
      </div>
    </div>
  );
}

class ErrorBoundary extends React.Component {
  constructor(props){ super(props); this.state = { hasError: false }; }
  static getDerivedStateFromError(){ return { hasError: true }; }
  componentDidCatch(error, info){ console.error('ErrorBoundary:', error, info); }
  render(){
    if (this.state.hasError) {
      return (
        <div className="p-6 text-center text-red-700">
          Ocurrió un error en la vista. Probá recargar o volver al inicio.
          <div className="mt-4">
            <button onClick={() => this.setState({ hasError:false })} className="btn">Reintentar</button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

ReactDOM.render(
  <ErrorBoundary><AppGPadel /></ErrorBoundary>,
  document.getElementById('root')
);
</script>

<script type="text/babel">
// ====== RANKING INTEGRATION (non-invasive) ======
// This block adds ranking configuration + award application without altering existing logic.
// It relies on existing globals: React, db (Firestore), bracketFinalInfo, computeTablaGrupo (if present).

// ====== RANKING INTEGRATION (non-invasive) ======
// This block adds ranking configuration + award application without altering existing logic.
// It relies on existing globals: React, db (Firestore), bracketFinalInfo, computeTablaGrupo (if present).

(function(){
  // ---- Safe helpers ----
  function defaultRankingCfg() {
    return {
      destinoId: null,
      modo: 'posiciones',                   // Simplificado a solo 'posiciones'
      multiplicador: 1,
      liga: { top: [100,60,40,20,10], participacion: 5 },
      ko:   { champion:120, runnerUp:80, semi:50, quarter:25, roundOf16:10 },
      dobles: { dividir: false }
    };
  }

  function withRankingDefaults(reglas) {
    const r = reglas || {};
    const base = defaultRankingCfg();
    return { 
      ...r, 
      ranking: { 
        ...base, 
        ...(r.ranking || {}) 
      } 
    };
  }

  function rankingsColRef(user, clubId) {
    try {
      var uid = (user && user.uid) || (window && window.__USER_UID) || (window && window.firebase && window.firebase.auth && window.firebase.auth().currentUser && window.firebase.auth().currentUser.uid) || null;
      if (!uid) { console.error('rankingsColRef: no UID'); return null; }
      return db
        .collection('users').doc(uid)
        .collection('clubs').doc(clubId)
        .collection('rankings');
    } catch (e) {
      console.error("rankingsColRef error", e);
      return null;
    }
  }

  // Devuelve array de alumnoIds desde una entrada (alumno o pareja).
  function expandEntryToAlumnoIds(entry, torneo) {
    if (!torneo) return [];
    if (torneo.modalidad !== 'dobles') {
      const id = (typeof entry === 'string') ? entry : (entry && entry.id);
      return id ? [id] : [];
    }
    const teams = torneo.teams || [];
    const team = (entry && entry.members) ? entry
      : (typeof entry === 'string' ? teams.find(t => t.id === entry) : entry);
    return (team && Array.isArray(team.members)) ? team.members.filter(Boolean) : [];
  }

  // ¿Todos los partidos de grupos están "done"?
  function groupsAllMatchesDone(torneo) {
    if (!torneo || !torneo.fixture) return false;
    const fx = torneo.fixture;
    let hasAny = false;
    for (const gid of Object.keys(fx)) {
      const rondas = fx[gid] || [];
      for (const rs of rondas) {
        for (const m of (rs || [])) {
          hasAny = true;
          if (!m || !m.done) return false;
        }
      }
    }
    return hasAny;
  }

  // --- Puntos por KO (bonos por posición) ---
  function collectKOPoints(torneo) {
    const out = new Map();
    const reglas = withRankingDefaults(torneo.reglas);
    const K = reglas.ko || {};
    const cuadro = torneo.cuadro || {};
    
    try {
      const fin = (typeof bracketFinalInfo === 'function') ? bracketFinalInfo(cuadro) : null;
      if (fin?.done) {
        const bonus = (key, entry) => {
          const val = K[key] || 0;
          expandEntryToAlumnoIds(entry, torneo).forEach(id => {
            out.set(id, (out.get(id)||0) + val);
          });
        };
        bonus('champion',  fin.champion);
        bonus('runnerUp',  fin.runnerUp);

        // Semifinales perdedores
        const semiR = cuadro[String(fin.lastRound-1)] || [];
        semiR.forEach(m => {
          const loser = (m?.result?.winner === 'a') ? m.b : m.a;
          bonus('semi', loser);
        });
        // Cuartos perdedores
        const qR = cuadro[String(fin.lastRound-2)] || [];
        qR.forEach(m => {
          const loser = (m?.result?.winner === 'a') ? m.b : m.a;
          bonus('quarter', loser);
        });
      }
    } catch (e) {
      console.warn("KO bonus skipped (no bracket helper?)", e);
    }
    return out;
  }

  // --- Bonos por posición en Liga (y participación) ---
  function collectLeaguePlacementPoints(torneo) {
    const out = new Map();
    const reglas = withRankingDefaults(torneo.reglas);
    const top = (reglas.ranking && reglas.ranking.liga && Array.isArray(reglas.ranking.liga.top)) ? reglas.ranking.liga.top : [];
    const part = (reglas.ranking && reglas.ranking.liga) ? (reglas.ranking.liga.participacion || 0) : 0;

    // Necesitamos computeTablaGrupo si existe
    if (!torneo.grupos || !Array.isArray(torneo.grupos)) return out;

    torneo.grupos.forEach(g => {
      let rows = [];
      try {
        if (typeof computeTablaGrupo === 'function') rows = computeTablaGrupo(torneo, g.id) || [];
      } catch (e) {
        console.warn("computeTablaGrupo error", e);
      }
      rows.forEach((row, i) => {
        const ids = expandEntryToAlumnoIds(row?.eid, torneo);
        const base = (i < top.length) ? (top[i] || 0) : 0;
        ids.forEach(id => out.set(id, (out.get(id)||0) + base));
      });

      // participación: quien haya jugado al menos un partido
      const fx = (torneo.fixture || {})[g.id] || [];
      const jugo = new Set();
      fx.forEach(rs => (rs || []).forEach(m => {
        if (m?.done) {
          expandEntryToAlumnoIds(m.a, torneo).forEach(id => jugo.add(id));
          expandEntryToAlumnoIds(m.b, torneo).forEach(id => jugo.add(id));
        }
      }));
      jugo.forEach(id => out.set(id, (out.get(id)||0) + part));
    });
    return out;
  }

  function mergePoints(maps) {
    const out = new Map();
    (maps || []).forEach(m => m && m.forEach((v,k) => out.set(k, (out.get(k)||0) + v)));
    return out;
  }

  async function applyAwardsToRanking({ user, clubId, torneo, force=false }) {
    const reglas = withRankingDefaults(torneo.reglas);
    const cfg = reglas.ranking || defaultRankingCfg();
    if (!cfg.destinoId) { alert('Elegí un Ranking destino en Reglas → Ranking.'); return null; }

    const parts = [];
    
    // Solo usamos el puntaje por posiciones
    if (torneo.formato !== 'eliminacion') parts.push(collectLeaguePlacementPoints(torneo));
    if (torneo.cuadro) parts.push(collectKOPoints(torneo));
    
    const tot = mergePoints(parts);
    const mult = cfg.multiplicador || 1;
    const awards = {};
    tot.forEach((v,k)=> awards[k] = Math.round(v * mult));

    const col = rankingsColRef(user, clubId);
    if (!col) { alert('No se pudo ubicar la colección de rankings.'); return null; }
    const ref = col.doc(cfg.destinoId);
    const snap = await ref.get();
    const data = snap.exists ? snap.data() : {};
    
const ajustesTorneos = { ...(data.ajustesTorneos || {}) };
const participantesSet = new Set(Array.isArray(data.participantes) ? data.participantes : []);
Object.entries(awards).forEach(([id, pts]) => {
  ajustesTorneos[id] = (parseInt(ajustesTorneos[id]||0,10)) + (pts||0);
  participantesSet.add(id);
});
const participantes = Array.from(participantesSet);
await ref.set({ ajustesTorneos, participantes, updatedAt: Date.now() }, { merge: true });
    // Además, persistimos un documento de 'awards' con el resumen PJ/G/E/P y PTS de este torneo
    try {
      const counts = (function() {
        const out = new Map();
        const ensure = (id) => { if (!out.has(id)) out.set(id, {PJ:0,G:0,E:0,P:0}); return out.get(id); };
        // Conteo por fase de grupos (si aplica)
        const gids = (typeof groups === 'function') ? groups(torneo) : Object.keys(torneo.grupos||{});
        for (const gid of gids) {
          let tabla = [];
          try {
            tabla = (typeof computeTablaGrupo === 'function') ? (computeTablaGrupo(torneo, gid) || []) : [];
          } catch (e) { tabla = []; }
          for (const row of (tabla || [])) {
            const ids = (typeof expandEntryToAlumnoIds === 'function') ? (expandEntryToAlumnoIds(row.eid, torneo) || []) : [row.eid].filter(Boolean);
            for (const id of ids) {
              const r = ensure(id);
              r.PJ += (row.pj||0);
              r.G  += (row.pg||0);
              r.E  += (row.pe||0);
              r.P  += (row.pp||0);
            }
          }
        }
        // Conteo por cuadros (eliminación directa)
        const isBYE = (e) => e && typeof e==='object' && e.BYE;
        for (const rd of Object.values(torneo.cuadro || {})) {
          for (const m of (rd || [])) {
            if (!m || !m.done || !m.result) continue;
            const aIds = (typeof expandEntryToAlumnoIds === 'function') ? (expandEntryToAlumnoIds(m.a, torneo) || []) : [m.a].filter(Boolean);
            const bIds = (typeof expandEntryToAlumnoIds === 'function') ? (expandEntryToAlumnoIds(m.b, torneo) || []) : [m.b].filter(Boolean);
            if (aIds.length === 0 || bIds.length === 0) continue; // probablemente BYE
            for (const id of aIds) ensure(id).PJ += 1;
            for (const id of bIds) ensure(id).PJ += 1;
            if (m.result.winner === 'a') {
              for (const id of aIds) ensure(id).G += 1;
              for (const id of bIds) ensure(id).P += 1;
            } else if (m.result.winner === 'b') {
              for (const id of bIds) ensure(id).G += 1;
              for (const id of aIds) ensure(id).P += 1;
            }
          }
        }
        return out;
      })();

      const resumen = {};
      const allIds = new Set([ ...(awards ? Object.keys(awards) : []), ...Array.from(counts.keys()) ]);
      for (const id of allIds) {
        const c = counts.get(id) || {PJ:0,G:0,E:0,P:0};
        const pts = awards && awards[id] ? awards[id] : 0;
        resumen[id] = { PJ: c.PJ||0, G: c.G||0, E: c.E||0, P: c.P||0, PTS: pts };
      }

      await ref.collection('awards')
        .doc(String(torneo.id || torneo.torneoId || torneo.nombre || Date.now()))
        .set({
          torneoId: torneo.id || torneo.torneoId || null,
          torneoNombre: torneo.nombre || '',
          categoria: torneo.categoria || null,
          sexo: torneo.sexo || null,
          modalidad: (torneo.reglas && torneo.reglas.modalidad) || torneo.modalidad || null,
          aplicadoAt: Date.now(),
          resumen
        }, { merge: true });
    } catch (e) {
      console.warn('No se pudo guardar awards del torneo en ranking', e);
    }



    console.log("Ranking awards applied:", awards);
    alert('Puntos del torneo aplicados al Ranking.');
    return awards;
  }

  // Exponer helpers mínimos por si querés llamarlos desde consola
  window.__rankingHelpers = {
    withRankingDefaults, groupsAllMatchesDone,
    collectLeaguePlacementPoints,
    applyAwardsToRanking
  };

})();

</script>

<script>
/* A4 CLEAN EXPORT v2 */
(function(){
  function findLogoSrc(){
    const sel = [
      'img[alt*="Coachex"]',
      'img[alt*="logo"]',
      '.topbar img',
      'link[rel="icon"]'
    ];
    for(const s of sel){
      const el = document.querySelector(s);
      if(!el) continue;
      if(el.tagName === 'LINK' && el.href) return el.href;
      if(el.src) return el.src;
    }
    return null;
  }

  function formatMeta(t){
    const modo = t.formato === 'eliminacion' ? 'Eliminación' : (t.formato === 'grupos_y_eliminacion' ? 'Grupos + Eliminación' : 'Grupos');
    const modal = t.modalidad === 'dobles' ? 'Dobles' : 'Singles';
    const count = (t.modalidad === 'dobles' ? (t.teams || []).length + ' parejas' : (t.participantes || []).length + ' jugadores');
    const created = t.createdAt ? new Date(t.createdAt).toLocaleDateString() : '';
    const topk = (t.topK != null ? `Top-K: ${t.topK}` : '');
    const idaVuelta = t.idaVuelta ? 'Ida y vuelta: Sí' : 'Ida y vuelta: No';
    return [modo, count, (created ? 'Creado: ' + created : ''), topk, idaVuelta].filter(Boolean).join(' · ');
  }

  
function buildA4Sheet(torneo, showBracket){
  const sheet = document.createElement('div');
  sheet.id = 'a4-sheet';
  sheet.setAttribute('role','document');

  // ===== Header =====
  const header = document.createElement('div');
  header.id = 'a4-header';

  const brand = document.createElement('div');
  brand.id = 'a4-brand';
  const logoSrc = (window.__findLogoSrc ? window.__findLogoSrc() : null);
  if (logoSrc){
    const img = document.createElement('img');
    img.src = logoSrc;
    img.alt = 'Coachex-Pro';
    brand.appendChild(img);
  }
  const btxt = document.createElement('div');
  btxt.textContent = 'Coachex-Pro';
  brand.appendChild(btxt);

  const title = document.createElement('div');
  title.id = 'a4-title';
  title.textContent = (torneo?.nombre || 'Torneo');

  const sub = document.createElement('div');
  sub.id = 'a4-sub';
  sub.textContent = (function(){
    const modo = torneo?.formato === 'eliminacion' ? 'Eliminación' : (torneo?.formato === 'grupos_y_eliminacion' ? 'Grupos + Eliminación' : 'Grupos');
    const count = (torneo?.modalidad === 'dobles' ? (torneo?.teams || []).length + ' parejas' : (torneo?.participantes || []).length + ' jugadores');
    const created = torneo?.createdAt ? new Date(torneo.createdAt).toLocaleDateString() : '';
    const topk = (torneo?.topK != null ? `Top-K: ${torneo.topK}` : '');
    const idaVuelta = torneo?.idaVuelta ? 'Ida y vuelta: Sí' : 'Ida y vuelta: No';
    return [modo, count, (created ? 'Creado: ' + created : ''), topk, idaVuelta].filter(Boolean).join(' · ');
  })();

  header.appendChild(brand);
  header.appendChild(title);
  header.appendChild(sub);
  sheet.appendChild(header);

  // ===== Helpers =====
  const label = (window.labelEntradaCard ? window.labelEntradaCard : (x, t)=> (typeof x==='string'?x:(x?.label||x?.id||'—')));

  function collectKOMatches(node, acc){
    acc = acc || [];
    if (!node) return acc;
    if (Array.isArray(node)){
      node.forEach(n => collectKOMatches(n, acc));
      return acc;
    }
    if (typeof node === 'object'){
      // If looks like a match
      if ('jugadorA' in node || 'jugadorB' in node || 'resultado' in node || 'score' in node){
        acc.push(node);
      }
      // Recurse props
      Object.keys(node).forEach(k => {
        const v = node[k];
        if (v && (typeof v === 'object')) collectKOMatches(v, acc);
      });
    }
    return acc;
  }

  function flattenGroupFixture(t){
    const out = [];
    const fixture = t?.fixture || {};
    const grupos = t?.grupos || [];
    grupos.forEach(g => {
      const gid = g.id || g.nombre;
      const rondas = fixture[gid];
      const list = [];
      if (Array.isArray(rondas)){
        rondas.forEach(r => {
          (r?.matches || r?.partidos || r || []).forEach(m => {
            if (m && (m.jugadorA != null || m.jugadorB != null)){
              list.push(m);
            }
          });
        });
      }
      out.push({ group: g, matches: list });
    });
    return out;
  }

  // ===== Body =====
  const sec = document.createElement('div');
  sec.id = 'a4-section';

  // KO Summary
  if (showBracket && torneo?.cuadro){
    const koCard = document.createElement('div');
    koCard.className = 'a4-card';
    const h = document.createElement('div');
    h.style.fontWeight = '700';
    h.style.marginBottom = '6px';
    h.textContent = 'Fase Final (resumen)';
    koCard.appendChild(h);

    const table = document.createElement('div');
    table.style.display = 'grid';
    table.style.gridTemplateColumns = '1fr';
    table.style.gap = '6px';

    const matches = collectKOMatches(torneo.cuadro, []);
    if (matches.length === 0){
      const item = document.createElement('div');
      item.className = 'a4-item';
      item.textContent = 'No hay cruces registrados.';
      table.appendChild(item);
    } else {
      matches.forEach(m => {
        const A = label(m.jugadorA, torneo);
        const B = label(m.jugadorB, torneo);
        const res = (m.resultado==='A' ? 'Ganador A' : (m.resultado==='B' ? 'Ganador B' : (m.resultado==='D' ? 'Empate' : '')));
        const line = `${A || '—'} vs ${B || '—'}${m.score ? ' · ' + m.score : ''}${res ? ' · ' + res : ''}`;
        const item = document.createElement('div');
        item.className = 'a4-item';
        item.textContent = line;
        table.appendChild(item);
      });
    }

    koCard.appendChild(table);
    sec.appendChild(koCard);
  }

  // Groups Summary (entries + fixture results if exist)
  if (torneo?.grupos){
    const gcard = document.createElement('div');
    gcard.className = 'a4-card';
    const h2 = document.createElement('div');
    h2.style.fontWeight = '700';
    h2.style.marginBottom = '6px';
    h2.textContent = 'Grupos (resumen)';
    gcard.appendChild(h2);

    const groupsWithFx = flattenGroupFixture(torneo);

    (torneo.grupos || []).forEach((g, idx) => {
      const gh = document.createElement('div');
      gh.className = 'a4-muted';
      gh.style.margin = '6px 0';
      gh.textContent = `Grupo ${g.nombre || g.id || ''}`;
      gcard.appendChild(gh);

      // Entradas
      const list = document.createElement('div');
      list.style.display = 'grid';
      list.style.gridTemplateColumns = '1fr';
      list.style.gap = '4px';
      (g.entradas || []).forEach(e => {
        const item = document.createElement('div');
        item.className = 'a4-item';
        item.textContent = label(e, torneo);
        list.appendChild(item);
      });
      gcard.appendChild(list);

      // Partidos del fixture (si hay)
      const fx = groupsWithFx[idx]?.matches || [];
      if (fx.length){
        const fxTitle = document.createElement('div');
        fxTitle.className = 'a4-muted';
        fxTitle.style.margin = '6px 0 2px 0';
        fxTitle.textContent = 'Partidos:';
        gcard.appendChild(fxTitle);

        const fxList = document.createElement('div');
        fxList.style.display = 'grid';
        fxList.style.gridTemplateColumns = '1fr';
        fxList.style.gap = '4px';
        fx.forEach(m => {
          const A = label(m.jugadorA, torneo);
          const B = label(m.jugadorB, torneo);
          const res = (m.resultado==='A' ? 'Ganador A' : (m.resultado==='B' ? 'Ganador B' : (m.resultado==='D' ? 'Empate' : '')));
          const line = `${A || '—'} vs ${B || '—'}${m.score ? ' · ' + m.score : ''}${res ? ' · ' + res : ''}`;
          const item = document.createElement('div');
          item.className = 'a4-item';
          item.textContent = line;
          fxList.appendChild(item);
        });
        gcard.appendChild(fxList);
      }
    });

    sec.appendChild(gcard);
  }

  // Empty state
  if (!sec.children.length){
    const empty = document.createElement('div');
    empty.className = 'a4-item';
    empty.textContent = 'Sin datos para mostrar.';
    sec.appendChild(empty);
  }

  sheet.appendChild(sec);
  return sheet;
}

  window.__findLogoSrc = findLogoSrc;
})();
</script>


<!-- === PDF A4 (centrado + info real) - injected by ChatGPT === -->
<script>
(function(){
  function makeLabelFn(torneo){
    const pools = [
      torneo?.alumnos, torneo?.alumnosList,
      (torneo && torneo.alumnosSnapshot && torneo.alumnosSnapshot.alumnos),
      window.__alumnos, window.alumnos,
      (window.__appState && window.__appState.alumnos)
    ].filter(Boolean);
    const map = new Map();
    pools.forEach(arr => { try{ (arr||[]).forEach(a=>{ if(a?.id) map.set(a.id,a); }); }catch(_){} });
    function alumnoById(id){ return (id ? (map.get(id) || null) : null); }
    function labelAlumnoById(id){
      const a = alumnoById(id);
      if (!a) return id || "—";
      const ap = a.apellido || ""; const no = a.nombre || a.name || "";
      return `${ap ? ap + ", " : ""}${no || a.id || "—"}`.trim();
    }
    return function labelEntrada(e, t){
      t = t || torneo;
      if (t?.modalidad === "dobles") {
        const team = (e && e.members) ? e : (t.teams || []).find(tt => tt.id === (typeof e === "string" ? e : e?.id));
        if (!team) return (e?.label || e?.id || "—");
        if (team.label) return team.label;
        const [id1, id2] = team.members || [];
        const A = labelAlumnoById(id1); const B = labelAlumnoById(id2);
        return (A && B) ? `${A} / ${B}` : (A || B || "—");
      } else {
        if (e?.label) return e.label;
        const id = (typeof e === "string") ? e : e?.id;
        return labelAlumnoById(id);
      }
    };
  }

  function collectKOMatches(node, acc){
    acc = acc || [];
    if (!node) return acc;
    if (Array.isArray(node)){ node.forEach(n => collectKOMatches(n, acc)); return acc; }
    if (typeof node === "object"){
      const isMatch = ("jugadorA" in node) || ("jugadorB" in node) || ("resultado" in node) || ("score" in node);
      if (isMatch) acc.push(node);
      Object.values(node).forEach(v => { if (v && typeof v === "object") collectKOMatches(v, acc); });
    }
    return acc;
  }

  function flattenGroupFixture(t){
    const out = [];
    const fixture = t?.fixture || {};
    const grupos = t?.grupos || [];
    grupos.forEach(g => {
      const gid = g.id || g.nombre;
      const rondas = fixture[gid];
      const list = [];
      if (Array.isArray(rondas)){
        rondas.forEach(r => ((r?.matches || r?.partidos || r || [])).forEach(m => {
          if (m && (m.jugadorA != null || m.jugadorB != null)) list.push(m);
        }));
      }
      out.push({ group: g, matches: list });
    });
    return out;
  }

  function computeChampion(t){
    const ms = collectKOMatches(t?.cuadro, []);
    if (!ms.length) return null;
    const finalM = ms.find(m => m.isFinal || m.final || m.ronda === "final" || m.round === "final") || ms[ms.length-1];
    if (!finalM) return null;
    const res = finalM.resultado;
    const winner = (res === "A") ? finalM.jugadorA : (res === "B" ? finalM.jugadorB : null);
    if (!winner) return null;
    return { winner, score: finalM.score || "" };
  }

  function buildA4TorneoSheet(torneo, showBracket){
    const label = makeLabelFn(torneo);
    const sheet = document.createElement("div");
    sheet.style.cssText = [
      "width:1123px","min-height:794px","background:#fff","color:#0f172a",
      "padding:40px 48px","box-sizing:border-box","border-radius:12px",
      "box-shadow:0 0 0 1px rgba(0,0,0,.04)","font-family:ui-sans-serif,system-ui"
    ].join(";");

    const header = document.createElement("div");
    header.style.cssText = "display:flex;flex-direction:column;align-items:center;gap:8px;margin-bottom:16px";

    const brand = document.createElement("div");
    brand.style.cssText = "display:inline-flex;align-items:center;justify-content:center;gap:10px;font-weight:800;font-size:22px;margin:0 auto;line-height:1";
    (function useLogo(){
      const trySel = ['img[alt*=\"Coachex\"]','img[alt*=\"logo\"]','.topbar img','link[rel=\"icon\"]'];
      let src = null;
      for (const s of trySel){
        const el = document.querySelector(s);
        if (!el) continue;
        src = (el.tagName === "LINK") ? el.href : el.src;
        if (src) break;
      }
      if (src){
        const img = document.createElement("img");
        img.src = src; img.alt = "Coachex-Pro";
        img.style.cssText = "width:28px;height:28px;border-radius:9999px;object-fit:cover;display:inline-block;transform:translateY(2px)";
        brand.appendChild(img);
      }
    })();
    const btxt = document.createElement("div"); btxt.textContent = "Coachex-Pro";
    brand.appendChild(btxt);

    const title = document.createElement("div");
    title.textContent = torneo?.nombre || "Torneo";
    title.style.cssText = "font-size:26px;line-height:1.2;font-weight:800;text-align:center;margin-top:4px";

    const sub = document.createElement("div");
    const modo = torneo?.formato === "eliminacion" ? "Eliminación" : (torneo?.formato === "grupos_y_eliminacion" ? "Grupos + Eliminación" : "Grupos");
    const count = (torneo?.modalidad === "dobles" ? (torneo?.teams || []).length + " parejas" : (torneo?.participantes || []).length + " jugadores");
    const created = torneo?.createdAt ? new Date(torneo.createdAt).toLocaleDateString() : "";
    const topk = (torneo?.topK != null ? `Top-K: ${torneo.topK}` : "");
    const idaVuelta = torneo?.idaVuelta ? "Ida y vuelta: Sí" : "Ida y vuelta: No";
    sub.textContent = [modo, count, (created ? "Creado: " + created : ""), topk, idaVuelta].filter(Boolean).join(" · ");
    sub.style.cssText = "font-size:12px;line-height:1.5;color:#64748b;text-align:center";

    header.appendChild(brand); header.appendChild(title); header.appendChild(sub);
    sheet.appendChild(header);

    const section = document.createElement("div");
    section.style.cssText = "display:flex;flex-direction:column;gap:12px";

    const champion = computeChampion(torneo);
    if (champion){
      const card = document.createElement("div"); card.style.cssText = "border:1px solid #e2e8f0;border-radius:10px;padding:12px";
      const h = document.createElement("div"); h.textContent = "Resultado final"; h.style.cssText = "font-weight:700;margin-bottom:6px";
      const line = document.createElement("div"); line.style.cssText = "font-size:13px";
      line.textContent = `Campeón: ${label(champion.winner, torneo)}${champion.score ? " · " + champion.score : ""}`;
      card.appendChild(h); card.appendChild(line);
      section.appendChild(card);
    }

    if (showBracket && torneo?.cuadro){
      const ko = document.createElement("div"); ko.style.cssText = "border:1px solid #e2e8f0;border-radius:10px;padding:12px";
      const h = document.createElement("div"); h.textContent = "Fase Final (resumen)"; h.style.cssText = "font-weight:700;margin-bottom:6px";
      ko.appendChild(h);
      const list = document.createElement("div"); list.style.cssText = "display:grid;grid-template-columns:1fr;gap:6px";
      const matches = collectKOMatches(torneo.cuadro, []);
      if (!matches.length){
        const item = document.createElement("div"); item.style.cssText = "border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px";
        item.textContent = "No hay cruces registrados."; list.appendChild(item);
      } else {
        matches.forEach(m => {
          const A = label(m.jugadorA, torneo), B = label(m.jugadorB, torneo);
          const res = (m.resultado==="A" ? "Ganador A" : (m.resultado==="B" ? "Ganador B" : (m.resultado==="D" ? "Empate" : "")));
          const item = document.createElement("div"); item.style.cssText = "border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px";
          item.textContent = `${A || "—"} vs ${B || "—"}${m.score ? " · " + m.score : ""}${res ? " · " + res : ""}`;
          list.appendChild(item);
        });
      }
      ko.appendChild(list); section.appendChild(ko);
    }

    if (torneo?.grupos){
      const gc = document.createElement("div"); gc.style.cssText = "border:1px solid #e2e8f0;border-radius:10px;padding:12px";
      const h2 = document.createElement("div"); h2.textContent = "Grupos (resumen)"; h2.style.cssText = "font-weight:700;margin-bottom:6px";
      gc.appendChild(h2);
      const fx = flattenGroupFixture(torneo);
      (torneo.grupos || []).forEach((g, idx) => {
        const gh = document.createElement("div"); gh.textContent = `Grupo ${g.nombre || g.id || ""}`; gh.style.cssText = "color:#64748b;margin:6px 0 4px 0";
        gc.appendChild(gh);
        const elist = document.createElement("div"); elist.style.cssText = "display:grid;grid-template-columns:1fr;gap:4px";
        (g.entradas || []).forEach(e => {
          const item = document.createElement("div"); item.style.cssText = "border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px";
          item.textContent = label(e, torneo); elist.appendChild(item);
        });
        gc.appendChild(elist);
        const mx = fx[idx]?.matches || [];
        if (mx.length){
          const t = document.createElement("div"); t.textContent = "Partidos:"; t.style.cssText = "color:#64748b;margin:6px 0 2px 0";
          gc.appendChild(t);
          const mlist = document.createElement("div"); mlist.style.cssText = "display:grid;grid-template-columns:1fr;gap:4px";
          mx.forEach(m => {
            const A = label(m.jugadorA, torneo), B = label(m.jugadorB, torneo);
            const res = (m.resultado==="A" ? "Ganador A" : (m.resultado==="B" ? "Ganador B" : (m.resultado==="D" ? "Empate" : "")));
            const item = document.createElement("div"); item.style.cssText = "border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px";
            item.textContent = `${A || "—"} vs ${B || "—"}${m.score ? " · " + m.score : ""}${res ? " · " + res : ""}`;
            mlist.appendChild(item);
          });
          gc.appendChild(mlist);
        }
      });
      section.appendChild(gc);
    }

    if (!section.children.length){
      const empty = document.createElement("div"); empty.style.cssText = "border:1px solid #e5e7eb;border-radius:10px;padding:10px;font-size:12px";
      empty.textContent = "Sin datos para mostrar."; section.appendChild(empty);
    }
    sheet.appendChild(section);
    return sheet;
  }

  window.__buildA4TorneoSheet = buildA4TorneoSheet;
})();
</script>

<script>
async 
</script>

<script>
// ====== TORNEOS: Exportación PDF A4 (clona #bracket-canvas) ======

/**
 * Construye un contenedor A4 apaisado y clona el bracket visible (id: #bracket-canvas).
 * Centra logo + "Coachex-Pro" y agrega título/metadatos.
 */
function buildA4Root(torneo) {
  const root = document.createElement('div');
  Object.assign(root.style, {
    position: 'fixed',
    left: '-99999px', top: '0',
    width: '1123px', minHeight: '794px',   // A4 horizontal aprox a 96 dpi
    background: '#fff',
    padding: '16px',
    border: '1px solid #e2e8f0',
    borderRadius: '12px',
    fontFamily: 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial'
  });

  // Header centrado (logo + Coachex-Pro)
  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.justifyContent = 'center';
  header.style.gap = '10px';
  header.style.marginBottom = '8px';

  // Usa <link rel="icon"> si existe; si no, fallback a ./img/logo_favicon.png o logo_favicon.png
  let logoSrc = null;
  const linkIcon = document.querySelector('link[rel="icon"], link[rel="shortcut icon"]');
  if (linkIcon && linkIcon.href) logoSrc = linkIcon.href;
  if (!logoSrc) {
    const cands = ['./img/logo_favicon.png', './logo_favicon.png', 'img/logo_favicon.png', 'logo_favicon.png'];
    for (const c of cands) { try { logoSrc = c; break; } catch(_) {} }
  }

  const logo = new Image();
  logo.src = logoSrc || 'logo_favicon.png';
  logo.width = 28; logo.height = 28;
  logo.style.borderRadius = '9999px';
  logo.alt = 'Coachex-Pro';
  header.appendChild(logo);

  const title = document.createElement('div');
  title.style.fontSize = '20px';
  title.style.fontWeight = '800';
  title.textContent = 'Coachex-Pro';
  header.appendChild(title);
  root.appendChild(header);

  // Título del torneo + metadatos
  const name = document.createElement('div');
  name.style.fontSize = '22px';
  name.style.fontWeight = '800';
  name.style.textAlign = 'center';
  name.style.marginBottom = '2px';
  name.textContent = torneo?.nombre || 'Torneo';
  root.appendChild(name);

  const meta = document.createElement('div');
  meta.style.fontSize = '12px';
  meta.style.color = '#64748b';
  meta.style.textAlign = 'center';
  meta.style.marginBottom = '12px';

  const esDobles = torneo?.modalidad === 'dobles';
  const parejas  = (torneo?.teams || []).length;
  const jugadores = esDobles ? parejas*2 : (torneo?.participantes || []).length;

  const formato = (torneo?.formato === 'eliminacion' ? 'Eliminación' :
                  torneo?.formato === 'grupos_y_eliminacion' ? 'Grupos + Eliminación' : 'Grupos');

  const creado = torneo?.createdAt || torneo?.fechaCreacion || Date.now();
  const topK = torneo?.topK != null ? ' · Top-K: ' + torneo.topK : '';
  const idaV = (torneo?.formato !== 'eliminacion') ? (' · Ida y vuelta: ' + (torneo?.idaVuelta ? 'Sí' : 'No')) : '';

  meta.textContent = [
    formato,
    esDobles ? (parejas + ' parejas (' + jugadores + ' jugadores)') : (jugadores + ' jugadores'),
    'Creado: ' + new Date(creado).toLocaleDateString(),
    topK, idaV
  ].filter(Boolean).join(' · ');
  root.appendChild(meta);

  // Clonar el bracket visible
  const src = document.getElementById('bracket-canvas');
  if (src) {
    const clone = src.cloneNode(true);
    clone.id = 'bracket-canvas-pdf';
    clone.style.transformOrigin = '0 0';
    root.appendChild(clone);
  } else {
    const warn = document.createElement('div');
    warn.style.fontSize = '12px';
    warn.style.color = '#ef4444';
    warn.textContent = '(No se pudo clonar las llaves. Mostrando sólo encabezado)';
    root.appendChild(warn);
  }

  document.body.appendChild(root);
  return root;
}

// Espera a que carguen imágenes dentro de un nodo
async function waitImages(el) {
  const imgs = Array.from(el.querySelectorAll('img')).filter(i => !i.complete || i.naturalWidth === 0);
  if (!imgs.length) return;
  await Promise.all(imgs.map(img => new Promise(res => {
    img.addEventListener('load', res, { once:true });
    img.addEventListener('error', res, { once:true });
  })));
}

// Exportar A4 a PDF (apaisado), clonando el canvas de brackets
async function exportPDF_A4(torneo, showBracket, setShowBracket) {
  try {
    let revert = false;
    if (!document.getElementById('bracket-canvas') && typeof setShowBracket === 'function') {
      setShowBracket(true);
      revert = true;
      await new Promise(r => setTimeout(r, 60));
    }

    const el = buildA4Root(torneo);
    await waitImages(el);

    if (!window.html2canvas) { alert('html2canvas no está disponible.'); return; }
    const canvas = await html2canvas(el, { backgroundColor: '#ffffff', scale: 2 });

    document.body.removeChild(el);
    if (revert) setShowBracket(false);

    const jsPDFCtor = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF;
    if (!jsPDFCtor) { alert('jsPDF no está disponible.'); return; }

    const pdf = new jsPDFCtor('l','pt','a4');
    const W = pdf.internal.pageSize.getWidth();
    const H = pdf.internal.pageSize.getHeight();
    const ratio = Math.min(W / canvas.width, H / canvas.height);
    const w = canvas.width * ratio;
    const h = canvas.height * ratio;

    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', (W - w) / 2, (H - h) / 2, w, h);
    const fn = (torneo?.nombre ? torneo.nombre.replace(/\s+/g,'_') : 'torneo') + '.pdf';
    pdf.save(fn);
  } catch (e) {
    console.error(e);
    alert('No se pudo exportar PDF.');
  }
}
</script>

<script>
// === COMPROBANTE MENSUAL (standalone) ===
// No toca nada del resto de la app. Usa jsPDF (y autoTable si está) + formatCurrency existente.
window.generarComprobanteMensual = async function generarComprobanteMensual({
  alumno = {},            // { id, nombre, apellido, dni? }
  mensualidad = {},       // { id?, periodo?, periodoYMD?, fecha?, inicio?, fin?, plan?, monto, metodo?, reciboNro?, notas? }
  perfil = {},            // datos del profesor/club si querés mostrar
  club = {},              // opcional: { nombre?, direccion? }
  periodoLabel,           // si lo pasás, se usa tal cual (ej: "septiembre 2025")
  filename                // opcional, nombre del archivo PDF
} = {}) {
  if (!window.jspdf || !window.jspdf.jsPDF) {
    alert("jsPDF no está cargado");
    return;
  }
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();

  // Helpers
  const MESES_LARGO = ["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"];
  const parseYMDLocal = (ymd) => {
    if (!ymd || typeof ymd !== "string") return null;
    const [y,m,d] = ymd.split("-").map(Number);
    if (!y || !m) return null;
    return new Date(y, (m||1)-1, d||1, 0, 0, 0, 0);
  };
  const todayDMY = () => {
    const d = new Date();
    const dd = String(d.getDate()).padStart(2,"0");
    const mm = String(d.getMonth()+1).padStart(2,"0");
    return `${dd}/${mm}/${d.getFullYear()}`;
  };
  const safe = (s) =>
  String(s || "")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^\w.-]+/g, "_")
    .replace(/_{2,}/g, "_")
    .replace(/^_+|_+$/g, "");

  // Periodo
  let periodoSrc = mensualidad.periodo || mensualidad.periodoYMD || mensualidad.fecha || mensualidad.inicio || mensualidad.mes;
  let periodoTxt = periodoLabel || "";
  if (!periodoTxt) {
    if (typeof periodoSrc === "string") {
      // Formatos aceptados: "YYYY-MM", "YYYY-MM-DD"
      let d = null;
      if (/^\d{4}-\d{2}$/.test(periodoSrc)) d = parseYMDLocal(periodoSrc + "-01");
      else d = parseYMDLocal(periodoSrc);
      if (d) periodoTxt = `${MESES_LARGO[d.getMonth()]} ${d.getFullYear()}`;
    }
    if (!periodoTxt) {
      const d = new Date();
      periodoTxt = `${MESES_LARGO[d.getMonth()]} ${d.getFullYear()}`;
    }
  }

  const alumnoNombre = [alumno.apellido, alumno.nombre].filter(Boolean).join(", ") || alumno.nombre || alumno.id || "—";
  const dni = alumno.dni ? String(alumno.dni) : "";
  const plan = mensualidad.plan || mensualidad.tipo || mensualidad.abono || mensualidad.frecuencia || "Mensualidad";
  const metodo = mensualidad.metodo || mensualidad.metodoPago || mensualidad.forma || "—";
  const notas = mensualidad.notas || "";
  const numero = mensualidad.reciboNro || mensualidad.id || ("M-" + Math.random().toString(36).slice(2,8).toUpperCase());
  const monto = (typeof formatCurrency === "function")
    ? formatCurrency(mensualidad.monto)
    : (new Intl.NumberFormat('es-AR', { style:'currency', currency:'ARS', minimumFractionDigits:0, maximumFractionDigits:0 }).format(Number(mensualidad.monto||0)));

  // Encabezado con logo (si existe ./logo_favicon.png)
  let y = 16;
  try {
    const resp = await fetch("./logo_favicon.png");
    if (resp.ok) {
      const blob = await resp.blob();
      const dataUrl = await new Promise((res) => { const r = new FileReader(); r.onload = () => res(r.result); r.readAsDataURL(blob); });
      try { doc.addImage(dataUrl, "PNG", 12, 10, 18, 18); } catch(_) {}
    }
  } catch(_) {}
  doc.setFontSize(15); doc.text("Comprobante de Mensualidad", 40, y); y += 6;
  doc.setFontSize(10); doc.text(`Período: ${periodoTxt}`, 40, y); y += 5;
  const profe = `${perfil?.nombre || ""} ${perfil?.apellido || ""}`.trim() || (perfil?.nombreCompleto || "");
  if (profe) { doc.text(`Profesor/a: ${profe}`, 40, y); y += 5; }
  if (club?.nombre) { doc.text(`Club: ${club.nombre}`, 40, y); y += 5; }

  // Datos de alumno + comprobante
  y += 3;
  doc.setFontSize(11);
  doc.text(`N°: ${numero}`, 420, 16); // esquina sup derecha
  doc.text(`Fecha de emisión: ${todayDMY()}`, 420, 22);

  // Cuerpo (con autoTable si está)
  const rows = [
    ["Alumno/a", alumnoNombre + (dni ? ` (DNI ${dni})` : "")],
    ["Plan", plan],
    ["Método de pago", metodo],
    ["Monto", monto],
  ];
  if (notas) rows.push(["Notas", String(notas)]);

  if (doc.autoTable) {
    doc.autoTable({
      startY: y + 4,
      head: [["Campo", "Valor"]],
      body: rows,
      styles: { fontSize: 9, cellPadding: 2 },
      headStyles: { fillColor: [63,63,65], textColor: 255, fontStyle: "bold" },
      theme: "grid",
      columnStyles: { 0: { cellWidth: 120 } },
      margin: { left: 12, right: 12 }
    });
    y = doc.lastAutoTable.finalY + 10;
  } else {
    doc.setFontSize(10);
    let x1 = 14, x2 = 140;
    rows.forEach(([k,v]) => {
      doc.text(`${k}:`, x1, y);
      doc.text(String(v), x2, y);
      y += 6;
    });
    y += 6;
  }

  // Pie
  const pageH = doc.internal.pageSize.height;
  doc.setFontSize(8);
  doc.text("Generado por Coachex-Pro", 12, pageH - 10);

  // Guardar
  const name = filename || `Comprobante_Mensual_${safe(alumnoNombre)}_${safe(periodoTxt)}.pdf`;
  doc.save(name);
};
</script>



<script>
/* =================== HELPERS (definidos UNA sola vez) =================== */
if (!window.collectPhoneStrings) window.collectPhoneStrings = function collectPhoneStrings(obj, max = 30) {
  const out = [], stack = [obj], seen = new Set();
  while (stack.length && out.length < max) {
    const cur = stack.pop();
    if (!cur || typeof cur !== "object" || seen.has(cur)) continue;
    seen.add(cur);
    for (const k in cur) {
      const v = cur[k];
      if (typeof v === "string" && /\d{7,}/.test(v)) out.push(v);
      else if (v && typeof v === "object") stack.push(v);
    }
  }
  return out;
};

if (!window.toWaMsisdn) window.toWaMsisdn = function toWaMsisdn(raw, country = "AR") {
  let s = String(raw || "").trim();
  if (s.startsWith("+") || s.startsWith("00")) {
    s = s.replace(/^00/, "+").replace(/[^\d+]/g, "");
  } else {
    s = s.replace(/[^\d]/g, "");
  }
  if (country === "AR") {
    const only = s.replace(/\D/g, "");
    if (s.startsWith("+54")) {
      let rest = only.slice(2);
      rest = rest.replace(/^0+/, "");
      rest = rest.replace(/(^\d{2,4})15/, "$1");
      if (!/^9/.test(rest)) rest = "9" + rest;
      return "54" + rest;
    }
    let loc = only.replace(/^0+/, "");
    loc = loc.replace(/(^\d{2,4})15/, "$1");
    return "549" + loc;
  }
  if (s.startsWith("+")) return s.slice(1).replace(/\D/g, "");
  return s.replace(/\D/g, "");
};

if (!window.findAlumnoPhone) window.findAlumnoPhone = function findAlumnoPhone(alumnoNombre) {
  const row = [...document.querySelectorAll("table tbody tr")]
    .find(r => (r.querySelector("td:nth-child(2)")?.textContent || "").trim() === alumnoNombre);
  const id = row?.dataset?.alumnoId || null;
  let alumno = null;

  if (id && window.__alumnosById) alumno = window.__alumnosById[id];

  if (!alumno && Array.isArray(window.__alumnos)) {
    alumno = window.__alumnos.find(a => {
      const etiqueta = `${a?.apellido ? a.apellido + ", " : ""}${a?.nombre || a?.name || ""}`.trim();
      const etiqueta2 = `${a?.nombre || ""} ${a?.apellido || ""}`.trim();
      return etiqueta === alumnoNombre || etiqueta2 === alumnoNombre;
    });
  }
  if (!alumno) return null;

  const candidates = Array.from(new Set([
    alumno?.whatsapp, alumno?.WhatsApp, alumno?.wasap, alumno?.wpp, alumno?.wapp,
    alumno?.telefono, alumno?.tel, alumno?.cel, alumno?.celular,
    alumno?.movil, alumno?.phone, alumno?.mobile,
    alumno?.["teléfono"], alumno?.["móvil"],
    alumno?.contactoPadre, alumno?.contactoMadre,
    alumno?.contacto?.telefono, alumno?.contacto?.whatsapp,
    ...window.collectPhoneStrings(alumno)
  ].filter(Boolean)));

  const raw = candidates.find(s => /\d{7,}/.test(String(s)));
  return raw ? window.toWaMsisdn(raw, "AR") : null;
};
</script>

<script>
/* ========== HISTORIAL DE PAGOS: botón “Comprobante ▾” para ABONO MENSUAL (ES5-safe) ========== */
(function(){
  var MESES = ["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"];

  function toNumber(v){
    var s = String(v == null ? "" : v)
      .replace(/\./g,"")
      .replace(",",".")
      .replace(/[^0-9.-]/g,"");
    var n = Number(s);
    return isFinite(n) ? n : 0;
  }

  function periodoFrom(concepto, fechaYMD){
    var m = String(concepto||"").match(/abono\s+mensual\s*-\s*(.+)$/i);
    if (m && m[1]) return m[1].trim();
    if (/^\d{4}-\d{2}-\d{2}$/.test(fechaYMD||"")) {
      var d = new Date(fechaYMD + "T00:00:00");
      return MESES[d.getMonth()] + " " + d.getFullYear();
    }
    return "";
  }

  function buildWaText(d){
    var montoTxt = (typeof window.formatCurrency === "function")
      ? window.formatCurrency(d.monto)
      : new Intl.NumberFormat('es-AR', { style:'currency', currency:'ARS', minimumFractionDigits:0, maximumFractionDigits:0 }).format(d.monto || 0);
    return [
      "Hola " + d.alumnoNombre + "! Te envío el comprobante de abono mensual.",
      "",
      "Período: " + d.periodo,
      "Fecha de pago: " + d.fecha,
      "Método: " + d.metodo,
      "Monto: " + montoTxt,
      "",
      "Generado por Coachex-Pro"
    ].join("\n");
  }

  function cellText(tds, i){
    var el = tds[i];
    return ((el && el.textContent) || "").trim();
  }

  function extractRowInfo(row){
    var tds = row.querySelectorAll("td");
    var fecha = cellText(tds,0);
    var alumnoNombre = cellText(tds,1);
    var concepto = cellText(tds,2);
    var montoTxt = cellText(tds,3);
    var metodo = cellText(tds,4);
    var monto = toNumber(montoTxt);
    var periodo = periodoFrom(concepto, fecha);
    return { fecha:fecha, alumnoNombre:alumnoNombre, concepto:concepto, monto:monto, metodo:metodo, periodo:periodo };
  }

  function addDropdown(row){
    var tds = row.querySelectorAll("td");
    var accionesTd = tds[5];
    if (!accionesTd) return;
    if (accionesTd.querySelector(".btn-comprobante-mensual")) return;

    var wrap = document.createElement("div");
    wrap.className = "relative inline-block ml-1";

    var btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-comprobante-mensual px-3 py-1.5 text-sm border rounded-xl bg-white hover:bg-slate-50 flex items-center";
    btn.textContent = "Comprobante ▾"; // el icono se aplica abajo

    var menu = document.createElement("div");
    menu.className = "absolute z-50 mt-1 w-44 bg-white border rounded-xl shadow hidden";
    menu.innerHTML = [
      '<button type="button" class="w-full text-left px-3 py-2 text-sm hover:bg-slate-50" data-act="pdf">Descargar PDF</button>',
      '<button type="button" class="w-full text-left px-3 py-2 text-sm hover:bg-slate-50" data-act="wa">Enviar por WhatsApp</button>'
    ].join("");

    btn.addEventListener("click", function(e){
      e.stopPropagation();
      menu.classList.toggle("hidden");
    });
    document.addEventListener("click", function(){ menu.classList.add("hidden"); });

    menu.addEventListener("click", function(ev){
      var target = ev.target || ev.srcElement;
      var act = target ? target.getAttribute("data-act") : null;
      if (!act) return;
      var d = extractRowInfo(row);
      if (act === "pdf") {
        if (typeof window.generarComprobanteMensual === "function") {
          window.generarComprobanteMensual({
            alumno: { nombre: d.alumnoNombre },
            mensualidad: { monto: d.monto, metodo: d.metodo, fecha: d.fecha },
            periodoLabel: d.periodo,
            perfil: window.__perfil || {},
            club: window.__clubActivo || {}
          });
        } else {
          alert("Falta window.generarComprobanteMensual");
        }
      } else if (act === "wa") {
        var text = buildWaText(d);
        var msisdn = (window.findAlumnoPhone ? window.findAlumnoPhone(d.alumnoNombre) : null);
        var base = msisdn ? ("https://wa.me/" + msisdn) : "https://wa.me/";
        window.open(base + "?text=" + encodeURIComponent(text), "_blank");
      }
      menu.classList.add("hidden");
    });

    wrap.appendChild(btn);
    wrap.appendChild(menu);
    accionesTd.appendChild(wrap);
  }

  function isMensualRow(row){
    var tds = row.querySelectorAll("td");
    var concepto = ( (tds[2] && tds[2].textContent) || "" ).toLowerCase();
    var metodo   = ( (tds[4] && tds[4].textContent) || "" ).toLowerCase();
    return /abono\s+mensual/.test(concepto) || /mensual/.test(metodo);
  }

  function scan(){
    var rows = document.querySelectorAll("table tbody tr");
    for (var i=0;i<rows.length;i++){
      try { if (isMensualRow(rows[i])) addDropdown(rows[i]); } catch(e){}
    }
  }

  var obs = new MutationObserver(function(){ scan(); });
  obs.observe(document.body, { subtree: true, childList: true });

  window.addEventListener("load", scan);
  setTimeout(scan, 1000);
})();
</script>

<script>
/* ========== AGENDA · CONTACTOS: WhatsApp por CADA CONTACTO (fila) (ES5-safe) ========== */
(function waPerContactRow(){

  function findTelHeaderIndex(table){
    var ths = table.querySelectorAll("thead th");
    for (var i=0;i<ths.length;i++){
      if (/\btel[eé]fono\b/i.test((ths[i].textContent||""))) return i;
    }
    return -1;
  }

  function ensureAccionHeader(table){
    var theadRow = table.querySelector("thead tr");
    if (!theadRow) return;
    var hasAccion = false;
    for (var i=0;i<theadRow.children.length;i++){
      if (/acci[oó]n/i.test(theadRow.children[i].textContent||"")) { hasAccion = true; break; }
    }
    if (!hasAccion) {
      var th = document.createElement("th");
      th.textContent = "Acción";
      theadRow.appendChild(th);
    }
  }

  function ensureRowButton(row, getMsg){
    if (row.querySelector(".btn-wa-contacto")) return;

    var table = row.closest ? row.closest("table") : row.parentNode;
    var telIdx = findTelHeaderIndex(table);
    var telCell = null;
    if (telIdx >= 0) telCell = row.children[telIdx];
    else telCell = row.querySelector("td:nth-child(2)");

    var telRaw = telCell ? (telCell.textContent || "").trim() : "";
    var msisdn = telRaw ? (window.toWaMsisdn ? window.toWaMsisdn(telRaw, "AR") : null) : null;

    var accionCell = row.querySelector("td.td-accion-wa");
    if (!accionCell) {
      accionCell = document.createElement("td");
      accionCell.className = "td-accion-wa";
      row.appendChild(accionCell);
    } else {
      if (accionCell.querySelector(".btn-wa-contacto")) return;
      accionCell.textContent = "";
    }

    var btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-wa-contacto px-3 py-1.5 text-sm border rounded-xl bg-white hover:bg-slate-50";
    btn.textContent = "WhatsApp";
    btn.addEventListener("click", function(){
      var base = msisdn ? ("https://wa.me/" + msisdn) : "https://wa.me/";
      var text = getMsg();
      window.open(base + "?text=" + encodeURIComponent(text), "_blank");
    });

    accionCell.appendChild(btn);
  }

  function processCard(card){
    var textarea = card.querySelector("textarea");
    var table = card.querySelector("table");
    if (!textarea || !table) return;

    ensureAccionHeader(table);

    var getMsg = function(){ return textarea.value || ""; };
    var trs = table.querySelectorAll("tbody tr");
    for (var i=0;i<trs.length;i++) ensureRowButton(trs[i], getMsg);
  }

  function scan(){
    var cards = document.querySelectorAll("div");
    for (var i=0;i<cards.length;i++){
      var card = cards[i];
      var hasTextarea = !!card.querySelector("textarea");
      var hasTable = !!card.querySelector("table");
      var looksLikeContacts = /tel[eé]fono/i.test(card.textContent || "");
      if (hasTextarea && hasTable && looksLikeContacts) processCard(card);
    }
  }

  var obs = new MutationObserver(scan);
  obs.observe(document.body, { childList: true, subtree: true });

  window.addEventListener("load", scan);
  setTimeout(scan, 600);
})();
</script>

<script>
/* === Igualar ícono/estilo con el "Comprobante" de pago por clase (SVG o emoji 📄) (ES5-safe) === */
(function syncMensualComprobanteIcon(){
  function getAttrNum(el, name){
    if (!el || !el.getAttribute) return NaN;
    var v = el.getAttribute(name);
    var n = v != null ? parseFloat(v) : NaN;
    return isFinite(n) ? n : NaN;
  }

  function findReference() {
    var refBtn = null;
    var all = document.querySelectorAll("button,a");
    for (var i=0;i<all.length;i++){
      var el = all[i];
      var t = (el.textContent || "").trim().toLowerCase();
      if (/comprobante\b/.test(t) && !el.classList.contains("btn-comprobante-mensual")) { refBtn = el; break; }
    }
    if (!refBtn) return { kind: null };

    // a) Nodo gráfico
    var node = refBtn.querySelector("svg, img, i, [data-icon], .icon, .bi, .fa");
    if (node) {
      var csI = getComputedStyle(node);
      var size = {
        w: parseFloat(csI.width)  || getAttrNum(node,"width")  || 16,
        h: parseFloat(csI.height) || getAttrNum(node,"height") || 16,
        mr: csI.marginRight || "4px",
        va: csI.verticalAlign || "-2px"
      };
      var color = getComputedStyle(refBtn).color;
      return { kind: "node", node: node, size: size, color: color };
    }

    // b) Emoji 📄
    var txt = (refBtn.textContent || "").trim();
    if (txt.indexOf("📄") === 0) {
      var color2 = getComputedStyle(refBtn).color;
      return { kind: "emoji", emoji: "📄", color: color2, mr: "6px", va: "-1px", scale: 0.9 };
    }

    return { kind: null };
  }

  function apply(){
    try{
      var ref = findReference();
      if (!ref.kind) return;
      var list = document.querySelectorAll(".btn-comprobante-mensual");
      for (var i=0;i<list.length;i++){
        var btn = list[i];
        if (ref.color) btn.style.color = ref.color;

        var olds = btn.querySelectorAll("svg, img, i, [data-icon], .icon, .bi, .fa, .ico-doc-emoji");
        for (var j=0;j<olds.length;j++){ var n = olds[j]; if (n && n.parentNode) n.parentNode.removeChild(n); }

        if (ref.kind === "node") {
          var clone = ref.node.cloneNode(true);
          if (clone.tagName && clone.tagName.toLowerCase() === "svg") {
            clone.setAttribute("width",  Math.round(ref.size.w));
            clone.setAttribute("height", Math.round(ref.size.h));
          } else {
            clone.style.width  = Math.round(ref.size.w) + "px";
            clone.style.height = Math.round(ref.size.h) + "px";
          }
          clone.style.marginRight   = ref.size.mr;
          clone.style.verticalAlign = ref.size.va;
          clone.style.color         = "inherit";
          btn.insertBefore(clone, btn.firstChild);
        } else if (ref.kind === "emoji") {
          var span = document.createElement("span");
          span.className = "ico-doc-emoji";
          span.textContent = ref.emoji;
          span.style.marginRight   = ref.mr;
          span.style.verticalAlign = ref.va;
          span.style.fontSize      = (ref.scale) + "em";
          span.style.lineHeight    = "1";
          btn.insertBefore(span, btn.firstChild);
        }

        if (!/comprobante/i.test(btn.textContent)) btn.append(" Comprobante ▾");
      }
    } catch(e){ /* evitar que un error bloquee la página */ }
  }

  var mo = new MutationObserver(apply);
  mo.observe(document.body, { childList: true, subtree: true });
  window.addEventListener("load", apply);
  setTimeout(apply, 300);
})();
</script>
<style>
/* —— Mesas más lindas —— */
.pretty-table thead th{
  position: sticky; top: 0; z-index: 2;
  background: #fff; /* para que no transparente al hacer scroll */
}
.pretty-table tbody tr:nth-child(even){ background: rgba(0,0,0,.02); }
.pretty-table tbody tr:hover{ background: rgba(0,0,0,.04); }

/* —— Botones suaves —— */
.btn-soft{
  transition: transform .12s ease, box-shadow .12s ease, background-color .12s ease;
  will-change: transform;
}
.btn-soft:hover{
  transform: translateY(-1px);
  box-shadow: 0 6px 16px rgba(0,0,0,.08);
}

/* —— Toast minimal —— */
.toast-host{ position:fixed; right:16px; bottom:16px; z-index:99999; }
.toast{
  background:#111; color:#fff; padding:10px 12px; border-radius:12px;
  margin-top:8px; box-shadow:0 8px 30px rgba(0,0,0,.2);
  opacity:0; transform: translateY(10px); transition: opacity .25s, transform .25s;
  font-size: 14px;
}
.toast.show{ opacity:1; transform: translateY(0); }
</style>

<script>
/* ===== Micro-polish ES5-safe ===== */
(function(){
  /* 1) Mejoras visuales de tablas (sticky + zebra + hover) */
  function prettifyTables(){
    var tables = document.querySelectorAll("table");
    for (var i=0;i<tables.length;i++){
      var t = tables[i];
      if ((t.className||"").indexOf("pretty-table") === -1) {
        t.className += (t.className?" ":"") + "pretty-table";
      }
    }
  }

  /* 2) Botones suaves (Comprobante mensual + WhatsApp) */
  function softenButtons(){
    var sels = [".btn-comprobante-mensual", ".btn-wa-contacto"];
    for (var s=0; s<sels.length; s++){
      var btns = document.querySelectorAll(sels[s]);
      for (var i=0;i<btns.length;i++){
        var b = btns[i];
        if ((b.className||"").indexOf("btn-soft") === -1) {
          b.className += " btn-soft";
        }
      }
    }
  }

  /* 3) Toast minimal */
  var _toastHost = null;
  function toast(msg, ms){
    if (!_toastHost){
      _toastHost = document.createElement("div");
      _toastHost.className = "toast-host";
      document.body.appendChild(_toastHost);
    }
    var el = document.createElement("div");
    el.className = "toast";
    el.textContent = msg;
    _toastHost.appendChild(el);
    setTimeout(function(){ el.className += " show"; }, 10);
    setTimeout(function(){
      el.style.opacity = "0"; el.style.transform = "translateY(10px)";
      setTimeout(function(){ if (el.parentNode) el.parentNode.removeChild(el); }, 250);
    }, ms || 1500);
  }
  window._toast = toast; // por si querés usarlo desde otros scripts

  /* 4) Click para copiar teléfonos (columna “Teléfono”) */
  function findTelHeaderIndex(table){
    var ths = table.querySelectorAll("thead th");
    for (var i=0;i<ths.length;i++){
      if (/\btel[eé]fono\b/i.test((ths[i].textContent||""))) return i;
    }
    return -1;
  }
  function fallbackCopy(text){
    var ta = document.createElement("textarea");
    ta.value = text; ta.style.position="fixed"; ta.style.top="-1000px"; ta.style.left="-1000px";
    document.body.appendChild(ta); ta.select();
    try{ document.execCommand("copy"); toast("Teléfono copiado"); }catch(e){}
    if (ta.parentNode) ta.parentNode.removeChild(ta);
  }
  function enableCopyPhones(){
    var tables = document.querySelectorAll("table");
    for (var i=0;i<tables.length;i++){
      var table = tables[i];
      var telIdx = findTelHeaderIndex(table);
      if (telIdx < 0) continue;
      var rows = table.querySelectorAll("tbody tr");
      for (var r=0;r<rows.length;r++){
        var row = rows[r];
        var cell = row.children[telIdx];
        if (!cell) continue;
        if (cell.getAttribute("data-copy-phone-init") === "1") continue;
        cell.setAttribute("data-copy-phone-init", "1");
        cell.style.cursor = "copy";
        cell.title = "Copiar al portapapeles";
        (function(cell){
          cell.addEventListener("click", function(){
            var txt = (cell.textContent || "").replace(/\s+/g," ").trim();
            if (!txt) return;
            if (navigator.clipboard && navigator.clipboard.writeText){
              navigator.clipboard.writeText(txt).then(function(){ toast("Teléfono copiado"); }, function(){ fallbackCopy(txt); });
            } else {
              fallbackCopy(txt);
            }
          });
        })(cell);
      }
    }
  }

  /* Escucha cambios de DOM para re-aplicar */
  function scan(){ prettifyTables(); softenButtons(); enableCopyPhones(); }
  var mo = new MutationObserver(scan);
  mo.observe(document.body, { childList:true, subtree:true });
  window.addEventListener("load", scan);
  setTimeout(scan, 400);
})();
</script>

</script>

</body>
</html>
